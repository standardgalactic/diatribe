A Universal Training Algorithm for Quantum Deep Learning
Guillaume Verdon,1, 2, 4 Jason Pye,1, 2, 4 and Michael Broughton3
1Department of Applied Mathematics, University of Waterloo, Waterloo, Ontario, N2L 3G1, Canada
2Institute for Quantum Computing, University of Waterloo, Waterloo, Ontario, N2L 3G1, Canada
3School of Computer Science, University of Waterloo, Waterloo, Ontario, N2L 3G1, Canada
4Perimeter Institute for Theoretical Physics, Waterloo, Ontario, N2L 2Y5, Canada
(Dated: June 27, 2018)
We introduce the Backwards Quantum Propagation of Phase errors (Baqprop) principle, a cen-
tral theme upon which we construct multiple universal optimization heuristics for training both
parametrized quantum circuits and classical deep neural networks on a quantum computer. Baqprop
encodes error information in relative phases of a quantum wavefunction deﬁned over the space of net-
work parameters; it can be thought of as the uniﬁcation of the phase kickback principle of quantum
computation and of the backpropagation algorithm from classical deep learning. We propose two
core heuristics which leverage Baqprop for quantum-enhanced optimization of network parameters:
Quantum Dynamical Descent (QDD) and Momentum Measurement Gradient Descent (MoMGrad).
QDD uses simulated quantum coherent dynamics for parameter optimization, allowing for quan-
tum tunneling through the hypothesis space landscape. MoMGrad leverages Baqprop to estimate
gradients and thereby perform gradient descent on the parameter landscape; it can be thought of
as the quantum-classical analogue of QDD. In addition to these core optimization strategies, we
propose various methods for parallelization, regularization, and meta-learning as augmentations to
MoMGrad and QDD. We introduce several quantum-coherent adaptations of canonical classical
feedforward neural networks, and study how Baqprop can be used to optimize such networks. We
develop multiple applications of parametric circuit learning for quantum data, and show how to per-
form Baqprop in each case. One such application allows for the training of hybrid quantum-classical
neural-circuit networks, via the seamless integration of Baqprop with classical backpropagation.
Finally, for a representative subset of these proposed applications, we demonstrate the training of
these networks via numerical simulations of implementations of QDD and MoMGrad.
CONTENTS
I. Introduction
2
II. Background
5
A. Continuous Quantum Registers
5
B. Discrete Simulation of Continuous Quantum
Registers
6
1. Quantum Phase Estimation
8
C. Quantum Phase Kickback
8
1. Quantum Gradients
10
III. Quantum Parametric Optimization
10
A. Basic Principles
10
1. Quantum Feedforward and Baqprop
10
2. Full-batch Eﬀective Phase Kicks
12
3. Eﬀective Forces
14
B. Quantum Dynamical Descent
15
1. Core Algorithm
15
2. Heisenberg Picture Update rule
17
3. Connections to QAOA
17
4. Adiabatic Limit
18
C. Momentum Measurement Gradient
Descent
20
D. Phase Space Visualization
22
IV. Further Quantum Descent Methods
23
A. Batching & Parallelization
23
1. Quantum Stochastic Descent
23
2. Sequential Mini-Batching
24
3. Coherently Accumulating Momentum
Parallelization
25
4. Quantum Random Access Memory
Mini-batching
27
B. Discrete Parametric Optimization
28
1. Kicking Hybrid Discrete-Continuous
Parameters
28
2. Continuous-Discrete Hybrid QDD
29
3. Continuous-Discrete Hybrid Momentum
Measurement Gradient Descent
30
4. Continuum-Embedded Discrete
Optimization
30
5. Estimating Continuum Gradients with
Single Qubits
31
C. Regularization & Variants
32
1. Parameter/Weight Decay
32
2. Meta-networked Interacting Swarm
Optimization
32
3. Dropout
34
D. Quantum Meta-Learning
36
1. Overview
36
2. Quantum hyper-parameter Descent
37
3. Network Architecture Optimization
40
V. Quantum Neural Network Learning
41
A. Quantum-Coherent Neural Networks
41
1. Classical-to-Quantum Computational
Embedding
41
2. Classical Data Phase Kicking
42
3. Abstract Quantum Neuron
43
arXiv:1806.09729v1  [quant-ph]  25 Jun 2018

2
4. Quantum Neural Network Feedforward &
Baqprop
44
B. Quantum Phase Error Backpropagation:
Layerwise Analysis
46
1. Operator Chain Rule
48
C. Implementations of Quantum Coherent
Neurons
49
1. Hybrid CV-DV Neurons
49
2. CV-only
50
VI. Quantum Parametric Circuit Learning
50
A. Parametric Ansatze & Error
Backpropagation
51
1. From Classically- to
Quantumly-Parametrized Ansatze
51
2. Quantum Parametric Circuit Error
Backpropagation
52
B. Quantum State Exponentiation
53
1. Single state exponentiation
53
2. Sequential Exponential Batching
54
3. QRAM Batching
55
C. Quantum State Learning
55
1. Quantum Pure State Learning
55
2. Quantum Mixed State Learning
56
D. Quantum Unitary & Channel Learning
56
1. Supervised Unitary Learning
56
2. Supervised Channel Learning
57
3. Unsupervised Unitary Learning
57
4. Unsupervised Channel Learning
58
E. Quantum
Classiﬁcation/Regression/Measurement
Learning
59
1. Overview
59
2. Output Encodings & Implementation
Options
59
F. Quantum Code Learning
60
1. Quantum Autoencoders: Compression
Code Learning
60
2. Denoising Quantum Autoencoder
63
3. Quantum Error Correcting Code
Learning
63
G. Generative Adversarial Quantum Circuits
65
1. Classical Generative Adversarial
Networks Review
65
2. Generative Adversarial Quantum
Circuits
65
H. Parametric Hamiltonian Optimization
68
1. Hamiltonian-Parallelized Gradient
Accumulation
68
I. Hybrid Quantum Neural-Circuit Networks
70
1. Fully Coherent Hybrid Networks
70
2. Hybrid Quantum-Classical Networks
71
VII. Numerical Experiments
72
A. Quantum Neural Deep Learning
72
1. Application & Methods
72
2. Implementation & Results
73
B. Quantum Parametric Hamiltonian
Optimization
74
1. Application & Methods
75
2. Implementation & Results
75
C. Quantum Unitary Learning
76
1. Application & Methods
76
2. Implementation & Results
76
D. Hybrid Neural-Circuit Learning
77
1. Application & Methods
77
2. Implementation & Results
77
VIII. Discussion & Outlook
78
1. Near-term considerations
78
2. Further-term considerations
79
IX. Conclusion
80
X. Acknowledgements
81
References
81
I.
INTRODUCTION
The ﬁeld of classical deep learning [1] has seen a rapid
expansion in interest and number of breakthrough appli-
cations in recent years [2-11].
Deep learning consists of a class of algorithms within
the broader class of machine learning algorithms, which
are mostly employed either to identify patterns in a given
dataset and/or generate new data mimicking such pat-
terns. At their core, many machine learning algorithms
consist of three main components. First is the model:
a parametrized hypothesis class of functions, usually ar-
ranged in a network of layered compositions of simpler
parametric functions. Networks with multiple layers are
called deep, and are the subclass of models considered in
deep learning. Second is a cost function: a metric to eval-
uate how well speciﬁc hypotheses model the data. The
third and ﬁnal key component is the optimizer: an algo-
rithmic strategy used to search over the space of hypothe-
ses in order to minimize the cost function to a suﬃcient
degree.
A central concept in the optimization of such networks
of compositions is the principle of backwards propagation
of errors, also known as the backpropagation algorithm.
Typically the cost function (error) of such a layered net-
work is a function strictly of the output (ﬁnal layer) of
the network (or occasionally of the output of certain sub-
sets of the network). The backpropagation algorithm is
a means for information about the gradient of the cost
function (with respect to the network parameters) to
spread eﬃciently throughout the network, beginning at
the output and propagating backwards through the com-
positional layers. Since the (negative) gradient provides
the direction of steepest descent in the landscape of hy-
potheses, this propagation can be leveraged to optimize
the network parameters in order to ﬁnd a local minimum

3
of the cost function. Many, if not all, canonical network
optimization methods employ the backpropagation prin-
ciple in some manner [3, 12]. It is often deemed that the
recent resurgence and successes of classical deep learning
can be traced back to the ﬁrst demonstrations of imple-
mentations backpropagation algorithm [12, 13].
In this paper, we introduce a quantum-native back-
propagation principle (Sec. III A 1), called the backwards
quantum propagation of phase errors (Baqprop).
This
Baqprop principle allows for the eﬃcient optimization of
quantumly-parametrized networks on a quantum com-
puter. Previously, such quantum networks typically con-
sisted of classically-parametrized quantum operations.
By considering versions of these networks using quan-
tum parameters, we can exploit the quantum mechan-
ical properties of the wavefunction over the hypothesis
space to aid in the propagation of gradient information
throughout the network. More speciﬁcally, Baqprop em-
ploys the phase kickback principle of quantum comput-
ing to induce relative phases between diﬀerent branches
of the wavefunction in the superposition over hypoth-
esis space.
These relative phases will contain the de-
sired gradient information. Baqprop will thus allow for
quantum-enhanced optimization over multiple types of
quantum parametric network hypothesis classes.
Note
that the technique of leveraging phase kickback for gra-
dients was originally pioneered by Jordan [14], and later
improved upon in Ref. [15]. In our background section
(Sec. II), we show how this gradient technique is related
to phase estimation in the context of both continuous
variable quantum information and qudits/qubits. There-
fore, in the context of training quantum-parametric net-
works, Baqprop provides a uniﬁed view of both classical
backpropagation and quantum phase estimation.
Further included in this work is the introduction of two
main Baqprop-based parameter optimization strategies
(Sec. III B & III C). Both approaches leverage the cost
function error signal encoded in the relative phases of the
quantum parameter wavefunction, but provide diﬀerent
means of using this error signal to update the parameters
during an iteration of the optimization. The ﬁrst of these
strategies is a fully quantum-coherent method of opti-
mization, called Quantum Dynamical Descent (QDD).
This method is motivated by the recognition that these
relative phases can be seen as induced by an eﬀective po-
tential acting on the parameters. The QDD algorithm is
then a descent of the parameter optimization landscape
via quantum simulation of the Schr¨odinger dynamics un-
der the inﬂuence of this eﬀective potential.
The sec-
ond method is a quantum-classical approach, which in-
volves a quantum measurement of the Baqprop-induced
relative phase shifts in the wavefunction of the param-
eters. This allows for the estimation of the local gradi-
ent of the cost function in the parameter space, which
can then be used in gradient descent to descend the cost
landscape. Since these relative phase shifts can be in-
terpreted as kicks in the momenta of the parameters,
we call this approach Momentum Measurement Gradient
Descent (MoMGrad).
The broad aim of this work is to bridge classical and
quantum deep learning theory within a uniﬁed framework
for optimization on quantum computers.
Establishing
this bridge between theories allows for an exchange of
powerful tools across ﬁelds, as well as the possibility to
mutually improve understanding of both topics. In this
spirit, in Section IV we introduce multiple techniques
as augmentations of the core optimization methods of
Section III (QDD and MoMGrad), which are directly in-
spired from methods of classical deep learning [16-18].
For example, we introduce methods for parallelization
(Sec. IV A 3), regularization (Sec. IV C 1), and hyper-
parameter optimization (meta-learning, Sec. IV D). In
addition to these various augmented optimization strate-
gies, in Sections V and VI we explore ways of leverag-
ing Baqprop in numerous applications of quantum para-
metric transformation learning for classical and quantum
data modelling. In particular, for classical data learning
we examine quantum-coherent analogues of traditional
classical neural networks (Sec. V), while for quantum
data we discuss the training of a number of applications
of Quantum Parametric Circuits (Sec. VI). We later test
the eﬃcacy of training some of these proposed applica-
tions with QDD and MoMGrad via numerical simulations
of quantum computation in Section VII.
To provide further context for this work, let us brieﬂy
describe how it ﬁts into the current state of quantum ma-
chine learning literature. Inspired by classical machine
learning, the ﬁeld of quantum machine learning began as
an exploration of the possibility of using quantum algo-
rithms to identify patterns in either quantum or classical
data using a quantum computer [19]. Early quantum ma-
chine learning work took a similar path as early classical
machine learning; before the advent of the connectionist
approach (deep learning), the focus lied mostly on so-
called analogizer-type algorithms [13] . Such early quan-
tum algorithms include Quantum Principal Component
Analysis [20], Quantum Support Vector Machines [21],
and other kernel methods [22, 23]. Many of these algo-
rithms focused on the analysis of classical data embedded
into a quantum wavefunction via a theoretical quantum
computer component called a Quantum Random Access
Memory [24]. The goal of such an embedding was to ex-
ploit the exponential dimensionality of the Hilbert space
to encode data in the probability amplitudes of a multi-
qubit wavefunction, in order to potentially gain an expo-
nential speedup over classical algorithms. The feasibility
and practicality of this data-loading scheme, with realis-
tic noise conditions and error correction overheads taken
into account, remains a debated topic to this day [25].
Beyond the data loading issue, part of the quantum ma-
chine learning ﬁeld has moved away from analogizer-type
methods [13] towards parametric networks (resembling
deep learning) for similar reasons to those responsible
for the eventual dominance of classical deep learning over
classical kernel-type methods. [26-29] Namely, the rea-
soning being ﬂexibility and modelling capacity: not all

4
data is linearly separable (using SVMs), thus requiring a
hand-picked kernel, and not all data is well-suited to a
Principal Component Analysis.
Before we delve into the more recent literature on
quantum parametric networks, we will ﬁrst mention ear-
lier work involving deep learning on quantum comput-
ers. Similar to the progression of classical deep learning,
the ﬁrst forms of quantum neural networks to be studied
were Boltzmann machines.
In classical machine learn-
ing, some of the work ﬁrst incorporating backpropaga-
tion was in the context of deep networks of coupled spin-
like neurons called Deep Boltzmann Networks [30]. On
the quantum side, analog quantum computers allowed for
a physical implementation of networks of qubits whose
statistics mimic those of Boltzmann machines [31-34].
This general avenue of research focused on determining
whether quantum computers can accelerate the training
of classical neural network models. Due to the possibility
of superpositions of the joint state of the neurons, and
thereby of quantum tunneling in the energy landscape,
it was hoped that Quantum Annealing could provide a
speedup over classical annealing optimization methods
for such neural network models. Despite early claims of
a speedup [35], certain bottlenecks such as the embedding
problem, qubit quality, and thermal noise [36] would ob-
scure whether there could truly be a quantum advantage
for Quantum Annealing, especially with the advent of
quantum-inspired classical algorithms designed to com-
pete with these machines [37].
The question thus remained: is there a way to leverage
the quantum properties of superposition, entanglement,
and tunneling in order to gain an optimization advantage
for a classical neural network? Later work continued on
this avenue of research, [38] but most work pivoted to
quantum parametric circuits, which we will return to be-
low.
In this paper, we provide a comprehensive approach
to training classical neural networks on a quantum com-
puter for the purposes of classical data learning (Sec. V).
All techniques make use of superposition and entangle-
ment (Sec. III), and some techniques employ tunneling
directly (Sec. III B, IV D). We also provide an in-depth
analysis of quantum backpropagation of the error sig-
nal in these quantum-coherent neural networks, thus ex-
plicitly relating quantum and classical backpropagation.
This bridging of the theories allows for further exchange
of insights and techniques, as well as a merging of both
the classical and quantum backpropagation principles
(see Sec. VI I 2). Furthermore, not only can the network
parameters be optimized, but so can the network archi-
tecture and hyper-parameters in a quantum tunneling
procedure in the space of trained networks, which we
call Quantum Meta-Learning (QMetaL, Section IV D).
Although we do not directly claim a general speedup
for training classical neural nets, in Section III B we
explicitly relate Quantum Dynamical Descent (QDD)
to the Quantum Approximate Optimization Algorithm
(QAOA) [39-41] and the Quantum Adiabatic Algorithm
(QAA) [42-44]. QAA is the predecessor to Quantum An-
nealing, the latter of which is considered to be the open
quantum system analogue of QAA. The QAOA is akin
to a variationally-optimized, temporally coarse-grained,
approximate quantum simulation of the QAA. Both the
QAA and the QAOA have been shown to exhibit a quan-
tum advantage in some optimization scenarios [40, 45].
As such, the possibility may be open to show a speedup
for Quantum Dynamical Descent and/or Quantum Meta-
Learning for certain types of networks and optimization
scenarios. We leave further analysis of such advantages
for future work.
More recent approaches to quantum deep learning have
moved away from attempting to train classical models
on a quantum computer, and have rather involved a
quantum-native model called quantum parametric cir-
cuits (QPCs) [26-29] . As their name implies, QPCs con-
sist of multiple parametric quantum operations arranged
in a sequential, layered structure, in a similar fashion to
a neural network. In the literature, QPCs are sometimes
called Quantum Variational Algorithms [29] or Quantum
Neural Networks [26, 27]. To avoid confusion with the
quantum-coherent neural networks from Section V, we
will exclusively use the term Quantum Parametric Cir-
cuits.
QPCs can learn from either classical data or quantum
data, and have been shown to be able to do so on near-
term noisy quantum hardware [46, 47], mainly through
the use of classical-quantum hybrid optimization schemes
[48].
Such optimization schemes ﬁrst execute multiple
runs of a parametric circuit on a quantum processing
unit for a certain set of parameters. Through these runs
the expectation value of certain observables at the output
of the circuit are obtained and fed to a classical process-
ing unit. The classical computer is then tasked with the
extremization of this expectation value subject to varia-
tions in the parameters, using the quantum computer as
a black box. Thus the classical and quantum computer
work in tandem to variationally optimize over the space
of parametric circuits, hence the name quantum-classical
hybrid optimization.
Despite a recent rapid expansion of this body of work,
the question remains open as to whether there can be a
more eﬃcient means to optimize over the space of quan-
tum networks either in the short term (Noisy Interme-
diate Scale Quantum Devices [49] era) and long term
(post Fault-Tolerance and Error Correction [50]). Fur-
thermore, a backpropagation principle could provide a
uniﬁed approach to the optimization of quantum net-
works, and provide insights as to which ansatze are eﬃ-
ciently trainable [51].
The work presented in this paper tackles these is-
sues.
We show explicitly how to use Baqprop for a
number of applications of Quantum Parametric Cir-
cuits in Section VI. A main draw using Baqprop is
that it requires only on the order of one query (feedfor-
ward) per optimization step. This can be compared to
the above-mentioned classical ﬁnite-diﬀerence (quantum-

5
classical) methods which usually require a number of
queries which scales at least linearly with the number
of parameters. The applications featured in Section VI
either build upon previously existing work [52, 53], or
relate to works released during the writing of this pa-
per [26, 27, 54].
In particular, we study the follow-
ing tasks:
quantum state learning (Sec. VI C), quan-
tum unitary learning (Sec. VI D 1 & VI D 3), quantum
channel learning (Sec. VI D 2 & VI D 4), quantum clas-
siﬁcation/regression (Sec. VI E), quantum compression
code (Sec. VI F 1 & VI F 2) and quantum error correcting
code learning (Sec. VI F 3), quantum generative adver-
sarial learning (Sec. VI G), as well as parametric Hamil-
tonian optimization (Sec. VI H). Finally, we propose an
application which combines both classical neural net-
works and quantum parametric circuits in a hybrid net-
work (Sec. VI I 2).
We show how to leverage Baqprop
to train these hybrid neural-circuit networks either ex-
clusively on a quantum processing unit, or in a hy-
brid quantum-classical fashion, combining classical back-
propagation with Baqprop, and allowing for the seam-
less backpropagation of error information through the
classical-quantum interface.
As this paper is intended for a broad audience, we be-
gin with an introduction of core background quantum
computing concepts in Section II, including continuous-
variable (CV) and discrete variable (DV) phase space,
phase estimation, basic operations, and gradient estima-
tion. Although not essential to understanding this paper,
a knowledge of standard deep learning may be useful to
the reader who would like to compare classical versions of
certain protocols to their respective quantum versions in-
troduced in this paper. We encourage the reader looking
to fully connect concepts of classical and quantum deep
learning to consult one of many possible references which
cover the basics, such as gradient descent, stochastic gra-
dient descent, minibatch gradient descent, and hyper-
parameter optimization [1].
II.
BACKGROUND
A.
Continuous Quantum Registers
A quantum register that stores a real number is deﬁned
by an observable with a spectrum consisting of R, which
we will denote here by ˆΦ :=
R
R dΦ Φ |Φ⟩⟨Φ|. The Hilbert
space upon which this operator acts is L2(R). Shifts be-
tween eigenstates of the operator ˆΦ are generated by a
conjugate momentum operator, denoted ˆΠ, which satis-
ﬁes [ˆΦ, ˆΠ] = i (where throughout we set ℏ= 1).
Addition and multiplication of real numbers are com-
mon operations performed during a computation. In or-
der to implement these operations as unitaries on quan-
tum registers, they need to be reversible. This is typi-
cally achieved by retaining one or more of the inputs in
the output of the computation. For example, addition of
two quantum real numbers in eigenstates |Φ1⟩and |Φ2⟩
(respectively), can be achieved with
e−iˆΦ1 ˆΠ2 : |Φ1, Φ2⟩7→|Φ1, Φ1 + Φ2⟩.
(1)
Here we have used one of the output registers to store one
of the inputs, and the other to store the sum of the two
input values. Note that this implementation of addition
can be thought of as a von Neumann measurement of
the ﬁrst register by the second.
Addition can also be
achieved somewhat less eﬃciently by retaining both input
values and storing the output in a third register (which
is initialized to the state |Φ3 = 0⟩):
e−iˆΦ1 ˆΠ3e−iˆΦ2 ˆΠ3 : |Φ1, Φ2, 0⟩7→|Φ1, Φ2, Φ1 + Φ2⟩.
(2)
Enacting multiplication of two quantum real numbers
typically involves using a third register for the output
(initialized to |Φ3 = 0⟩). The unitary for multiplication
is
e−iˆΦ1 ˆΦ2 ˆΠ3 : |Φ1, Φ2, 0⟩7→|Φ1, Φ2, Φ1Φ2⟩.
(3)
These basic operations will be used extensively in the
paper.
An illustration of addition of two continuous registers
is provided in Fig. 1. The ﬁgure consists of the plots of
the Wigner functions before and after the ﬁrst version of
addition for two registers initialized to Gaussian states.
Here we will only employ Wigner functions for purposes
of illustration, but for completeness, we have deﬁned the
Wigner function of a continuous register in state ˆρ to be:
Wc(x, p) :=
Z dx′dp′
2π
tr[ ˆD†
c(x′, p′)ˆρ]e−i(x′p+p′x+p′x′/2),
(4)
where
ˆDc(x, p) :=
1
√
2π e−ipˆΦe−ixˆΠ.
(5)
One of the simplest physical systems with a quantum
real number as its degree of freedom is the quantum har-
monic oscillator, deﬁned by a Hamiltonian:
ˆH =
1
2m
ˆΠ2 + m
2 ω2(ˆΦ −Φ0)2,
(6)
where m and ω are the oscillator mass and frequency (re-
spectively), and Φ0 simply sets the location of the min-
imum of the potential term. A collection of continuous
quantum variables will often be arranged as a vector of
operators, ˆΦ := (ˆΦn)N
n=1. (Throughout, we will be us-
ing the notation a = (an)n to denote a vector whose nth
component is an.) A set of coupled quantum harmonic
oscillators, with degrees of freedom ˆΦ, in the simplest
case (of equal masses) are associated with a Hamiltonian
H =
1
2m
ˆΠT ˆΠ + 1
2(ˆΦ −Φ0)T K(ˆΦ −Φ0)
(7)
where K is a positive-deﬁnite matrix which encodes the
couplings.
It is a basic fact of such a system that its

6
Figure 1. CV adder. In plots (a) and (b) we have two initial
Gaussian pointer states initialized with Φ centered at 1 and
2, respectively. In plots (c) and (d) we show these two reg-
isters after the addition, where plot (c) retains the input of
the ﬁrst register and plot (d) shows the output on the second
register. We see that, as expected, the Gaussian in (d) is cen-
tered at the value 3. Here we have employed Gaussian states
of ﬁnite variance, since ˆΦ eigenstates are unphysical, hence
there is some noise in the input and output values for these
registers. Also, in plot (c) we have that the Wigner function
is broadened in the Π direction due to phase kickback (which
we will treat in Subsection II C). In plot (d), the variance in
the Φ direction is increased due to uncertainty in Φ of the two
registers before the addition.
ground state, |0⟩, is a Gaussian wavefunction when rep-
resented in the joint eigenbasis of ˆΦ:
⟨Φ|0⟩= [det(mW /π)]1/4e−m
2 (Φ−Φ0)T W (Φ−Φ0),
(8)
where W :=
q
1
mK (recall, K is positive-deﬁnite).
B.
Discrete Simulation of Continuous Quantum
Registers
If one has access to a discrete system, for example,
a collection of qubits on a quantum computer, then it
is possible to approximate the behavior of a continuous
register. A register which stores a qudit of dimension d
is deﬁned by the operator
ˆJd :=
d−1
X
j=0
j |j⟩⟨j| ,
(9)
acting on the Hilbert space H = Cd. If one has access to
N qubits, it is possible to construct ˆJd for d = 2N as
ˆJ2N =
N
X
n=1
2n−2(ˆI(n)
2
−ˆZ(n)
2
)
= 2N −1
2
−
N
X
n=1
2n−2 ˆZ(n)
2
,
(10)
where ˆI(n)
2
and ˆZ(n)
2
are the identity and the Pauli-Z
operator (respectively) for the nth qubit. Note that in
the above equation, and throughout this paper, constant
terms added to operators should be treated as propor-
tional to the identity.
The operator ˆJd can be used to simulate a continuous
operator ˆΦ on a ﬁnite interval, [a, b] ⊂R, by identify-
ing the eigenvalues of ˆJd with discrete samples on the
interval. Then one can write the simulated continuous
variable on the interval [a, b] as:
ˆΦd := (b −a)
(d −1)
ˆJd + aˆId,
(11)
where ˆId is the identity operator for the qudit.
One
means of deﬁning a momentum operator is as the gener-
ator of shifts in the value of the continuous or discrete
register. Such an operator can be written as the Fourier
transform (continuous or discrete, respectively) of the ob-
servable corresponding to the value of the register. For a
continuous register storing a quantum real number, the
Fourier transform is:
ˆFc |x⟩:=
Z
R
dy
√
2π e−ixy |y⟩.
(12)
The momentum operator from the previous section can
thus alternatively be deﬁned as
ˆΠ = ˆF †
c ˆΦ ˆFc.
(13)
From this deﬁnition, it is straightforward to show that ˆΠ
generates shifts in the register: e−iαˆΠ |x⟩= |x + α⟩, for
any α ∈R.
In analogy with the continuum, one can deﬁne a dis-
crete Fourier transform by
ˆFd |j⟩:=
1
√
d
d−1
X
k=0
ω−jk
d
|k⟩,
(14)
(where ωd := e2πi/d), and an analogous discrete momen-
tum operator by
ˆKd := ˆF †
d ˆJd ˆFd.
(15)
It is easy to show that this operator also generates shifts
in the eigenbasis of ˆJd. Explicitly, for some a ∈Zd,
ω−a ˆ
Kd
d
|j⟩= |(j + a)
mod d⟩.
(16)

7
Although at times we will ﬁnd it necessary to work
with ˆJd and ˆKd directly, often it is more convenient to
work with the exponentiated operators: ˆZd := ω−ˆ
Jd
d
and
ˆXd := ω−ˆ
Kd
d
.
Notice that we could also write ˆXd =
ˆF †
d ˆZd ˆFd. These are the Heisenberg-Weyl operators which
satisfy the relation, ˆZd ˆXd = ω−1
d
ˆXd ˆZd, in analogy with
the displacement operators used in the Weyl relations for
continuous systems.
Simulation of a continuous momentum operator on the
interval [a, b] using a qudit can be achieved with:
ˆΠd := (d −1)
(b −a)
ˆKd.
(17)
Note that this is not simply the discrete Fourier trans-
form of ˆΦd, since in the continuum we should have a
Schr¨odinger representation of ˆΠ as −i∂/∂Φ.
If ˆΦ has
units of length, then ˆΠ should have units of inverse
length, therefore the scaling of the two operators should
be diﬀerent. Also, we do not have a constant oﬀset for
the momentum operator so that it is centered at zero
momentum.
Now let us examine the exponentiated versions of these
simulated position and momentum operators. First, it
will be useful to derive an expression for ˆZα
d and ˆXα
d
for arbitrary α ∈R (note that the case where α ∈Zd
is straightforward). Because the map z 7→zα is locally
analytic, we can use the (Riesz) functional calculus to
deﬁne ˆZα
d as
ˆZα
d :=
d−1
X
j=0
ω−αj
d
|j⟩⟨j| ,
(18)
and continue to write ˆXα
d := ˆF †
d ˆZα
d ˆFd.
Note that al-
though we can write ˆZd = P
j∈Zd ω−j
d
|j⟩⟨j|, with a
sum over Zd, the sum for ˆZα
d is taken over the set
{0, . . . , d −1}. This is because, for arbitrary α ∈R, in
order to determine (ω−j
d )α ≡eα log(ω−j
d
), we must choose
a branch of the complex logarithm, which breaks the pe-
riodic structure of the phases, i.e., ω−α(j+d)
d
̸= ω−αj
d
for
α ̸∈Zd.
There is an alternative form of the operator ˆZα
d which
we will occasionally ﬁnd convenient. Due the local an-
alyticity of the map z 7→zα, one can in principle write
a local power series for ˆZα
d in terms of integer powers
of ˆZd. However, since we also have that ˆZd
d = ˆId, this
series will collapse in order to give a representation of
ˆZα
d in terms of a superposition of ﬁnite powers, ˆZk
d, with
k ∈{0, . . . , d−1}. To obtain such a form explicitly, let us
ﬁrst deﬁne the following orthonormal basis for operators
on Cd:
ˆDd(q, p) :=
1
√
d
ˆZp
d ˆXq
d,
(19)
where q, p ∈Zd. These operators are orthonormal with
respect to the Hilbert-Schmidt inner product, ⟨A, B⟩:=
tr(A†B). To demonstrate that they are a basis, we note
that
|j⟩⟨k| =
1
√
d
X
p∈Zd
ωjp
d ˆDd(p, j −k),
(20)
i.e., they can be used to represent an arbitrary matrix
element of an operator acting on Cd. Using this relation,
it is simple to show that, for arbitrary α ∈R, one can
write
ˆZα
d =
X
k∈Zd
∆(α −k) ˆZk
d,
(21)
ˆXα
d =
X
k∈Zd
∆(α −k) ˆXk
d ,
(22)
where
∆(γ) := 1
d
d−1
X
j=0
ωγj
d
= 1
dω(d−1)γ/2
d
sin(πγ)
sin(πγ/d).
(23)
Hence, ˆZα
d and ˆXα
d can be represented as a superposition
of phases and displacements (respectively).
Notice that ∆(γ) is peaked around γ = 0. Therefore,
for example, if we apply ˆXα
d to a computational basis
state, |j⟩, then the value of the register is shifted to a
digital approximation of α, with errors if α ̸∈Zd. (We
demonstrate this fact explicitly in Fig. 2 below in the
context of phase estimation.)
With this in hand, let us consider the exponentiated
versions of our simulated continuous operators ˆΦd and
ˆΠd. Using the above, one can write
ω−αˆΠd
d
= P
k∈Zd ∆

α

d−1
b−a

−k

ˆXk
d ,
(24)
ω−β ˆΦd
d
= P
k∈Zd ∆

β

b−a
d−1

−k

ˆZk
d.
(25)
Consider, for example, beginning with the state |j⟩. In
the simulated interval, this corresponds to an eigenvector
of the simulated position operator, ˆΦd, with eigenvalue

b−a
d−1

j + a ∈[a, b]. Now suppose we apply a simulated
continuous displacement, ω−αˆΠd
d
, to this state. Then we
arrive at the state
ω−αˆΠd
d
|j⟩=
X
k∈Zd
∆

α
d −1
b −a

−k

|j + k⟩.
(26)
This state is peaked around a digital approximation to
the value j + k ∼j + α

d−1
b−a

. Thus, it is approximately
an eigenvalue of the simulated position operator ˆΦd with
eigenvalue

b−a
d−1

j + a + α.
That is, the value of ˆΦd
has been shifted by approximately α, hence the operator
ω−αˆΠd
d
is a simulation of a displacement of the eigenstates
of ˆΦd.

8
Of course, the error in approximation of the shift in α
is due to the fact that one can only get a certain preci-
sion for a ﬁnite d. Thus, for a given d, ideally we would
like the shift of the discrete register to be the closest
integer k to α

d−1
b−a

.
However, here we have a prob-
abilistic distribution over diﬀerent integer values, so we
will not obtain the closest integer approximation with
certainty.
If using qubits, one technique for suppress-
ing the probability of error is to use more qubits than
the desired precision and ignore these extra qubits when
performing a measurement or subsequent computations.
It is a standard result (see, for example, Ref. [55]) that
in order to obtain an approximation accurate to n bits
of precision with probability 1 −ϵ, one must use at least
N = n + ⌈log(2 + 1/2ϵ)⌉qubits for the simulation.
Other issues which can arise during a computation
with the simulated continuous operators are overﬂow and
underﬂow errors. An overﬂow error is simply a shift, α,
of the register which goes beyond the range [a, b]. An
underﬂow error is a shift that is too small to be resolved
by the discretization scale.
So far in this section, we have seen that it is possi-
ble to simulate the kinematic structure of a continuous
quantum system using a suﬃciently large digital system.
Insofar as the dynamics is concerned, in Ref. [56], it was
shown that it is possible to simulate the dynamics of a
quantum harmonic oscillator using a Hamiltonian
ˆHd = 1
2 ˆp2
d + 1
2 ˆx2
d,
(27)
where in our notation these operators can be written
ˆxd =
r
2π
d
d −1
b −a

(ˆΦd −a) −d
2

,
ˆpd = −
r
2π
d
 b −a
d −1

ˆΠd + d
2

.
(28)
1.
Quantum Phase Estimation
The ﬁnal tool we will review in this subsection is the
phase estimation algorithm, which can be seen as a hy-
brid continuous-discrete variable operation.
As above,
let ˆΦ and ˆΠ be the continuous variable and its conju-
gate momentum, and let ˆΦd and ˆΠd be corresponding
simulated continuous operators.
The phase estimation
algorithm is a von Neumann measurement of the contin-
uous variable by the simulated discrete variable, and can
be summarized by the operator:
ω−ˆΦˆΠd
d
.
(29)
We see that this is a straightforward extension of the
continuous shifts of the discrete registers from before,
but now the magnitude of the shift is controlled by a
continuous quantum register. Often this algorithm is im-
plemented by taking the discrete Fourier transforms out
of the exponential and applying a controlled phase oper-
ator: ω−ˆΦˆΠd
d
= ˆF †
dω
−( d−1
b−a)
2 ˆΦ(ˆΦd−a)
d
ˆFd. This is due to the
fact that it is straightforward to construct ˆΦd from Pauli-
Z qubit operators for d = 2N, and then the controlled-
phase gate breaks into a product of 2-local controlled-
phase gates:
ω
−ˆΦˆΠ2N
2N
= ω
−(2N −1)2
2(b−a) ˆΦ
2N
ˆF †
2N
N
Y
n=1
ω

2N −1
b−a

2n−2 ˆΦ ˆ
Z(n)
2
2N
ˆF2N .
(30)
Note that throughout this paper, all products of oper-
ators will be ordered as:
N
Y
n=1
ˆUn := ˆUN · · · ˆU2 ˆU1.
(31)
An illustration of the phase estimation algorithm is
provided in Fig. 2. The plots are of the Wigner func-
tions of the continuous and discrete registers before and
after the algorithm. The continuous Wigner function is
deﬁned as in the previous subsection. The deﬁnition of
the discrete Wigner function used here (for odd d) is:
Wd(q, p) := 1
d
X
q′,p′∈Zd
tr[ ˆD†
d(q′, p′)ˆρ]ω−(q′p+p′q+2−1p′q′)
d
,
(32)
where 2−1 := (d + 1)/2 is the multiplicative inverse of 2
in Zd for odd d (cf., Ref. [57]).
More generally, the shift could be controlled by an ar-
bitrary observable, ˆA, from any type of register.
For
example, this observable could be a Hamiltonian. If this
register is in an eigenstate of the observable, then the
phase estimation algorithm provides a digital approxi-
mation to the eigenvalue of that observable. Explicitly,
suppose ˆA |α⟩= α |α⟩, then
ω−ˆ
AˆΠd
d
|α, 0⟩= |α⟩⊗
X
k∈Zd
∆

α
d −1
b −a

−k

|k⟩, (33)
where a, b should be chosen so that the interval [a, b] con-
tains the spectrum of ˆA (or at least the desired eigenvalue
α).
C.
Quantum Phase Kickback
To every action, there is an equal and opposite reac-
tion. Although this archaic dogma is no longer a central
tenet of modern physics, remnants of Newton's third law
make occasional appearances, particularly in quantum
computing. In more general terms, this law makes the
point that generically a coupling between two physical
systems causes them to react to one another. Concretely
this is due to the coupling inducing generalized forces
appearing in the equations of motion of both systems.
In quantum mechanics, these coupling terms appear in

9
Figure 2. Phase Estimation. In plots (a) and (b), we have the
Wigner functions of the initial states of both the continuous
and discrete registers (respectively). The discrete register was
chosen to be a qudit of dimension d = 63. The continuous
register is initialized to a highly squeezed Gaussian pointer
state with Φ centered at 2. The discrete register is initialized
to a null state.
Plot (c) demonstrates the phase kickback
on the momentum of the continuous register (discussed in
the next subsection), while plot (d) is the result of the von
Neumann measurement. Here we chose a = 0 and b = 5, so
that the discrete-continuous conversion factor is (d −1)/(b −
a) = 12.4. Hence, for a von Neumann measurement of a value
of Φ = 2, the discrete register is centered at q = 25, which is
the closest integer approximation to 2×(d−1)/(b−a) = 24.8.
the generators of the unitary operators which evolve the
interacting systems, although the eﬀect on one or both
systems may not be apparent.
For example,
consider the case of a controlled-
displacement on the position basis of two continuous reg-
isters,
e−iˆΦc ˆΠt : |Φc, Φt⟩7→|Φc, Φt + Φc⟩.
(34)
It would seem that the operation had no eﬀect on the
control register. However, we can see this is not so by
examining the action on the momentum basis,
e−iˆΦc ˆΠt : |Πc, Πt⟩7→|Πc −Πt, Πt⟩.
(35)
Hence, the control register is only left unchanged if in
a position eigenstate, and the target register is only left
unchanged if in a momentum eigenstate.
Often, this back-action is more easily visualized in the
Heisenberg picture. We see that under this controlled-
displacement, the operators of the two registers evolve
as:
Ad[eiˆΦc ˆΠt](ˆΦc) = ˆΦc
Ad[eiˆΦc ˆΠt](ˆΠc) = ˆΠc −ˆΠt
Ad[eiˆΦc ˆΠt](ˆΦt) = ˆΦt + ˆΦc
Ad[eiˆΦc ˆΠt](ˆΠt) = ˆΠt
(36)
where Ad[ ˆU]( ˆA) := ˆU ˆA ˆU †.
An analogous eﬀect plays a prominent role in quantum
computing, where it goes by the name of phase kickback.
Suppose we consider a controlled-NOT gate,
ˆCNOT := |0⟩⟨0|c ⊗ˆIt + |1⟩⟨1|c ⊗ˆXt,
(37)
acting on two qubits. In the Z-basis, this acts as
ˆCNOT : |zc, zt⟩7→|zc, zt ⊕zc⟩,
(38)
and in the X-basis,
ˆCNOT : |xc, xt⟩7→|xc ⊕xt, xt⟩,
(39)
where the X eigenstates are identiﬁed as |x = 0⟩= |+⟩
and |x = 1⟩= |−⟩. In the Heisenberg picture, this looks
like
Ad[ ˆCNOT ]( ˆZc) = ˆZc
Ad[ ˆCNOT ]( ˆXc) = ˆXc ⊗ˆXt
Ad[ ˆCNOT ]( ˆZt) = ˆZc ⊗ˆZt
Ad[ ˆCNOT ]( ˆXt) = ˆXt.
(40)
We see that the operation not only aﬀects the target
qubit, but also the control qubit.
More precisely, the
operation changes the computational value of the target
qubit (zt) and the phase of the control qubit (xc), hence
the name phase kickback.
The point here is that phase kickback may seem like
odd quantum behavior, since it is not intuitive to think
of a controlled operation aﬀecting the state of the con-
trol register. However, it is simply the fact that we are
including the physics of the control register in our model,
and that the back-action on the control register is simply
due to a remnant of Newton's third law within quan-
tum mechanics. In particular, we are keeping track of
the eﬀects these operations have in the conjugate of the
computational basis. This back-action could also be seen
with classical bit strings, however one does not typically
consider the "momentum" of bit strings in classical com-
puting.
However, that is not to say that we are only doing clas-
sical physics. In the realm of quantum mechanics, these
phases can interfere with each other to produce highly
non-classical phenomena. This eﬀect is used throughout
quantum computing, e.g., in Shor's algorithm. In this
paper, we will use controlled-unitaries of the form,
ˆU( ˆΦ) :=
X
Φ
|Φ⟩⟨Φ| ⊗ˆU(Φ),
(41)

10
which
are
generally
more
sophisticated
than
the
controlled-displacement and controlled-NOT gates just
described, but the phase kickback behaves similarly. We
will be using this kickback in the following to train ma-
chine learning algorithms parametrized by quantum reg-
isters, ˆΦ.
1.
Quantum Gradients
An application of phase kickback that we will use
throughout the paper is for computing the gradient of
an oracle for a function, f, whose input is a continuous
or simulated continuous register. This phase estimation
of gradients technique for a black box oracle was ﬁrst pio-
neered by Jordan [14] and later improved upon by Wiebe
et al. [15]. Consider a von Neumann measurement of the
output of this function, described abstractly by:
e−if(ˆΦ1)ˆΠ2 : |Φ1, Φ2⟩7→|Φ1, Φ2 + f(Φ1)⟩.
(42)
We can think of this operation as computing the function
f on the ﬁrst register and storing the result in the second.
In the Heisenberg picture, one can view this operation as
Ad[eif(ˆΦ1)ˆΠ2](ˆΦ2) = ˆΦ2 + f(ˆΦ1).
(43)
The phase kickback appears as a shift in the momentum
of the ﬁrst register,
Ad[eif(ˆΦ1)ˆΠ2](ˆΠ1) = ˆΠ1 −f ′(ˆΦ1)ˆΠ2,
(44)
where f ′ is the derivative of f. Thus we see that if the
second register begins in a state of small uncertainty in
ˆΠ2, the momentum of the ﬁrst register is shifted propor-
tional to the gradient of f. Of course, if there is large un-
certainty in either of the quadratures of the ﬁrst register,
then this shift will provide little information. However,
we see that it will possible to extract some information
about the gradient by measuring the momentum ˆΠ1. Be-
low we will show how to make use of this observation to
implement backpropagation in a variety of contexts.
III.
QUANTUM PARAMETRIC
OPTIMIZATION
This section will be devoted to explaining abstractly
the training algorithm used to accomplish quantum pa-
rameter optimization for general parametrized quan-
tum algorithms.
Then, Sections V and VI will exam-
ine more concretely how these techniques can be used
to train quantum-coherent neural networks as well as
parametrized quantum algorithms for performing various
quantum information tasks.
A.
Basic Principles
1.
Quantum Feedforward and Baqprop
Machine learning consists of the task of ﬁnding a suit-
able algorithm among a parametrized class of algorithms.
On a quantum computer, an algorithm consists of a uni-
tary operator acting on a collection of registers.
Nat-
urally, one can consider parametrizing a quantum algo-
rithm (unitary operator) with some collection of param-
eters, Φ = (Φn)n. Abstractly, we can denote this algo-
rithm as ˆU(Φ). For example, the algorithm may consist
of a set of single qubit rotations along with controlled-
NOT gates, and the parameters could be taken as the
Euler angles parametrizing each rotation.
In such considerations, the algorithm is quantum but
the parameters remain externally-controlled and classi-
cal. Here, we will extend this by using parameters which
are quantized. To this end, we introduce registers to store
the parameters in addition to those upon which the algo-
rithm is performing its computation. Let us denote the
full Hilbert space as HΦ ⊗Hc, where HΦ is the param-
eter Hilbert space and Hc is the computational Hilbert
space. The combined unitary operator will be denoted
ˆU( ˆΦ) :=
X
Φ
|Φ⟩⟨Φ| ⊗ˆU(Φ).
(45)
Note that the sum over Φ is only formal; we also include
the case where this consists of integrals over continu-
ous variables. Every ﬁxed set of parameters Φ applies
a parametrized algorithm ˆU(Φ). Allowing for quantum
parameters allows us to apply a superposition of quantum
algorithms. Of course, when the state of the parameters
is such that the uncertainty in Φ is small then we recover
the case of a quantum algorithm controlled by classical
parameters.
Including the parameters as a part of the system under
consideration will allow us to analyze the computation of
the class of algorithms and the training of the parameters
as a closed dynamical system. Furthermore, the quantum
mechanical nature of the parameters can allow for some
advantages in training, as we will explore throughout this
paper.
Note that although the parameters have been pro-
moted to quantum operators, in this paper we will only
consider seeking a classical value for the parameters for
the purposes of inference at the end of the training. In
one of the optimization strategies we will present below
(Quantum Dynamical Descent, Subsection III B), the end
of the training will result in a wavefunction over the set
of parameters. At this stage, one could perform a mea-
surement of the parameters or multiple measurements
to obtain an expectation value, and use the result as
the classical value.
The second optimization strategy
is semi-classical (Momentum Measurement Gradient De-
scent, Subsection III C), and the end of the training will
directly result in a set of classical parameters to be used
for inference.

11
Once the parametrized class of algorithms is ﬁxed (i.e.,
the hypothesis space), next is to provide an appraisal
of each algorithm according to some metric, and then
search for a set of parameters which optimizes this met-
ric. In machine learning, this parameter search is guided
by training data. The basic element of training is to feed
a single example input into the algorithm, and evaluate a
loss function at the output. Typically, the gradient (with
respect to the parameters) of the loss function for multi-
ple training examples are combined to update the values
of the parameters using some variant of gradient descent.
If the algorithm is comprised of many parametrized com-
ponents, as in deep learning, then the gradients of the loss
function at the output need to be propagated back to the
relevant component in order perform this update. In this
section, we will explain the use of quantum phase kick-
back to obtain a gradient of the loss function for a single
training example. The following sections will elaborate
upon various schemes for making use of these gradients,
as well as combining the phase kicks for multiple training
examples.
The remainder of this section will be used to describe,
abstractly,
the Quantum Feedforward and Baqprop
(QFB) algorithm, which evaluates the gradient of the loss
function for a single training example and stores it in the
momenta of the parameter registers via an eﬀective phase
kick. To this end, let us begin by denoting |ξ⟩∈Hc as
the input associated with a single training example to the
quantum algorithm ˆU(ˆΦ). For example, this state could
denote the encoding of a classical number (or set of num-
bers) in a continuous or discrete quantum register. How-
ever, this could be any state in Hc for a general quantum
algorithm. Further discussion of the structure of input
states will be provided below for particular applications.
Let us also suppose the parameters are initialized in an
arbitrary state, |Ψ0⟩∈HΦ, expressed in the parameter
eigenbasis as |Ψ0⟩= P
Φ Ψ0(Φ) |Φ⟩. The algorithm then
acts on this joint initial state to produce a superposition
of parametrized algorithms on the example input state
|ξ⟩, and yields
X
Φ
Ψ0(Φ) |Φ⟩ˆU(Φ) |ξ⟩.
(46)
This will be called the feedforward step of the QFB al-
gorithm.
The next step in a machine learning training algorithm
is to evaluate the performance of the algorithm, using a
loss function, based on the output for a particular in-
put. In this case, the loss function will be an operator,
which will be denoted ˆL, which acts on the computational
Hilbert space, Hc (and acts as the identity on the param-
eters). After the feedforward step of the QFB training
algorithm, we apply the exponential of the loss function
as a phase gate,
ˆI ⊗e−iη ˆL,
(47)
where η is the phase kicking rate, which will inﬂuence the
learning rate of the algorithm. Methods for exponentiat-
ing various loss functions will be described below when
discussing particular applications. Finally, after evaluat-
ing the loss function, we transmit the eﬀect of the phase
gate back to the parameters of the algorithm by perform-
ing a backpropagation step, consisting of the application
of the inverse of the feedforward step, namely, ˆU †(ˆΦ).
This backward quantum propagation of phase errors will
be referred to as Baqprop.
In all, the quantum feedforward and Baqprop (QFB)
circuit is
ˆUQFB := ˆU( ˆΦ)†e−iη ˆL ˆU( ˆΦ)
= e−iη ˆL(ˆΦ),
(48)
where ˆL(ˆΦ) := ˆU( ˆΦ)† ˆL ˆU( ˆΦ) can be seen as the loss
function operator evolved under the feedforward unitary
ˆU(ˆΦ). Applied to the joint initial state of the parameters
and the training example input state, |Ψ0⟩⊗|ξ⟩, we get
ˆUQFB |Ψ0⟩|ξ⟩=
X
Φ
Ψ0(Φ) |Φ⟩e−iη ˆL(Φ) |ξ⟩.
(49)
We can view this output state as a superposition of
ancilla-assisted phase gates on the parameters by decom-
posing the operator ˆL(Φ) (for ﬁxed Φ) into its eigen-
basis, which we will denote as ˆL(Φ) |λΦ⟩= λΦ |λΦ⟩.
Then if we decompose the input state in this basis,
|ξ⟩= P
λΦ ξ(λΦ) |λΦ⟩, we have
ˆUQFB |Ψ0⟩|ξ⟩=
X
Φ,λΦ
e−iηλΦΨ0(Φ)ξ(λΦ) |Φ⟩|λΦ⟩. (50)
We see that the QFB algorithm acts as a nonlinear phase
gate for the parameters in each branch of λΦ. Notice that
if |ξ⟩is an eigenstate of the operator ˆL(ˆΦ) (in the sense
that ˆL(ˆΦ) |ξ⟩= ξ |ξ⟩for all Φ), then the QFB algorithm
acts as a pure phase kick. In particular, we will show
in Section V A 2 that this generally occurs when training
neural networks for classical data learning on a quantum
computer.
In the generic case, the QFB algorithm, ˆUQFB, causes
the parameter and computational registers to become en-
tangled. Since the purpose of the training data is to play
an auxiliary role to guide the training of the parameters,
let us focus solely on the eﬀect the QFB algorithm has on
the parameters. Not only will the momenta be shifted,
but the entanglement between the parameters and the
computational registers will cause the parameter wave-
function to decohere, as can be seen from the channel:
ˆρΦ(η) = trC
h
e−iη ˆL(ˆΦ)ˆρΦ(0) ⊗|ξ⟩⟨ξ| eiη ˆL(ˆΦ)i
=
X
i
ˆAi(ˆΦ)ˆρΦ(0) ˆA†
i(ˆΦ),
(51)
where ˆρΦ(0) = |Ψ0⟩⟨Ψ0|, ˆAi(ˆΦ) := ⟨i| e−iη ˆL(ˆΦ) |ξ⟩are
the Kraus operators for the channel, and {|i⟩}i is an ar-
bitrary basis for HC. We see that the decoherence can be

12
interpreted as due to a noisy measurement of the param-
eters by the computational registers which causes them
to become entangled. Generically this will have the eﬀect
of causing phase decoherence in the parameter eigenba-
sis and increasing the uncertainty in the values of the
parameters. To minimize the eﬀect of this decoherence,
one must train the algorithm slowly, i.e., tune the learn-
ing rate η to be suﬃciently small. Then, if we expand
the above channel perturbatively in η, we see that it is
unitary to ﬁrst order:
ˆρΦ(η) = trC
h
(1 −iη ˆL(ˆΦ) + . . . )ˆρΦ(0) ⊗|ξ⟩⟨ξ|
×(1 + iη ˆL(ˆΦ) + . . . )
i
= ˆρΦ(0) −iη[L(ˆΦ), ˆρΦ(0)] + O(η2),
(52)
with an eﬀective Hamiltonian,
L(ˆΦ) := ⟨ξ| ˆL(ˆΦ) |ξ⟩.
(53)
Therefore, we see that insofar as the parameters are con-
cerned, the QFB algorithm acts as an eﬀective unitary
phase gate e−iηL(ˆΦ) (to ﬁrst order in η). Any decoherence
does not occur until higher orders in η. For the conve-
nience of notation, in the following we will use e−iηL(ˆΦ)
to denote the eﬀect of the QFB algorithm on the param-
eters, and it should be understood that it is valid only to
ﬁrst order in η.
Now let us examine how the momenta of the parame-
ters are aﬀected by this eﬀective phase gate,
ˆΠ
7→
eiηL(ˆΦ) ˆΠe−iηL(ˆΦ) + O(η2)
= ˆΠ −η ∂L(ˆΦ)
∂ˆΦ
+ O(η2).
(54)
We see that to ﬁrst order in η, the momenta are kicked
according to the gradient of the loss function. This gra-
dient update can be interpreted as an eﬀective force on
the parameters in the direction of decreasing values of
the loss function. We will elaborate upon this analogy in
the Section III A 3.
We leave as future work a more careful analysis of the
open systems nature of the parameter-data interactions.
In particular, of interest would be to elaborate upon the
decoherence at higher orders in η and frame the problem
in terms of repeated interactions between the parameters
with multiple data points.
2.
Full-batch Eﬀective Phase Kicks
Above we considered eﬀective phase kicks for an ab-
stract state, |ξ⟩(which is associated with an input ex-
ample on the computational space), and an abstract loss
function ˆL. Now let us examine this again with some
more emphasis on the machine learning aspects of these
phase kicks, without yet examining the details of par-
ticular applications.
Speciﬁcally, we will consider how
multiple loss function phase kicks can be batched over
a dataset in order to induce a cost function as an eﬀec-
tive phase. Here we will only consider batching the full
dataset, whereas later (Section IV A) we will discuss more
reﬁned techniques for combining kicks from multiple data
points. We illustrate the concept for input-output pairs
of data which would occur in supervised learning, but as
we will show in later sections it can extend to many other
cases, including unsupervised scenarios and Hamiltonian
optimization.
A classical dataset for a supervised learning prob-
lem consists of a collection of input/output pairs,
{(xj, yj)}j∈B, which we will assume to be real vectors.
In this setting, we consider the computational Hilbert
space, Hc, to be partitioned into an input space as well
as an auxiliary work space, so that (respectively) Hc =
Hi ⊗Hw. (If one is training via superpositions of classi-
cal data points, it would be necessary to assign a Hilbert
space for the outputs as well.) Before the QFB procedure
is applied for a single data point, (xj, yj), the input state
on Hi must be prepared in a computational basis state
corresponding to the input, xj. For an initially blank in-
put register, |0⟩i, we can apply the classically-controlled
unitary ˆUi(xj) = e−ixj·ˆpi : |0⟩i 7→|xj⟩i.
Once this
state is prepared, we apply the QFB algorithm as above
to the combined parameter and computational spaces
HΦ ⊗Hc, with the parameters initialized to some state
|Ψ0⟩= P
Φ Ψ0(Φ) |Φ⟩. Because in a supervised learning
problem the loss function will depend on the output data
point, yj, the exponentiated loss function occurring after
the feedforward operation will generally be a classically-
controlled unitary, where the classical control registers
are those which store the desired output, yj. We will la-
bel the classically-controlled loss function as ˆL(yj). Af-
ter the uncomputation step, we can also uncompute the
state preparation by acting ˆU †
i (xj) = e+ixj·ˆpi. It turns
out that this will indeed uncompute the state prepara-
tion because, as we mentioned above, in the case of an
embedded classical machine learning problem, the com-
putational registers are left unchanged at the end of the
QFB algorithm, so we get a perfect unitary phase kick of
the loss function and hence the parameter and computa-
tional registers are left unentangled. Again, the details
of this fact will be provided in V A 2.
As a whole, this procedure applied onto the initial state
|Ψ0⟩Φ |0⟩c yields
ˆU †
i (xj) ˆU †(ˆΦ)e−iη ˆL(yj) ˆU(ˆΦ) ˆUi(xj) |Ψ0⟩Φ |0⟩c
= e−iηL(xj,yj,ˆΦ) |Ψ0⟩Φ ⊗|0⟩c ,
(55)
where L(xj, yj, ˆΦ) :=
ˆU †
i (xj) ˆU †(ˆΦ)ˆL(yj) ˆU(ˆΦ) ˆUi(xj).
In Figure 3 we represent this classical-data-induced phase
kick for a single data point. In the same ﬁgure, we repre-
sent pictorially how the eﬀective phase kick amounts to
an operation strictly on the parameters, using the com-
putational registers eﬀectively as an auxiliary space to
assist the phase kick.

13
Figure 3. Quantum Feedforward and Baqprop procedure for a backpropagating loss phase error of a single classical data point.
The eﬀective phase kick is an exact unitary on the parameter registers. Note that for this diagram and throughout this paper
the rate hyper-parameters will be labelled as Ξ, in this case the phase kicking rate η ∈Ξ is considered a hyper-parameter.
Repeating this procedure for subsequent data points
is straightforward:
ﬁrst prepare the input state to a
computational state representing the input data point
xj+1, then apply the QFB algorithm with the classically-
controlled loss function ˆL(yj+1), and ﬁnally uncompute
the input state preparation. As one proceeds through the
dataset {(xj, yj)}j∈B, the phase kicks on the parameter
registers accumulate, resulting in a total phase kick,
e−iηJ (ˆΦ) |Ψ0⟩Φ ⊗|0⟩c ,
(56)
where we have deﬁned the average cost function for clas-
sical data,
J (ˆΦ) := 1
|B|
X
j∈B
L(xj, yj, ˆΦ).
(57)
Here we have also redeﬁned η to be the total phase kick-
ing rate of the batch, and ˜η := η/|B| the phase kicking
rate normalized by the batch size, which would appear in
the exponentiated loss functions for the individual data
points. This accumulation of phase kicks for the dataset
is illustrated in Figure 4.
For quantum data, the procedure is slightly diﬀer-
ent due to the fact that the state preparation at the
input of the parametrized algorithm and the exponen-
tiated loss function must be controlled from quantum
data sources rather than classical.
Consider, for illus-
tration, a case of supervised quantum data learning,
where we are handed a set of input/output pairs of quan-
tum states, {(ˆρi
j, ˆρo
j )}j∈B, which are states on respective
Hilbert spaces Hij ⊗Hoj. We consider beginning with a
blank computational register, |0⟩c, and swap in an input
state, ˆρi
j, from the dataset using the input preparation
unitary ˆUi(ˆρi
j). Once again, we being with a certain state
for the parameters, |Ψ0⟩= P
Φ Ψ0(Φ) |Φ⟩, and apply the
parametric unitary ˆU(ˆΦ) onto the compute and parame-
ter Hilbert space jointly. After this, a certain exponential
of a loss operator dependent on the desired output state
ˆLj(ˆρo
j ) is applied. In general, generating an exponenti-
ated loss depending on the state ˆρo
j can consume multiple
copies of ˆρo
j . We refer the reader to Section VI for speciﬁc
examples of quantum data learning problems, and to Sec-
tion VI B for particular examples of state-dependent loss
Figure 4. Phase kick batching. By sequentially applying the
Quantum Feedforward and Baqprop for multiple data points
in the full batch B, we can act an eﬀective phase kick accord-
ing to the cost function for the full data set by accumulating
the loss exponentials. Here ˜η = η/|B| is the phase kicking pa-
rameter normalized by the batch size. The registers labelled
as H-P, P, C, and D, correspond to the hyper-parameters, the
parameters, the compute, and the data registers respectively.
Note that most diagrams in Sections III and IV will use clas-
sical data registers, but all protocols also work for quantum
data kicking.
functions. After the loss function is applied, the para-
metric unitary is uncomputed, and the quantum data
preparation unitary is uncomputed in order to establish
a fresh compute register for the next iteration. The data
registers Hi
j ⊗Ho
j are also discarded after generating the
eﬀective phase kick. In all, the algorithm schematically
consists of the transformation,
ˆU †
i (ˆρi
j) ˆU †(ˆΦ)e−iη ˆLj(ˆρo
j) ˆU(ˆΦ) ˆUi(ˆρi
j) |Ψ0⟩Φ |0⟩c
trc
7→e−iηL(ˆρi
j,ˆρo
j,ˆΦ) |Ψ0⟩Φ + O(η2),
(58)
where
e−iηL(ˆρi
j,ˆρo
j,ˆΦ) :=
⟨0|c ˆU †
i (ˆρi
j) ˆU †(ˆΦ)e−iη ˆLj(ˆρo
j) ˆU(ˆΦ) ˆUi(ˆρi
j) |0⟩c .
(59)

14
Figure 5. Quantum Feedforward and Baqprop procedure for a backpropagating loss phase of a single quantum data point. The
eﬀective phase kick is eﬀectively a unitary phase kick on the parameters to ﬁrst order in η. We use a swap-control symbol for
both the input and output, for the input the data is fully swapped onto the compute registers, whereas for application of an
output-dependent phase kick the swap-control symbolizes the consumption of multiple copies from state exponentiation, which
we treat in-depth in Subsection VI B.
This swapping out of the computational register is im-
portant for quantum data problems since the QFB proce-
dure generally does not entirely disentangle the compu-
tational and parameter registers. By swapping out and
discarding the output of the computational register, we
are tracing out this register, and as such, on average,
to ﬁrst order in η the expected value of the phase kick is
that of (53). We present a quantum data QFB procedure
pictorially in Figure 5.
With this procedure, it is again straightforward to
accumulate phase kicks for multiple data points.
Af-
ter applying the algorithm for the full data batch,
{(ˆρi
j, ˆρo
j )}j∈B, we obtain a total eﬀective phase kick,
e−iηJ (ˆΦ) |Ψ0⟩Φ ⊗|0⟩c ,
(60)
where we have deﬁned the average eﬀective cost function
for quantum data as
J (ˆΦ) := 1
|B|
X
j∈B
L(ˆρi
j, ˆρo
j , ˆΦ),
(61)
and where η is the total phase kicking rate. Again, we
emphasize that this phase kick is only valid to ﬁrst order
in η.
Now that we have an abstract method for obtain-
ing the gradient of the (eﬀective) cost function for the
parametrized quantum algorithm, next is to examine
methods for making use of these gradients to update the
weights.
3.
Eﬀective Forces
In
the
previous
section,
we
saw
that
for
any
parametrized quantum programs, we can consider using
a set of quantum registers for the parameters. We can ini-
tiate the parameters in a superposition of values, and by
applying a forward computation, a loss function phase-
kick, and an uncomputation, we can push the wavefunc-
tion in the momentum basis according to the gradient of
the (eﬀective) loss function.
Let us consider how these momentum kicks can be in-
terpreted from the perspective of classical Hamiltonian
dynamics. Consider the Hamiltonian H(q, p) function,
where q is a position variable, and p its conjugate mo-
mentum. In the simplest cases, the Hamiltonian is com-
posed of a sum of two terms, the kinetic term T and
the potential term V . In many physical scenarios, the
kinetic term is strictly a function of the momentum, e.g.,
T(p) = p·p
2m (where m is the mass parameter), while the
potential term, V (q), is strictly a function of position.
Hence, we can write H(q, p) = T(p) + V (q). In canoni-
cal Hamiltonian mechanics, the change in the momentum
per unit time is given by ˙p = −∂qH, hence ˙p = −∂qV (q)
for the case above. For a suﬃciently small unit of time,
the change in the momentum vector is proportional to the
negative gradient of the potential ∆p = −∇qV (q) ∆t.
We can compare this to the ﬁnite-diﬀerence version of
Newton's second law, where the change in momentum
per unit time is deﬁned as a force, ∆p = F ∆t, and we
see the force is then equal to the negative gradient of
the potential F = −∇qV (q). Notice that in (54), the
change in momentum for a single data point is propor-
tional to the kicking rate η times the negative gradient
of the eﬀective loss function L. After batching multiple
data points, the momentum kicks accumulate to change
the momentum according to the negative gradient of the
total eﬀective cost function,
ˆΠ 7→ˆΠ −η ∂J (ˆΦ)
∂ˆΦ
+ O(η2).
(62)
Thus, in our physics analogy, the cost function acts as a
potential for the weights, with parameters Φ and conju-
gate momenta Π playing the respective roles of position
and momentum, q and p.
Therefore, we see that the momentum shifts induced
by the batched quantum feedforward and Baqprop pro-
cedure (QFB) can be seen as analogous to applying a
force onto the parameters, with η playing the role of
the time step parameter and J the potential.
Note
that a momentum kick is not a step of gradient de-
scent, just as a force-induced momentum update does

15
not alone cause a particle to move. For this, one must
also take into account the remaining Hamilton equa-
tions, which in canonical scenarios give the change in
the position per unit time as ˙q = ∂pH.
In the case
above, where H(q, p) = T(p) + V (q), this is given by
˙q = ∂pT(p) =
1
mp. For a small time step ∆t, the po-
sition is updated according to ∆q =
1
mp∆t. Therefore,
any update in the momentum is channelled to the posi-
tion via the kinetic term. We do not yet have an analogue
of this kinetic term for training quantum machine learn-
ing programs. In the next section we will introduce such
terms in order to use the force induced by the batched
QFB algorithm to update the values of the parameters.
B.
Quantum Dynamical Descent
The idea behind Quantum Dynamical Descent (QDD)
is to simulate Schrodinger time-evolution of the weights
as they would evolve if they were particles moving un-
der the inﬂuence of the potential induced by the cost
function. Dynamical time-evolution of a quantum me-
chanical system is governed by a Hamiltonian operator,
similar to classical Hamiltonian mechanics, but instead
of a scalar function, we have an operator for the Hamilto-
nian. For a time-independent Hamiltonian, ˆH, the time
evolution operator is simply ˆU(τ) = exp (−i ˆHτ), while
for a time-dependent Hamiltonian ˆH(τ), with τ as the
time parameter, the Schrodinger equation dictates that
the time evolution operator is a time-ordered exponential
of the form ˆU(τ) = T exp(−i
R τ
0 dτ ′ ˆH(τ ′)).
Now, in the previous subsection, we established that
our cost function J was analogous to a potential term
V in the Hamiltonian, as derived from the momentum
update rule. In fact, since the cost function, J ( ˆΦ), is
an operator on the Hilbert space of the parameters, it
is more akin to an operator-valued potential term which
would appear in the Hamiltonian operator ˆH = ˆT + ˆV .
Thus for QDD, we want to introduce a kinetic term along
with the cost function potential in order to construct a
Hamiltonian operator under which we can evolve the pa-
rameter wavefunction. Let us consider a time-dependent
Hamiltonian,
ˆH(τ) =
1
2m(τ) ˆΠ2 + J ( ˆΦ)
(63)
where τ is the time parameter and ˆΠ2 ≡ˆΠT ˆΠ.
No-
tice that we consider a standard kinetic term strictly de-
pendent on the momentum, but with a time-dependent
mass parameter.
This is a standard Hamiltonian for
Schrodinger dynamics of a single particle in N spatial di-
mensions (apart from the time-dependent mass), where
N is the number of parameters. Using a time-varying
mass is less standard, but it will allow us to control the
rate of descent of the potential landscape as the descent
proceeds. The optimization of how to initialize this pa-
rameter and its rate of change will fall into the category
of hyper-parameter optimization tasks. We will exam-
ine a few approaches for the design of the mass function,
one inspired by the Quantum Approximate Optimization
Algorithm, and another by the Quantum Adiabatic Al-
gorithm.
1.
Core Algorithm
The Quantum Dynamical Descent (QDD) algorithm
consists of applying alternating pulses as in the Trot-
terization of the time evolution generated by a time-
dependent Hamiltonian of the form ˆH = ˆT + ˆV .
In
other words, the algorithm consists of applying opera-
tions which mimic a ﬁnite-time-step quantum simulation
of the Hamiltonian in (63) which has the cost function
as the potential and a time-variable mass kinetic term.
More explicitly, the time-ordered exponential gener-
ated by the Hamiltonian (63) is approximated with a
product of single time-step exponentials.
To describe
this mathematically, ﬁrst partition the time interval of
interest, I ⊂R, into sub-intervals Ik := [τk, τk+1] ⊂I
with τk−1 < τk < τk+1 for all k and I = ∪kIk. The evo-
lution associated with each sub-interval will be called an
epoch, since it corresponds to a gradient and parameter
update for the full batch of data. (Alternative batching
schemes will be discussed in Subsection IV A.) With this
partitioning of the time interval, we can approximate the
time-evolution operator by decomposing it into a prod-
uct of time-evolution operators generated by averaged
operators on each sub-interval:
U(τ) = T exp

−i
Z
I
dτ ˆH(τ)

≈
Y
k
e−i∆τk ˆ
Hk,
(64)
where ∆τk := τk+1 −τk is the length of sub-interval Ik
and ˆHk :=
R
Ikdτ ˆH(τ) is the averaged Hamiltonian for
the kth time interval.
Note that the above expression
is approximate since the time-dependent mass prevents
the Hamiltonian from commuting with itself at diﬀer-
ent times. We proceed by using the Lie-Suzuki-Trotter
formula to divide the exponential of the Hamiltonian in
each sub-interval into that of the cost potential and ki-
netic terms,
U(τ) ≈
Y
k
e−i∆τk ˆ
Hk ≈
Y
k
e−i∆τk ˆ
Π2/2mke−i∆τkJ (ˆΦ)
(65)
where mk := (
R
Ikdτm−1(τ))−1 is the inverse averaged
inverse mass.
In a following subsubsection, we argue that a small
time step (ﬁne temporal partition) with a slowly decreas-
ing mass parameter can yield the minimum of J (Φ)
through the adiabatic theorem. In general, it is up to
the discretion of the practitioner to determine an appli-
cable time step and mass parameter schedule. In clas-
sical machine learning, this process of ﬁnding the opti-
mal initializations and optimal learning rates are a part
of a process called hyper-parameter optimization. Algo-
rithms for hyper-parameter optimization are often called

16
meta-learning algorithms. In Subsubsection IV D, we of-
fer a set of quantum meta-learning algorithms for Quan-
tum Dynamical Descent. Since we will generally optimize
the parameters for each pulse, we can write the unitary
corresponding to the quantum dynamical descent as
ˆUqdd =
Y
k
e−iγk ˆ
Π2e−iηkJ (ˆΦ)
(66)
where we call each parameter ηk the phase kicking rate
and γk the kinetic rate for epoch k. We will argue in
Subsubsection III B 4 that a heuristic one may wish to
use for choosing the phase kicking rate and kinetic rate
is to begin with γk ≫ηk for small k (early time), and
for large k (late time) shift towards γk ≪ηk. Later we
will discuss how beginning with a large kinetic rate and
transitioning to a (relatively) larger phase kicking rate
aids in converging to a local minimum.
Recall that the cost function for each epoch is the
loss function for each data point averaged over the en-
tire batch (dataset). That is, for a batch set B,
J (ˆΦ) = 1
|B|
X
j∈B
Lj(ˆΦ).
(67)
Above we wrote the loss function in supervised classical
learning for a data point (xj, yj) as L(xj, yj, ˆΦ). Simi-
larly, for supervised quantum data learning, the loss func-
tion was denoted L(ˆρi
j, ˆρo
j , ˆΦ) for a data point (ˆρi
j, ˆρo
j ).
Here we will simply denote the loss function as Lj(ˆΦ)
for a data point (classical or quantum) indexed by points
in the data batch j ∈B.
For each epoch, we can split the exponential of the cost
function into a product of exponentiated loss functions
for each data point in the batch,
e−iηkJ (ˆΦ) =
Y
j∈B
e−i
ηk
|B| Lj(ˆΦ).
(68)
Recall that each of these exponentials in turn consist
of applying an iteration of QFB (feedforward, classical-
or quantum-controlled loss pulse,
and backpropaga-
tion/uncomputation).
The above decomposition pre-
sumes an application of QFB for each data point sequen-
tially. Later, in Section IV A, we will examine methods
for parallelizing this phase accumulation.
Now, for Quantum Dynamical Descent, as seen in (66)
we need to alternate between phase kicks and kinetic
term exponentials. Recall that ˆΦ is a vector of param-
eters with nth component ˆΦn, and the conjugate mo-
mentum ˆΠ with components ˆΠn = ˆF (n)† ˆΦn ˆF (n), where
we use ˆF (n) to denote the Fourier transform on the
nth component. For the kinetic term exponentials, be-
cause of the commutation relation [Φn, Φn′] = 0 (hence
[Πn, Πn′] = 0), one can apply all kinetic terms in parallel
on the diﬀerent parameter registers,
e−iγk ˆ
Π2 =
O
n
e−iγk(ˆΠn)2 =
O
n
ˆF (n)†e−iγk(ˆΦn)2 ˆF (n).
(69)
Therefore, the depth of this part of the circuit is strictly
dependent upon the qubital precision of the parameter
registers in the case of simulated continuous parameters,
and on the speed of the analog Fourier transform in the
case of continuous parameters.
Recall that the Hilbert space upon which this algo-
rithm is being run is a tensor product of the parameter
and computational Hilbert spaces, HΦ ⊗Hc. The initial
state on the computational space is the blank state |0⟩c,
whereas the parameters will generically be initialized to
some Gaussian pointer state,
Ψ0(Φ) =
1
det1/4(2πΣ0)
e+iΠ0·Φe−1
4 (Φ−Φ0)T Σ−1
0
(Φ−Φ0),
(70)
where Φ0 is the initial mean for the wavefunction, Π0
its initial momentum, and Σ0 any initial correlations be-
tween the parameters (often they will be chosen as uncor-
related, hence Σ0 will be diagonal). Some implications
of diﬀerent choices for the initial wavefunction parame-
ters, {Φ0, Π0, Σ0}, will be discussed below in the context
of the adiabatic theorem.
We will ﬁnd it useful when
discussing hyper-parameter optimization to also include
preparation of this initial parameter wavefunction as a
part of the QDD algorithm. Hence, we will write a uni-
tary, ˆUp(Θ), where Θ := {Φ0, Π0, Σ0}, to denote the
preparation of the parameter wavefunction Ψ0(Φ) from
some initial reference state.
This preparation unitary
can be thought of as classically controlled by the hyper-
parameters Θ.
A circuit diagram for two iterations of QDD, including
the initial state preparation, is provided in Figure 6.
Figure 6.
Two iterations of Quantum Dynamical Descent.
The descent rate hyper-parameters are represented by the
classical vector Ξ = {γ, η}, while the preparation hyper-
parameters are represented by Θ = {Φ0, Π0, Σ0}. The uni-
tary ˆUp(Θ) prepares the pointer state of the parameters as
in equation (70) and is thus dependent on these preparation
hyper-parameters. In this diagram and in most diagrams for
Section III, we use classical registers to represent the data,
but one may as well use quantum data registers, the latter of
which might require a fresh swap-in after every phase kick.
Additionally, we use H-P, P, C, and D to denote the hyper-
parameter, parameter, compute, and data registers, respec-
tively.

17
2.
Heisenberg Picture Update rule
We can now derive a Heisenberg picture update rule for
single-epoch update for the parameters under QDD. Re-
call we derived the update rule for the momentum under
conjugation by the cost exponential,
eiηJ (ˆΦ) ˆΠe−iηJ (ˆΦ) = ˆΠ −η∇J (ˆΦ) + O(η2),
(71)
i.e., the momentum is shifted by the negative gradient of
the cost function, up to second order error in the kicking
rate. Conversely, the exponential kinetic term shifts the
value of the parameter operator,
eiγ ˆ
Π2/2 ˆΦ e−iγ ˆ
Π2/2 = ˆΦ + γ ˆΠ.
(72)
We see that the parameter operator is updated according
to the momentum times the kinetic rate, γ. The QDD
algorithm applies (71) followed by (72), hence we can
derive how the parameters are updated according to the
gradient, to ﬁrst order in the kicking rate,
eiηJ (ˆΦ)eiγ ˆ
Π2/2 ˆΦe−iγ ˆ
Π2/2e−iηJ (ˆΦ)
= ˆΦ + γ ˆΠ −ηγ∇J (ˆΦ) + O(η2).
(73)
We thus see from the Heisenberg picture that the pa-
rameters get updated according to the momentum and
gradient of the cost function at each epoch.
Note that attempting to recursively conjugate the al-
ternating operators of QDD analytically in the Heisen-
berg picture rapidly becomes intractable, unless the cost
function can be approximated as a second-order polyno-
mial. This is due to the fact that the QFB unitary phase
kick is a non-Gaussian operation, and keeping track of
the operators as they evolve through such a set of non-
Gaussian operations gets exponentially hard. It is well-
known that Gaussian operations are classically eﬃciently
simulatable [58], whereas non-Gaussian operations gen-
erally are not. Letting the parameters coherently descent
the cost landscape leads to a state of complexity which
can be seen as classically hard to simulate. As an ad-
ditional inclination to suspect that Quantum Dynamical
Descent is also classically hard to simulate, as we describe
immediately below, it can be seen as a type of Quantum
Approximate Optimization Algorithm (QAOA), and this
class of algorithms has been proven to be classically hard
to simulate [40].
3.
Connections to QAOA
Here we will relate the Quantum Dynamical Descent
(QDD) approach to the Quantum Approximate Opti-
mization Algorithm (QAOA) [39], and its most general
form the Quantum Alternating Operator Ansatz [41].
First we will review the QAOA algorithm. QAOA is a
quantum-classical hybrid algorithm in which a classical
optimizer is used to optimize the hyper-parameters for
a sequence of alternating operators generated by non-
commuting Hamiltonians.
One usually deﬁnes a cost
Hamiltonian ˆHc and a mixer Hamiltonian ˆHm. The goal
of QAOA is to ﬁnd states of low cost expectation value
⟨ˆHc⟩. The algorithm begins with a simple initial state,
(e.g., the ground state of ˆHm) and applying the sequence
of alternating unitaries,
ˆUqaoa(η, γ) =
P
Y
k=1
e−iγk ˆ
Hme−iηk ˆ
Hc,
(74)
where the number of pulses P is ﬁxed. The set of pa-
rameters γ := (γk)P
k=1 and η := (ηk)P
k=1 are optimized
classically to minimize the expectation ⟨ˆHc⟩γ,η, which is
usually estimated using multiple runs and measurements.
The optimization is done in a feedback loop between the
quantum and classical computers; the quantum computer
is seen as a black-box in which one inputs parameters and
obtains a scalar corresponding to the expectation value.
As such, the classical optimizer is always using a ﬁnite-
diﬀerence algorithm, whether it is using Nelder-Mead,
gradient descent, or particle swarms.
Typically, the cost Hamiltonian is diagonal in the com-
putational basis, and the mixer Hamiltonian is a genera-
tor of shifts of computational basis states. For example, a
typical cost Hamiltonian seen for QAOA with qubits [39]
would be of the form ˆHc = −P
jk αjk ˆZj ˆZj −P
j βj ˆZk
which is a coupling of standard basis observables. This
choice of cost function is typical for any Quadratic Un-
constrained Binary Optimization (QUBO) problem. A
typical choice of mixer Hamiltonian would be Hm =
P
j Xj, i.e., an uncoupled sum of generators of shifts of
the standard basis. In our case, for machine learning, the
parameters we are optimizing are often continuous (real)
values, hence the choice of cost and mixer Hamiltonian
has to be adapted, but we can repeat this same pattern of
using a cost that is a polynomial of standard-basis diago-
nal operators, and a mixer which is the sum of generators
of shifts of each register.
Comparing (66) to (74), we see that the Quantum Dy-
namical Descent unitary is of the form of the Quantum
Alternating Operator Ansatz, with cost Hamiltonian be-
ing the eﬀective phase shift induced on the parameters by
the QFB, ˆHc = J (ˆΦ), and the mixer Hamiltonian made
up of generators of shifts of each register, ˆHm = ˆΠ2, i.e.,
the kinetic term we pulse to perform parameter shifts.
Since the QAOA algorithm consists both of applying
the unitaries and also optimizing the pulse lengths, we see
that we can consider the hyper-parameter optimization
of Quantum Dynamical Descent to be a case of a QAOA
problem, where optimizing the kinetic rates γ := (γk)P
k=1
and phase kicking rates η := (ηk)P
k=1 would count as a
meta-learning. We discuss in depth how to perform meta-
learning in Section IV D.
As mentioned in the last subsubsection (III B 2), in
certain cases classically simulating the QDD for certain
super-quadratic eﬀective cost functions becomes rapidly

18
intractable, since this would eﬀectively be a task of sim-
ulating non-Gaussian operations.
As we have detailed
above, QDD is like a continuous-variable QAOA prob-
lem, and QAOA itself has been shown to potentially
demonstrate a quantum advantage for certain optimiza-
tion problems [40].
We leave as future work a formal
proof of whether this quantum advantage result can be
extended to QDD, and whether this is achieved only in
the cases where the eﬀective potential is non-Gaussian.
Finally, QAOA is technically inspired from the Quan-
tum Adiabatic Algorithm, it can be considered as a tem-
porally coarse-grained, variationally optimized quantum
simulation of adiabatic evolution. In the limit of many
pulses, one can show that there exists a solution for the
hyper-parameters which converges to a quantum simula-
tion of adiabatic evolution, hence eﬀectively a quantum
simulated implementation of the Quantum Adiabatic Al-
gorithm. In the next subsection (III B 4), we establish a
similar limit for the QDD algorithm, i.e., a limit where
many pulses are applied and show how it can be seen as
a quantum simulation of a continuous-quantum-variable
adiabatic evolution. This will be useful to discuss con-
vergence and to use the physical intuition to derive a
heuristic for the initialization of hyper-parameters.
4.
Adiabatic Limit
Before we can connect to the adiabatic theorem, let us
brieﬂy review the Quantum Adiabatic Algorithm (QAA).
Suppose we would like to ﬁnd the ground state of a
certain cost Hamiltonian ˆHc.
We begin in a ground
state, |g0⟩, of some simpler Hamiltonian, ˆH0. Then we
evolve the system with the unitary generated by a time-
dependent interpolating Hamiltonian of the form ˆH(τ) =
(1 −τ/T) ˆH0 + (τ/T) ˆHc, where τ ∈[0, T] is the time pa-
rameter. Explicitly, this evolution operator is given by
the time-ordered exponential T exp(−i
R T
0 dτ ˆH(τ)).
In
this scenario, the adiabatic theorem states that for suﬃ-
ciently long time T, the evolution will track the instan-
taneous ground state |g(τ)⟩for all times τ ∈[0, T]. More
precisely, the condition for T is given by T ≫1/∆2,
where ∆g is the smallest ground state energy gap of the
interpolating Hamiltonian: ∆g := minτ ∆g(τ). (There
exist more general statements of the adiabatic theorem
[59]. We leave an examination of the connection of QDD
to these more general versions to the zealous reader.)
We can consider a set of cases where our Quantum
Dynamical Descent obeys the adiabatic theorem. So far
we have yet to specify which initial states are best for
the quantum parameter wavefunction, however, to ap-
ply the adiabatic theorem we will have to pick an initial
Hamiltonian, and hence a corresponding ground state.
We will work in the continuous-variable formalism but
much transfers over to the qubital case through quan-
tum simulation theory.
We can pick an initial Hamiltonian for N quantum
harmonic oscillators (for N parameters) with hyper-
parameters m0, k0 and Φ0
ˆH0 =
1
2m0 ˆΠ2 + k0
2 (ˆΦ −Φ0)2.
(75)
The corresponding ground state is the Gaussian wave-
function given by
Ψ0(Φ) =
  m0ω0
π
N/4 e−m0ω0
2
(Φ−Φ0)2,
(76)
where ω0 :=
p
k0/m0. We see that the variance in each
of the parameters is σ2 = 1/2m0ω0 = 1/2√m0k0. For
simplicity, we picked hyperparamters symmetrically over
dimensions, but in general, one could have a diﬀerent m0
and k0 for each dimension. That is, one could use the
Hamiltonian
ˆH0 =
N
X
n=1
h
1
2m0,n (ˆΠn)2 + k0,n
2 (ˆΦn −Φ0,n)2i
,
(77)
and a corresponding ground state with diﬀerent variances
for each dimension.
Note that, by the uncertainty principle, the wider the
variance is in position space, the narrower it is in momen-
tum space. Concretely, if we look at the Fourier trans-
form of (76),
˜Ψ0(Π) =

1
πm0ω0
N/4
e−iΦ0·Πe−
1
2m0ω0 Π2
,
(78)
we see that the variance in each of the parameter mo-
menta is inversely proportional to that of the correspond-
ing parameter: ˜σ2 = m0ω0/2 = √m0k0/2 = 1/4σ2. In
most cases, it will be advantageous to keep the variance
in position space larger than that in momentum space,
initially. This is tied to our choice of initial Hamiltonian,
since for k0 →0 we have the position space variance go
to inﬁnity.
For the ﬁnal Hamiltonian, we would like to ﬁnd the op-
timum of the cost function J (Φ). In general, this will be
achieved through minibatching (stochastic gradient de-
scent), but for this discussion we will assume that this
cost function includes all of the data in the batch so that
the potential itself is not stochastically time-dependent.
In the continuous-variable setting, achieving an inﬁnitely
sharp wavefunction centered at the optimum would be
physically impossible. Therefore, instead we will aim to
minimize a regularized cost Hamiltonian, whose regular-
izer will be an added kinetic term.
That is, our cost
Hamiltonian will be of the form:
ˆHc =
1
2mc ˆΠ2 + J (ˆΦ).
(79)
We will choose the cost mass parameter to be much
larger than the initial mass parameter, mc ≫m0. The
reasoning for this will become clear later.
For now,
let us consider a time-ordered Trotterized exponenti-
ation of our adiabatic time evolution.
That is, con-
sider the evolution under the interpolating Hamiltonian,
ˆH(τ) = (1 −τ/T) ˆH0 + (τ/T) ˆHc. Let us partition the

19
time interval τ ∈[0, T] into sub-intervals Ik := [τk, τk+1]
with τk−1 < τk < τk+1 for all k and I
= ∪kIk.
For convenience, let us also denote ∆τk := τk+1 −τk,
¯τk := (τk+1 + τk)/2, and the time-averaged Hamiltonian
on the sub-interval Ik as ˆHk :=
R
Ik dτ ˆH(τ). Then the
evolution operator over the interval τ ∈[0, T] generated
by the interpolating Hamiltonian is:
ˆU(T) ≈
Y
k
e−i∆τk ˆ
Hk
≈
Y
k
e−iγk ˆ
Π2e−iηkJ (ˆΦ)e−iλk(ˆΦ−ˆΦ0)2,
(80)
where
γk := ∆τk
(1 −¯τk/T)
2m0
+ ¯τk/T
2mc

(81)
ηk := ∆τk(¯τk/T)
(82)
λk := ∆τk(1 −¯τk/T)k0
2 .
(83)
We see that the adiabatic evolution can be split up into a
kinetic term, a (batched) QFB exponential, and an extra
phase term, which can be interpreted as a fading parame-
ter regularization term. Therefore, we see that this evolu-
tion can be viewed as a regularized QDD algorithm. (We
will refrain from discussing regularization until we treat
it in detail in Section IV C 1.) We see that as τ →T,
the coeﬃcient of the kinetic term becomes that associ-
ated with the cost mass, while the weight decay term
fades, and the QFB phase kicking rate dominates. Thus
starting with a small mass parameter m0 and ending in a
much larger mass mc, we get an eﬀective kinetic rate γk
that is decreasing, while we get an increasing QFB phase
kicking rate. Although in practical scenarios where one
may want a local minimum rather than a global mini-
mum, one may want to ignore the adiabatic condition.
The intuition of starting with a large uncertainty state,
a large kinetic rate, and slowly increasing the phase kick-
ing rate relative to the kinetic rate, can be very useful
for practitioners manually optimizing hyper-parameters.
Now, let us examine the ﬁnal cost Hamiltonian close
to a local minimum Φ∗.
Let us assume that there is
a local Taylor series expansion for the potential J (Φ)
around this point in parameter space. Because it is a
local optimum, the ﬁrst order term, ∼∇J (Φ∗), should
vanish, giving us
J (ˆΦ) ≈J (Φ∗) + 1
2(ˆΦ −Φ∗)T  ∇∇T J (Φ∗)

(ˆΦ −Φ∗).
(84)
This is simply a quadratic potential. Let us write K :=
∇∇T J (Φ∗). Since Φ∗is a local minimum, the Hessian
K will have strictly positive eigenvalues, hence the cost
Hamiltonian around the local minimum is simply that of
a collection of quantum harmonic oscillators. The eigen-
basis of K is called the set of normal modes for the os-
cillators. Let us write O to denote the orthogonal ma-
trix which maps to the normal mode basis of K, and let
{κn}N
n=1 be the set of eigenvalues of K. Let us also write
the quadratures in this basis as ˆq := O ˆΦ (correspond-
ingly, q∗:= OΦ∗) and ˆp := O ˆΠ. Then we can write the
cost Hamiltonian as:
ˆHc =
N
X
n=1
h
1
2mc ˆp2
n + 1
2κn(ˆqn −q∗
n)2i
.
(85)
In the parameter Hilbert space, this Hamiltonian is di-
agonalized in the joint Fock bases of the normal modes.
The gap between adjacent Fock states of the nth mode
is the frequency ωn :=
p
κn/mc.
Therefore, the gap
of the entire Hamiltonian is the smallest of these gaps:
∆c := minn ωn.
The ground state of the cost Hamiltonian written in
the original variables is given by:
Ψc(Φ) = [det(
p
mcK/π)]1/4e−
√mc
2
(Φ−Φ∗)T √
K(Φ−Φ∗),
(86)
which is a Gaussian with mean Φ∗and covariance matrix
Σ :=
1
2√mc K−1/2. We see that having a higher mass
parameter will concentrate the wavefunction around the
optimum, but reduce the gap. Thus, we can get a sharper
estimate of the optimum value at the cost of having a
longer runtime if we want to be sure to stay in the ground
state and obey the adiabatic principle. We illustrate this
in Figure 7.
Figure 7. Local ground state of at a local minimum of the
cost function, for two distinct values of kinetic term. Repre-
sented above are the cost function (gray), its Taylor expan-
sion near the local minimum (dashed), the spectrum of the
eﬀective Hamiltonians (horizontal lines) and the wavefunc-
tion in parameter space of the corresponding ground states,
for a large (left) and small (right) ﬁnal kinetic rate relative
to phase kicking rate of the simulated adiabatic evolution.
Taylor-expanded cost function potential can be locally ap-
proximated with a harmonic (second order) potential.
De-
pending on the ratio of ﬁnal kinetic vs. phase kicking rates of
the simulated adiabatic evolution, the eﬀective Hamiltonian
near the local minimum admits a ground state of higher vari-
ance for a greater gap, or lower variance with smaller gap.
Hence the slower the adiabatic evolution the sharper one can
concentrate the wavefunction on the local minimum value.
We have discussed the gap of the ﬁnal (cost) Hamilto-
nian (near a local minimum), but to obey the adiabatic
condition (ensuring that the system stays in the instan-
taneous ground state at all time), we want to make sure
to evolve the system adiabatically on a time scale greater

20
than the gap of the interpolating Hamiltonian. To show
that the interpolating Hamiltonian has a ground state
gap will generally not be possible. However, if the po-
tential in the initial Hamiltonian is centered near the op-
timum of the cost potential (i.e., Φ0 ≈Φ∗), then we can
use the Taylor expansion (84) of the cost potential and
approximate the interpolating Hamiltonian as:
ˆH(τ) ≈
ˆΠ2
2m(τ)+ 1
2(ˆΦ−Φ0(τ))T K(τ)(ˆΦ−Φ0(τ))+E0(τ),
(87)
where
m(τ) :=
h 1 −τ
T

1
m0 +
  τ
T

1
mc
i−1
,
(88)
K(τ) :=
 1 −τ
T

k0 +
  τ
T

K,
(89)
Φ0(τ) := K−1(τ)
 1 −τ
T

k0Φ0 +
  τ
T

KΦ∗
, (90)
E0(τ) :=
  τ
T

J (Φ∗) −1
2ΦT
0 (τ)K(τ)Φ0(τ)
+ 1
2
 1 −τ
T

k0Φ2
0 + 1
2
  τ
T

Φ∗T KΦ∗.(91)
Notice that since the initial coupling matrix is propor-
tional to the identity, k0 ˆI, then the two terms in the
expression for K(τ) can be simultaneously diagonal-
ized.
Hence, the eigenvalues of K(τ) will be κn(τ) =
(1 −τ/T)k0 + (τ/T)κn. Due to the fact that k0 > 0 and
the spectrum of K is positive, then the eigenvalues of
K(τ) are also positive as they consist of a convex combi-
nation of two positive numbers. Similarly, we have that
m(τ)−1 > 0 as it is a convex combination of positive
numbers (inverse masses of the initial and cost Hamilto-
nians). Therefore, the gap of the interpolating Hamilto-
nian, for any τ, which is the minimum eigenvalue of the
matrix W (τ) =
q
1
m(τ)K(τ), will be positive. That is,
∆g(τ) = minn
p
κn(τ)/m(τ) > 0 for all τ ∈[0, T].
C.
Momentum Measurement Gradient Descent
Momentum Measurement Gradient Descent (MoM-
Grad) is a way to perform a descent of the parameter
landscape in a way leveraging a quantum advantage rela-
tive to ﬁnite-diﬀerence methods, [14] but which requires
far less coherence time than Quantum Dynamical De-
scent. In many ways, it is very similar to typical gradient
descent, but in this case rather than via classical back-
propagation or automatic diﬀerentiation, the gradient is
obtained via the phase kickback principle and by mea-
surement of momentum perturbations. As was outlined
in a previous subsection, acting a phase kick with respect
to the cost function and backpropagating this phase kick
through the parametric circuit is akin to a ﬁnite time-
step contribution to shifting the momentum of each pa-
rameter. It is thus a "force kick", and by measuring the
shift in momenta, we can estimate the gradient of the
landscape, since we showed that the shift in momenta's
expectation values will be proportional to the gradient of
the cost function. Rather than letting the Schrodinger
dynamics naturally shift the parameter values after hav-
ing their momenta kicked, we use classical computation
to update the initialization of parameters for the next
iteration.
The algorithm consists of ﬁrst preparing an appropri-
ate momentum pointer state of the parameters, then ap-
plying the Quantum Feedforward and Baqprop (QFB)
algorithm outlined above, followed my a measurement
the momentum to obtain an estimate of the gradient.
In general, multiple runs and measurements are neces-
sary to get a sharp estimate of the gradient. We brieﬂy
analyze the tradeoﬀs between having a pointer state of
high certainty in parameter value versus obtaining a high
precision in the gradient. We will also consider how the
classical parameters for the momentum pointer state will
interface with the quantum algorithm in the classical-
quantum updating loop.
The type of initial pointer state of the parameters for
MoMGrad can be a Gaussian state, similar to that used
to initialize the parameters for Quantum Dynamical De-
scent.
For example, in the parameter eigenbasis, one
could write the wavefunction in the form
Ψ0(Φ) =
1
|2πΣ0|1/4 e+iΠ0·Φe−1
4 (Φ−Φ0)T Σ−1
0
(Φ−Φ0),
(92)
where Σ0 is the covariance matrix of the Gaussian, Φ0
and Π0 are the parameter and momentum expectation
values, respectively. For the sake of generality, we include
a preemptive momentum bias Π0, which is occasionally
used in variants of the gradient descent algorithms in
classical machine learning [60].
These sets of classical
parameters can be considered as hyper-parameters which
can be optimized using trial and error or using techniques
from Section IV D.
We can contrast the spread of the wavefunction with
that in the Fourier conjugate basis,
˜Ψ0(Π) =

2Σ0
π

1/4
e−iΦ0·Πe−(Π−Π0)T Σ0(Π−Π0).
(93)
(Ignoring global phases.) The covariance matrix in mo-
mentum space is now inverted.
For example, in the
case where this matrix is proportional to the identity,
Σ = σ2I, the variance in each of the parameters is σ2,
whereas the variance of the corresponding momentum is
1/4σ2. Thus they are inversely related as dictated by the
Heisenberg uncertainty principle.
Let us consider how the classical parametrization of
the wavefunction, {Φ0, Π0, Σ0}, gets updated at a given
epoch, through the classical-quantum approach.
Once
such an initial state has been prepared, the next step is
to apply the Quantum Feedforward and Baqprop (QFB)
circuit. Recall that after running this over a full data
batch, the momentum is updated according to
eiηJ (ˆΦ)Πe−iηJ (ˆΦ) = ˆΠ −η∇J (ˆΦ) + O(η2).
(94)
We could also examine the eﬀect this has on the wave-
function. Eventually we want to perform a measurement

21
of the momentum in order to obtain an estimate for the
gradient. By studying the statistics of each run in the
Schr¨odinger picture, we can assess how many runs are
necessary to obtain a particular precision for the gradient
estimate. In the Schr¨odinger picture, the QFB algorithm
acts as a non-linear phase shift on the initial wavefunc-
tion:
|Ψ0⟩7→e−iηJ (ˆΦ) |Ψ0⟩.
(95)
If the wavefunction is suﬃciently localized in parameter
space, around the mean Φ0, then we can Taylor-expand
the cost function,
J (ˆΦ) ≈J (Φ0) + (ˆΦ −Φ0)T ∇J (Φ0) + O

(ˆΦ −Φ0)2
,
(96)
and the QFB algorithm can be approximated as a linear
phase shift according to the gradient of the cost function
at the point Φ0,
⟨Φ| e−iηJ (ˆΦ) |Ψ0⟩
≈
1
|2πΣ0|e+i(Π0−η∇J (Φ0))·Φe−1
4 (Φ−Φ0)T Σ−1
0
(Φ−Φ0)
(97)
(Ignoring global phases.) Of course, this is equivalent to
shifting the average of the momentum,
⟨Π| e−iηJ (ˆΦ) |Ψ0⟩
≈

2Σ0
π

1/4
e−iΦ0·Π
× e−(Π−Π0+η∇J (Φ0))T Σ0(Π−Π0+η∇J (Φ0)).
(98)
Now that we have shown how the wavefunction gets
shifted in momentum space, the next step in the algo-
rithm is to measure the wavefunction in the momen-
tum basis to get an estimate for the average gradient.
To perform this measurement, one simply applies the
Fourier transform on each of the parameter registers,
ˆ
F := ⊗N
n=1 ˆF (n), and subsequently measures the state in
the standard (parameter) basis. From the Born rule, we
see that this measurement will draw a sample from the
probability distribution, p(Π) = | ⟨Π| e−iηJ (ˆΦ) |Ψ0⟩|2.
For the case where the wavefunction is highly localized
in parameter space, this distribution is approximately
Gaussian:
| ⟨Π| e−iηJ (ˆΦ) |Ψ0⟩|2
≈

2Σ0
π

1/2
e−2(Π−Π0+η∇J (Φ0))T Σ0(Π−Π0+η∇J (Φ0)),
(99)
with mean, Π0 −η∇J (Φ0), and covariance,
1
4Σ−1
0 .
Supposing that we perform r measurement runs, our
point-estimate of the mean of the momentum can be
seen as a sample from the normal distribution N(Π0 −
η∇J (Φ0), 1
4Σ−1
0 /r). Thus, with M runs, and initial pa-
rameter covariance, Σ0 = σ2 ˆI, we can estimate the com-
ponents of the average gradient each with a precision
(standard deviation) 1/2σ√r.
We see that increasing
the uncertainty in the initial parameter space wavefunc-
tion allows for quadratically fewer runs to estimate the
gradient within the same precision.
In the general case, without the simplifying assumption
of the wavefunction being highly localized in the param-
eter eigenbasis, the outcomes of multiple measurement
runs can be combined into a sample mean to generate an
estimate of the average momentum. Given that the orig-
inal momentum expectation value, Π0, is known (since
it is a parameter of the initial pointer state preparation),
and the average momentum is updated as
⟨Ψ0| ˆΠ |Ψ0⟩7→Π0 −η⟨∇J (ˆΦ)⟩0 + O(η2),
(100)
where we have written ⟨∇J (ˆΦ)⟩0 := ⟨Ψ0| ∇J (ˆΦ) |Ψ0⟩.
From an estimate of the average momentum, we can ex-
tract an estimate for the average gradient (to ﬁrst order
in η), η⟨∇J (ˆΦ)⟩0.
Once we have estimated this average gradient to
the desired precision, we use the result to reinitial-
ize the wavefunction with a new set of parameters,
{Φ0, Π0, Σ0}, in order to repeat this process at the next
epoch. The momentum parameter is updated according
to the shift of the average momentum induced by the cost
potential phase kick, i.e.,
Π0 7→Π0 −η⟨∇J (ˆΦ)⟩0.
(101)
Then we use this new momentum to update the param-
eter value:
Φ0 7→Φ0 + γ

Π0 −η⟨∇J (ˆΦ)⟩0

.
(102)
Note the appearance of the hyper-parameters η and γ.
These are in direct analogy to their counterparts in the
Quantum Dynamical Descent algorithm from the previ-
ous subsection. We will provide a visual comparison of
the phase space behavior of both MoMGrad and QDD in
the following subsection.
An alternative to the above update rule is to discard
the momentum between updates, and always initialize
the momentum of the wavefunction to zero, Π0 = 0. In
this case, we simply update the parameter values accord-
ing to the rule,
Φ0 7→Φ0 −γη⟨∇J (ˆΦ)⟩0.
(103)
Then we recover the classical update rule for gradient
descent (without momentum). Here, the learning rate is
a product of the phase kicking and kinetic rates.
Above we discussed the fact that increasing the un-
certainty in the parameter wavefunction will allow for a
more precise estimate of the average gradient using fewer
measurement runs. However, of course increasing the un-
certainty means that the wavefunction is no longer well

22
localized in parameter space. Therefore, even if we ob-
tain a precise estimate of the average gradient,
⟨∇J (ˆΦ)⟩0 =
Z
dΦ|Ψ0(Φ)|2∇J (Φ),
(104)
the information we obtain is only a coarse-grained indi-
cation of the direction in which the parameters should be
shifted in order to achieve the minimum of the cost func-
tion. Ideally, as in the case of QDD, one would like to use
the full operator ∇J (ˆΦ) to update the wavefunction in
each branch of the superposition over the parameters Φ.
In the case of MoMGrad, we only extract an expectation
value for this operator and move the entire wavefunction
to be centered at this updated parameter value. There-
fore, there is a trade-oﬀwhich is forced upon us by the
uncertainty principle, namely, that obtaining a more pre-
cise estimate of the gradient requires less uncertainty in
momentum space (a sharper momentum pointer state),
yet this estimate will only contain information about the
gradient averaged over a larger region of parameter space.
Figure 8. Two iterations of Momentum Measurement Gra-
dient Descent.
We use the same graphical notation as in
ﬁgure 6; Ξ = {γ, η} and Θ = {Φ0, Π0, Σ0} represent the
descent rate and preparation hyper-parameters respectively.
The measurement-controlled adder represents equation (101),
while the update of the hyper-parameters represents equation
(102), as well as the change in choice of preparation and rate
hyper-parameters for the next epoch. The register labels are
the same as in ﬁgure 6. Once again we picture the procedure
for classical data learning but the above is directly extendible
to quantum data learning scenarios.
D.
Phase Space Visualization
In Figure 9, we present a visual side-by-side compar-
ison of the Momentum Measurement Gradient Descent
and Quantum Dynamical Descent algorithms. For the
purpose of simply illustrating the diﬀerences, the ﬁgure
examines the evolution of the wavefunction for a single
continuous variable (plotted as a Wigner function, de-
ﬁned in Subsection II A) under a simple cubic poten-
tial, J (Φ) = Φ3 + 2Φ. In the ﬁgure, we show the ini-
tial wavefunctions, and then three steps of each of the
QDD and MoMGrad algorithms:
a phase kick, a ki-
netic pulse/measurement and reinitialization, and a sec-
ond phase kick.
Both of the algorithms are intialized to the same Gaus-
sian wavefunction, with zero mean position and momen-
tum (Φ0 = 0 and Π0 = 0 in our notation from the previ-
ous sections), and initial position uncertainty set to σ2
0 =
1 (correspondingly, the initial momentum uncertainty is
1/4σ2
0 = 1/4). The ﬁrst phase kick according to the cubic
potential is also the same for both algorithms, i.e., the
momentum is updated by Π 7→Π −η(3Φ2 + 2) + O(η2).
Note that in the above simulation, we use the full phase
kick e−iηJ (Φ), rather than only the approximation to ﬁrst
order in η.
The point at which QDD and MoMGrad diﬀer is in the
next step. After the ﬁrst phase kick, in QDD the next
step is to apply a kinetic pulse in order to evolve the Φ
quadrature of the wavefunction, so that the parameters
are updated according to the momentum kick. Under this
operation, all of the branches of the wavefunction move
independently of one another according to how they were
shifted by the local gradient. For example, the edges of
the wavefunction (in the Φ direction) which are initialized
in an area of higher slope of the potential are kicked
with a greater force than pieces of the wavefunction near
the origin. This causes these pieces of the wavefunction
to update more signiﬁcantly after the application of the
kinetic pulse.
Note that in the ﬁgure we have chosen
relatively large kinetic and phase kicking rates in order
to exaggerate the evolution so that one can see more
clearly the diﬀerences between the two algorithms.
In MoMGrad, one takes the expectation value of the
momentum after the phase kick. Since we began with
Π0 = 0, this average gives us −η dJ (Φ)
dΦ . Then the step
after the phase kick is to reinitialize to a new Gaussian
shifted according to this measurement (which we show in
the third step of MoMGrad in the ﬁgure). Therefore, as
opposed to QDD, the branches of the wavefunction are
not shifted independently, but they are all updated in the
same manner. Note also that since MoMGrad parameter
updates are achieved using the average of the potential
gradient, not the gradient of the average potential, there-
fore, for example, even if the wavefunction happened to
be centered at a saddle point (and had zero initial mo-
mentum), the location would still be shifted after the
parameter update.
The last step we show is a second phase kick after the
kinetic pulse of QDD and the measurement and reini-
tialization of MoMGrad.
Because MoMGrad is reini-
tialized to a Gaussian state in place of applying the ki-
netic pulse of QDD, it does not retain the non-Gaussian
features of the evolution induced by the generally non-
quadratic potential J (Φ). This is particularly apparent
in the rightmost plots of the ﬁgure, where we see that al-
though both methods roughly track the same evolution,
in QDD these non-Gaussianities accumulate, whereas in
MoMGrad they are periodically removed.

23
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
Φ
⇧
⇧
⇧
⇧
Φ
Φ
Φ
e)
f)
g)
h)
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
5
4
3
2
1
0
-1
-2
-3
-4
-5
-5 -4 -3 -2 -1  0  1  2  3  4  5
Φ
⇧
⇧
⇧
⇧
Φ
Φ
Φ
a)
b)
c)
d)
Figure 9. Comparison of the Momentum Measurement Gradient Descent (MoMGrad) algorithm (a)-(d), and the Quantum
Dynamical Descent (QDD) algorithm (e)-(h). Both algorithms are initialized to the same Gaussian state in (a) and (e), and
undergo the same phase kick in (b) and (f). The momentum measurement and reinitialization of MoMGrad is shown in (c),
whereas the result of the kinetic pulse of QDD is shown in (g). Plots (d) and (h) show the ﬁnal phase kick for MoMGrad and
QDD (respectively).
IV.
FURTHER QUANTUM DESCENT
METHODS
In this section we discuss a collection of variations upon
elements of the algorithms presented above, as well as
possible augmentations one can use in conjunction with
some of these procedures.
A.
Batching & Parallelization
In Subsections III B and III C, we outlined basic cases
of the Quantum Dynamical Descent (QDD) and Momen-
tum Measurement Gradient Descent (MoMGrad) algo-
rithms. During this previous analysis, we assumed full
batching of the data at every parameter update. That
is, we assumed the cost function was the averaged loss
over every data point in the dataset. Here, we will make
the distinction between an iteration, corresponding to an
update of the parameters, and an epoch, which is a sweep
through the entire dataset. In the above discussion, each
iteration was a full epoch; now we will examine alterna-
tives. As QDD and MoMGrad have numerous connec-
tions with classical deep learning, we can draw inspira-
tion from these techniques to engineer such alternatives.
1.
Quantum Stochastic Descent
One of the core techniques in classical deep learning is
stochastic gradient descent (SGD) [1]. In this approach,
one uses the loss function of a single data point as the
cost function for each parameter update (iteration).
We will ﬁrst describe how to apply this to Quantum
Dynamical Descent. Let us denote a dataset (classical or
quantum) by D. For example, this could be a collection of
input/output pairs of classical vectors or quantum states.
The data points in this set will be indexed by j ∈B. For
each data point (classical or quantum), the corresponding
eﬀective loss function arising from the Quantum Feedfor-
ward and Baqprop algorithm will be written as Lj(ˆΦ).
Stochastic Quantum Dynamical Descent then consists of
applying the unitary
ˆUsqdd =
Y
j∈B
e−iγj ˆ
Π2e−iηjLj(ˆΦ).
(105)
That is, for each data point we have the exponentiated ef-
fective loss function from QFB (which holds to ﬁrst order
in ηj), as well as a kinetic pulse. At the jth iteration, the
parameters get shifted by the gradient of the loss func-
tion for the jth data point, to ﬁrst order in the kicking
rate,
eiηjLj(ˆΦ)eiγj ˆ
Π2/2 ˆΦ e−iγj ˆ
Π2/2e−iηjLj(ˆΦ)
= ˆΦ + γj ˆΠ −ηjγj∇Lj(ˆΦ) + O(γ2
j , η2
j ).
(106)

24
We get the gradient update rule, similar to classical
stochastic gradient descent.
Note the unitary (105) is
for a single epoch (sweep over the entire dataset); it can
be repeated for multiple epochs.
For the SGD variant of Momentum Measurement Gra-
dient Descent, we similarly update the parameters af-
ter kicking with the exponential of the loss of each data
point. Before the jth parameter update the parameter
space wavefunction can be reinitialized to a Gaussian
state,
Ψ(j)(Φ) =
1
|2πΣ(j)|1/4 e+iΠ(j)Φ
× e−1
4 (Φ−Φ(j))T (Σ(j))−1(Φ−Φ(j)),
(107)
where Π(j) is the expectation value of the momentum
from the previous measurements, Φ(j) is the expectation
value of the parameter vector, and Σ(j) is the covariance
matrix for the jth update round (the latter being consid-
ered as a classical hyper-parameter). Now, by applying
the QFB circuit using the loss function of the jth data
point,
|Ψ(j)⟩7→e−iηjLj(ˆΦ) |Ψ(j)⟩,
(108)
and then applying the Fourier transform on each parame-
ter register and measuring the output (i.e., measuring the
momentum), we obtain the updated average momentum
as the expectation value
Π(j+1) := ⟨Ψ(j)|eiηjLj(ˆΦ) ˆΠe−iηjLj(ˆΦ)|Ψ(j)⟩
= Π(j) −ηj∇Lj(Φ(j)) + O(η2).
(109)
We then classically update the parameter expectation
value for the next round as
Φ(j+1) := Φ(j) + γjΠ(j+1).
(110)
This is the parameter iteration for the the jth data point.
We then sweep over the data set for a full epoch, updating
both the momentum and parameter expectation values at
each step. This can be repeated for multiple sweeps over
the dataset (epochs) as necessary.
In both stochastic QDD and stochastic MoMGrad, we
have the hyper-parameters {ηj, γj}j∈B, which are the
phase kicking and kinetic rates for each update. To op-
timize these hyper-parameters there are various classical
heuristics from which we can draw inspiration [61, 62].
Note that in our case the learning rate is a product of
both the phase kicking rate and kinetic rates.
As in the classical case, stochastic descent has some
perks; it tends to regularize the landscape and avoid over-
ﬁtting [63]. However, this comes with a tradeoﬀof being
noisy and hence unstable for high learning rates.
2.
Sequential Mini-Batching
In classical machine learning, a common practice is
to partition the training data into mini-batches of data.
That is, we can partition our dataset as D = ∪k∈SMk,
where S is an index set over the mini-batches. In turn,
each mini-batch, Mk, consists of a number of data points
indexed by j ∈Bk.
For the purposes of generating a cost function, sequen-
tial mini-batching will consist of consecutive applications
of the phase kicks for each data point in a mini-batch,
before either acting the kinetic term or classically shift-
ing the mean parameter vector, in the cases of QDD and
MoMGrad, respectively.
By sequentially applying the
phase kicks for every data point in the mini-batch, there
is a summation of the contributions to the shifts in the
momentum of the parameters.
Therefore, the average
momentum shift over the mini-batch can be used in the
parameter update. In the next subsubsection, we will ex-
plore an alternative where the average momentum shift
over a mini-batch is produced through an accumulation
of phase kicks applied in parallel rather than sequentially.
For the present case, we can write the explicit unitary
corresponding to a sequentially mini-batched version of
Quantum Dynamical Descent,
ˆUsmqdd =
Y
k∈S

e−iγk ˆ
Π2 Y
j∈Bk
e−i¯ηkLj(ˆΦ)
,
(111)
where we have the loss function Lj( ˆΦ) for each data
point, j ∈Bk. We have also denoted a modiﬁed kick-
ing rate ¯ηk := ηk/|Mk|, which is normalized by the size
of the mini-batch. If we consider the the cost function for
mini-batch k to be the average loss over the mini-batch,
Jk(ˆΦ) =
1
|Mk|
P
j∈Bk Lj(ˆΦ),
(112)
then we see that sequentially applying the QFB losses for
each data point in the mini-batch is the same as applying
the mini-batch cost exponential,
ˆUmqdd =
Y
k∈B
e−iγk ˆ
Π2e−i¯ηk
P
j∈Bk Lj(ˆΦ)
=
Y
k∈B
e−iγk ˆ
Π2e−iηkJk(ˆΦ).
(113)
Note that for each application of e−i¯ηkLj(ˆΦ), one executes
the QFB circuit for the jth data point, and in the above
each data point's exponential loss is applied in sequence
over the minibatch index before a kinetic pulse is applied.
Using the above expression, we can derive the update rule
for the parameters for each minibatch,
eiηkJk(ˆΦ)eiγk ˆ
Π2/2 ˆΦ e−iγk ˆ
Π2/2e−iηkJk(ˆΦ)
= ˆΦ + γk ˆΠ −ηkγk∇Jk(ˆΦ) + O(γ2
k, η2
k).
(114)
We see that we have the same update rule as in the case
of SQDD (106), but now for the averaged gradient over
the minibatch.
For the minibatched Momentum Measurement Gradi-
ent descent, there are two options: accumulate momen-
tum kicks sequentially in a quantum coherent fashion be-
fore measuring the momenta, or measuring the momen-
tum shift for each data point and classically summing up

25
the contributions for the parameter iteration. Although
the latter approach requires less coherence, more runs
are necessary to get an accurate estimate of the momen-
tum expectation value as compared to the former. Let
us consider the coherent momentum accumulation ﬁrst,
we start with a pointer state |Ψ(k)⟩for the kth iteration,
which we assume has a parameter space representation,
Ψ(k)(Φ) =
1
|2πΣ(k)|1/4 e+iΠ(k)Φ
× e−1
4 (Φ−Φ(k))T (Σ(k))−1(Φ−Φ(k)).
(115)
The coherently sequentially minibatched momentum
measurement gradient descent approach then consists of
applying all the QFB circuits for the loss function expo-
nential of each data point in sequence:
|Ψ(k)⟩7→
 Y
j∈Bk
e−i¯ηkLj(ˆΦ)
|Ψ(k)⟩= e−iηkJk(ˆΦ) |Ψ(k)⟩.
(116)
Note that same notation as in SMQDD above was used.
If we then measure in momentum space (by applying the
Fourier transform and measuring all the parameter reg-
isters), we can update the momentum expectation value
Π(k+1) := ⟨Ψ(k)| ˆΠ|Ψ(k)⟩
= Π(k) −ηk ⟨Ψ(k)|∇Jk(Φ)|Ψ(k)⟩+ O(η2
k).
(117)
If the covariance matrix of the parameters is chosen to
be diagonal with entries (σ(k)
n )2 (where n indexes the pa-
rameters), then the nth component of the gradient can be
estimated to a precision (standard deviation) 1/2σ(k)
n
√r
with r runs of preparation and measurement.
In contrast, the classically accumulated minibatched
momentum measurement gradient descent proceeeds by
preparing a copy of the pointer state for each data point,
i.e., |Ψ(k)⟩= N
j∈Bk |Ψ(k,j)⟩. (Here we use the tensor
product notation, but one could also consider measuring
and resetting sequentially). Assuming the pointer states
|Ψ(k,j)⟩are all identical copies of the form (115), by ap-
plying sequentially the exponential loss of each data point
in the minibatch on the diﬀerent copies
|Ψ(k)⟩7→
 O
j∈Bk
e−i¯ηkLj(ˆΦ)
|Ψ(k)⟩
=
O
j∈Bk
e−i¯ηkLj(ˆΦ) |Ψ(k,j)⟩,
(118)
measuring each copy's momenta, and classically summing
up the results yields the expectation value
1
|Mk|
P
j∈Bk ⟨Ψ(k)| ˆΠ(j)|Ψ(k)⟩
= Π(k) −ηk ⟨Ψ(k)|∇Jk(Φ)|Ψ(k)⟩+ O(η2
k)
(119)
Note that if the covariance matrix for all data points is
diagonal with entries (σ(k)
n )2, then with r runs for each
data point in the minibatch Mk, the expectation value
of the nth component of the gradient can be estimated
to a precision
p
|Mk|/2σ(k)
n
√r. Hence, an option is to
increase the variance of the pointer states (in position)
or to perform more runs. Given a minimal variance of
pointer states (e.g., limited number of qubits per param-
eter in the DV case, or limited squeezing levels in the
CV case), then the coherent accumulation of momenta
yields an advantage in terms of runs needed for a cer-
tain precision. In any case, one then updates the average
momentum parameter vector by the expectation value
above,
Π(k+1) := Π(k)−ηk ⟨Ψ(k)|∇Jk(Φ)|Ψ(k)⟩+O(η2
k). (120)
We get the same result as with the coherently accumu-
lated version, but possibly with a diﬀerent precision as
noted above.
In both cases, once the momentum was updated, we
can classically update the parameters expectation for the
next round as
Φ(k+1) := Φ(k) + γkΠ(k+1).
(121)
Thus concludes an iteration of sequentially minibatched
gradient descent, with either coherent or classical mo-
mentum accumulation. We can now consider how to par-
allelize the gradient accumulation over a minibatch.
3.
Coherently Accumulating Momentum Parallelization
An important development in the deployment of large
neural networks is the possibility to parallelize the train-
ing over minibatch elements. Classically, this would be
achieved by feeding forward the information of each data
point and computing the gradient contribution on dif-
ferent replicas of the network, each replica running on
diﬀerent registers in spatially parallel fashion, either on
diﬀerent cores or diﬀerent processors. Once the gradi-
ent contributions are computed, the replicas must com-
municate the gradient values to update their parameters
synchronously.
The same parallelization will be possi-
ble for Baqprop, but instead of adding gradients, we will
accumulate momenta coherently. The non-coherent clas-
sical version of parallel accumulation of momenta adapts
trivially from the above sequential version, hence we will
focus on the coherent accumulation of momenta. We call
this approach Coherently Accumulating Momentum Par-
allelization (CAMP).
The parallelism of CAMP relies on leveraging GHZ-
like entanglement [64] of the weights of the replicas. A
central quantum parameter server keeps in quantum co-
herent memory the weights at the beginning of an epoch,
then by coherently adding the parameter values onto dif-
ferent replicas, acting the QFB circuit for each data point
replica, and uncomputing the coherent addition, the cen-
tral parameter server will have accumulated all the mo-
menta contributions from the various replicas. This can

26
be seen as extending the phase backpropagation through
the computation that is the distribution and recollection
of the parameter values via adder gates.
Consider the parameter eigenstates of the various repli-
cas to be labelled as |Φ⟩[c] where c is the index of the
replica, with c = 0 being the index of the central pa-
rameter server. For minibatch parallelization, we have a
number of replicas equal to the minibatch size, as such,
for the kth minibatch, c ∈Bk, we begin with the state
of the central parameter server at iteration k, with the
replica's parameters set to null (squeezed state for CV or
null position state for qudit), i.e.,
|Ψ(k)⟩[0]
O
c∈Bk
|0⟩[c] =
X
Φ
Ψ(k)(Φ) |Φ⟩[0]
O
c∈Bk
|0⟩[c] .
(122)
Now, using adder gates (either CV or DV depending on
the architecture), we transform this state to
|Ψ(k)⟩[0]
O
c∈Bk
|0⟩[c] 7→
X
Φ
Ψ(k)(Φ) |Φ⟩[0]
O
c∈Bk
|Φ⟩[c] .
(123)
Eﬀectively, we are applying a parameter replication uni-
tary, which we will call the Tree Entangler (TENT),
which adds the parameter values to the replicas, as in
ˆUtent =
Y
c∈Bk
e−iˆΦ[0]⊗ˆ
Π[c].
(124)
Rather than applying this addition sequentially as above,
this addition can be achieved in logarithmic depth in
the size of the minibatch, by using adders in a sequence
shaped like a n-ary tree. This is a depth-optimal way to
add standard basis values onto multiple target registers
by using adders recursively, as to form a perfect (or com-
plete) n-ary tree of adders. For a complete n-ary tree
structure, we can create a GHZ state on r+1 registers in
a depth O(n logn(r)). Practically, the depth will be de-
termined by the interconnectivity of the diﬀerent sets of
registers, as it is the case classically where the bottleneck
of data parallelization is highly dependent on the inter-
connect between chips [65]. Figure 10 provides a circuit
diagram illustrating the Tree Entangler.
Coherently Accumulating Momentum Parallelization
(CAMP) consists of applying the TENT unitary, then ap-
plying the QFB circuit for each corresponding data point
in the minibatch on the diﬀerent replicas, and ﬁnally un-
computing the TENT. This is illustrated in Figure 11.
For the minibatch of index k, the CAMP unitary would
consist of:
ˆUcamp,k = ˆU †
tent
 O
j∈Bk
e−i¯ηkLj(ˆΦ[j])
ˆUtent.
(125)
We can compute the eﬀect of this conjugation as
ˆUcamp,k =
Y
j∈Bk
e−i¯ηkLj(ˆΦ[0]+ˆΦ[j]).
(126)
Figure 10. Example of Tree Entangler (TENT) unitary with
a binary tree structure. Left is a compact graphical represen-
tation for the TENT, and on the right is its expanded form.
Each CV adder is as in equation (2). For a complete n-ary
tree structure of adders, we can create a GHZ state on r + 1
registers in a depth O(n logn(r)).
Figure 11.
Example of a ﬁrst iteration of a Coherent Ac-
cumulation of Momentum Parallelization protocol (CAMP),
applied to a Quantum Dynamical Descent (QDD), for classi-
cal data. The replica ˆΦ[0] is the quantum parameter server,
the initial pointer state of the parameters is prepared in this
register via the unitary ˆUp(Θ), the TENT unitary (see Fig.
10) is then applied to entangle the parameter server with the
replicas ˆΦ[j]. Following this, the QFB circuit is applied for a
certain data point in each replica in a parallel fashion, then
the TENT unitary is uncomputed (inverse TENT represented
with [-] boxes). Finally the kinetic term exponential is applied
on the parameter server.
We see that we get a simultaneous exponential loss func-
tion on both the parameter server and the replica, but
since the replicas are initialized in null-parameter value
pointer states, the eﬀective unitary on the parameter

27
server is the minibatch loss function
ˆUcamp,k
O
c∈Bk
|0⟩[c] =
Y
j∈Bk
e−i¯ηkLj(ˆΦ[0]) O
c∈Bk
|0⟩[c]
= e−iηkJk(ˆΦ) O
c∈Bk
|0⟩[c] .
(127)
Hence we can consider CAMP as simply an ancilla-
assisted way to enact the exponential loss function over
the minibatch in a parallelized fashion,
e−iηkJk(ˆΦ).
(128)
One main draw of this method is that there is a speedup
to estimate the minibatch momentum update when done
coherently as compared to a classically accumulated mo-
mentum. Assuming perfect null eigenstates, ˆΦ |0⟩= 0,
initially in the replica's parameter registers, then induc-
ing the GHZ-like entanglement, acting the phase kicks
on each replica, and undoing the GHZ entanglement as
described above, we can resolve the nth component of
momentum within a standard deviation 1/2σ(k)
n
√r with
r runs, while classically accumulating momenta in diﬀer-
ent replicas one would get a
p
|Mk|/2σ(k)
n
√r standard
deviation in the same number of runs.
Using our results from sequential minibatching from
above, it is then straightforward to see how one ap-
plies CAMP to minibatched Quantum Dynamical De-
scent and minibatched Momentum Measurement Gradi-
ent Descent. For example, to perform paralellized Quan-
tum Dynamical Descent, one applies the CAMP for each
minibatch, using the initially null parameter replicas, in-
terlaced with the kinetic pulses in the parameter server
to update the parameter values:
ˆUpqdd =
Y
k∈B
e−iγk ˆ
Π2
[0]U †
tent
 O
j∈Bk
e−i¯ηkLj(ˆΦ[j])
ˆUtent
=
Y
k∈B
e−iγk ˆ
Π2
[0] ˆUcamp,k.
(129)
For Momentum Measurement Gradient Descent, one can
apply CAMP on the kth iteration pointer state
ˆUcamp,k |Ψ(k)⟩[0]
O
c∈Bk
|0⟩[c]
(130)
and follow the same steps and classical updates of the co-
herently sequentially minibatched MoMGrad, as in (117)
and (121).
The technique of employing GHZ-entanglement to get
a sensitivity speedup for phase sensing is well known and
widely used in the quantum sensing literature [66]. In
this literature, this speedup is usually achieved in the
context of discrete qubit/qudit pointers.
4.
Quantum Random Access Memory Mini-batching
One may consider attempting to train the algorithm
using multiple data points of a mini-batch in superpo-
sition. A possible means for doing mini-batching with
a superposition of data is to use Quantum Random Ac-
cess Memory (QRAM) to generate a sum of input states
(along with an address register) for every data point
in the mini-batch.
The general form of the entangled
address-input state is:
|¯ξ⟩ac :=
1
√
|Bk|
X
j∈Bk
|j⟩a |ξj⟩c ,
(131)
where j ∈Bk is an address for a data point in the mini-
batch, and |ξj⟩c is an input state on the computational
Hilbert space, Hc, associated with the corresponding
data point.
In this approach, the parametric unitary, ˆU(ˆΦ), acting
on HΦ ⊗Hc remains unchanged. The loss exponential
becomes a controlled-loss exponential, with the address
register as the control,
X
j∈Bk
|j⟩⟨j|A ⊗e−iη ˆLj,
(132)
where ˆLj is the loss function associated with data point
j. The full QFB circuit in this case is,
ˆU †(ˆΦ)
 X
j∈Bk
|j⟩⟨j|A ⊗e−iη ˆLj
ˆU(ˆΦ) |¯ξ⟩AC
=
1
√
|Bk|
X
j∈Bk
|j⟩A ⊗e−iη ˆLj(ˆΦ) |ξj⟩C ,
(133)
where ˆLj(ˆΦ) := ˆU(ˆΦ)† ˆLj ˆU(ˆΦ). To examine the eﬀect
this has on training the parameters, we can compute the
eﬀective phase operator, e−iηJk(ˆΦ), (again which holds
on average, to ﬁrst order in η), by tracing out both the
address and compute registers (a and c):
Jk(ˆΦ) =
1
|Bk|
X
j∈Bk
⟨ξj| ˆLj(ˆΦ) |ξj⟩c + O(η2).
(134)
Thus we see that in the end we obtain the same ef-
fective phase as in either sequential mini-batching or
CAMP. Let us brieﬂy compare the CAMP and QRAM
approaches to mini-batching with a rough analysis of the
errors in the eﬀective cost function. For CAMP, the er-
ror is O(|Bk| × η2/|Bk|2) = O(η2/|Bk|), since we have
|Bk| copies each with error O(η2/|Bk|2). For QRAM, the
error is O(η2), since we have a single copy of QFB apply-
ing a phase kick with kicking rate η. The sum in QRAM
is obtained from averaging over multiple runs.
Thus,
in QRAM, we are applying larger kicks and the cost
function is obtained stochastically over the data points,
whereas in CAMP we add logarithmic depth to the cir-
cuit in order to run a separate instance of QFB for each
data point in parallel, and the phase kicks are accumu-
lated coherently. Even though in CAMP one has to add
this logarithmic depth to the circuit, it seems that the
error in the eﬀective cost function is suppressed by the
size of the mini-batch, and one also would not have the
diﬃculty of building a QRAM [24].

28
Furthermore, for classical data, the CAMP procedure
for each data point is single-shot, because the computa-
tional register is left in a computational eigenstate at the
end of the QFB procedure. For quantum data, one would
need to run the QFB procedure multiple times in order
to obtain the average over the computational registers in
the eﬀective cost function.
Thus, it would seem that CAMP may be advantageous
to QRAM in certain contexts. We leave a more careful
analysis of the overhead needed in both approaches for
future work.
B.
Discrete Parametric Optimization
In some cases, instead of optimizing over a continuous
space of parameters, one may want to restrict the opti-
mization to a discrete subspace of parameters. In this
subsection, we consider how to perform both QDD and
MoMGrad in order to optimize discretely-parametrized
quantum circuits.
Furthermore, we propose a way to
embed a given discrete parametric optimization into the
continuous-variable versions of the QDD and MoMGrad
protocols via a speciﬁc choice of regularizing potential.
Finally, we show how to approximate continuum gradi-
ents as a ﬁnite-diﬀerence using single qubits for each of
the parameters.
Let us ﬁrst formally deﬁne what we consider to be dis-
crete parametric optimization. If P is the index set of
parameters, then in previous considerations in this pa-
per, the space of parameters was R|P|.
Using n-qubit
precision simulated continuous registers, whose parame-
ter values form a lattice isomorphic to Z|P|
2n we considered
approximating the set of possible parameters on some
interval of R|P|, as described in sec.
II). We consider
discrete optimization to be the case where a subset of
parameters, {Φj}j∈S, for some index subset S, are dis-
crete. The optimization is then over R|C| × Z|S|
d , where
C := P \ S. In this subsection, we will mainly focus on
having a hybrid set of parameters where some parameters
are binary and some are continuous, i.e., hybrid discrete-
continuous parametric optimization over R|C| × Z|S|
2 .
1.
Kicking Hybrid Discrete-Continuous Parameters
Consider the case where we would like a subset of the
parameters to be binary. In a nutshell, the strategy will
be to replace the quadratures of the continuous parame-
ters {ˆΦj, ˆΠj}j∈S for Pauli operators { ˆZj, ˆXj}j∈S, in the
various instances where the quadratures play a role in
the optimization procedures.
For this discrete continuous-binary hybrid parametric
optimization, we start by going from a a continuous para-
metric feedforward unitary ˆU(ˆΦ) to a hybrid continuous-
discrete-parametric feedforward unitary ˆU(ˆΦ, ˆ
Z) of the
form
ˆU(ˆΦ, ˆ
Z) =
X
Φ∈R|C|
X
b∈Z|S|
2
|Φ⟩⟨Φ| ⊗|b⟩⟨b| ⊗ˆU(Φ, b), (135)
where |bj⟩are the eigenstates of ˆZj of eigenvalues (−1)bj,
and |b⟩≡N
j∈S |bj⟩.
For above hybrid-parametric unitary, given a batch of
loss operators {ˆLk}k∈B, the quantum feedforward and
Baqprop circuit for the datum of index k ∈B would
have an induced eﬀective phase kick of the form
e−i¯ηLk(ˆΦ, ˆ
Z) = ⟨ˆU †(ˆΦ, ˆ
Z)e−i¯η ˆLk ˆU(ˆΦ, ˆ
Z)⟩c
(136)
where ˆ
Z is a vector of Pauli operators, ˆ
Z = ( ˆZj)j∈S, and
the expectation value is taken over the initial state of the
compute register as in (53). Here the rate ¯η = η/|B| is
the phase kicking rate η divided by the size of the batch.
By concatenating multiple of these eﬀective phase kicks
in sequence or in parallel (see sec. IV A for techniques
to do so), we can get an eﬀective phase kick for the full
batch cost function
e−iηJ (ˆΦ, ˆ
Z) =
Y
k∈B
e−i¯ηLk(ˆΦ, ˆ
Z).
(137)
We now have an eﬀective phase kick on both the discrete
and continuous parameters for the full cost function.
Before we derive an update rule induced by this eﬀec-
tive phase kick, let us deﬁne some notation and formalism
to treat functions of Paulis. Starting with a single qubit,
any function, f, of the operator ˆZ can be written as
f( ˆZ) = f(1) |0⟩⟨0| + f(−1) |1⟩⟨1|
= 1
2[f(1) + f(−1)]ˆI + 1
2[f(1) −f(−1)] ˆZ.
(138)
Then we deﬁne the derivative of f with respect to the
Pauli-Z operator as the coeﬃcient of ˆZ in the above ex-
pression, i.e.,
∂ˆ
Zf( ˆZ) = 1
2[f(1) −f(−1)].
(139)
Note that since this derivative is simply a coeﬃcient, as
an operator it is taken to be proportional to the identity.
Hence we see that the commutator of a function of ˆZ
with ˆX will give
[f( ˆZ), ˆX] = 2i∂ˆ
Zf( ˆZ) ˆY .
(140)
In general one can have a function of Pauli operators of
multiple registers, ˆ
Z = { ˆZj}M
j=1, which in general has a
decomposition as a polynomial of Paulis,
f( ˆ
Z) =
X
b∈ZM
2
αb ˆ
Zb,
ˆ
Zb :=
 NM
j=1 ˆZbj
j

,
(141)
where αk ∈R, bj ∈Z2 for all j and k. For such multi-
operator function, we deﬁne the partial derivative as
∂ˆ
Zkf( ˆ
Z) :=
X
b∈ZM
2
αb δ1bk
 N
j̸=k ˆZbj
j

(142)

29
which is the sum over terms which had a non-null power
of ˆZk, and for such terms the power of ˆZk is removed.
Finally notice that if we look at the commutator of f( ˆ
Z)
with ˆXk, we get
[f( ˆ
Z), ˆXk] = 2i∂ˆ
Zkf( ˆ
Z) ⊗ˆYk.
(143)
Now, using this formalism, we can derive an update
rule due to an eﬀective phase kick of the form featured
in equation (136),
⟨eiηL(ˆΦ, ˆ
Z) ˆXke−iηL(ˆΦ, ˆ
Z)⟩
= ⟨eiη ad[L(ˆΦ, ˆ
Z)]( ˆXk)⟩
= ⟨cos(2η∂ˆ
ZkL(ˆΦ, ˆ
Z)) ⊗ˆXk⟩
−⟨sin(2η∂ˆ
ZkL(ˆΦ, ˆ
Z)) ⊗ˆYk⟩
= ⟨ˆXk⟩−2η ⟨∂ˆ
ZkL(ˆΦ, ˆ
Z) ⊗ˆYk⟩+ O(η2).
(144)
Now that we have derived an update rule from the phase
kick induced by the hybrid-parametric QFB, we can
leverage this to perform hybrid-parametric variants of
both Quantum Dynamical Descent (QDD) and Momen-
tum Measurement Gradient Descent (MoMGrad).
2.
Continuous-Discrete Hybrid QDD
We begin with the hybrid-parametric variant of QDD.
As established in Section III B, QDD with continuous
quantum parameters is a form of Quantum Alternating
Operator Ansatz (QAOA). Thus, naturally, a continuous-
discrete variable hybrid QDD should be analogous to
both the continuous-variable QDD and a discrete vari-
able QAOA [39].
Our task is to optimize the cost function J (ˆΦ, ˆ
Z),
via alternating exponentials of operators.
In order to
construct such an optimization scheme, we draw inspira-
tion from discrete QAOA. In typical discrete QAOA for
qubits, the cost Hamiltonian is a function of the standard
basis operators ˆ
Z = { ˆZj}j, i.e.
ˆHc = f( ˆ
Z).
(145)
For such a cost Hamiltonian, the traditional choice of
mixer Hamiltonian is one of the form
ˆHm =
X
j
ˆXj,
(146)
i.e. the sum of Pauli ˆX operators.
To some extent, the Pauli ˆZ and ˆX operators are to
a qubit what ˆΦ and ˆΠ are to a harmonic oscillator (con-
tinuous quantum register). The Hadamard gate is the
qubit's analogue of a discrete Fourier transform, and con-
jugation of ˆZ by Hadamards gives ˆH ˆZ ˆH = ˆX. Recalling
the formalism from section II, the ˆΠ quadrature for a
qudit is the Fourier conjugate to the position operator
ˆΦ. As such, in the context of this analogy, the mapping
{ˆΦ, ˆΠ} 7→{ ˆ
Z, ˆ
X} of continuous to discrete operators is
sensible.
Although there is some analogy between ˆΠ and ˆX, this
analogy has its limits as there are a few diﬀerences to
keep in mind. Looking at the update rule in equation
(143), we can contrast this with an analogous formula
for functions f(ˆΦ) of the continuous parameter variables
[f(ˆΦ), ˆΠk] = i∂ˆΦkf(ˆΦ).
(147)
We again get a derivative of the function, but in contrast
to (143), there is no remaining operator with support on
the kth register which tensored with the derivative, we
have the identity on this register instead. Furthermore,
for continuous QDD (see sec. III B), the mixer Hamilto-
nian is ∼ˆΠ2, but Pauli operators are involutory ˆX2 = ˆI,
hence we will have to use ˆXj as the mixer Hamiltonian
for each discrete parameter.
Now that we have built some further intuition, we can
proceed to building the continuous-discrete hybrid QDD
procedure. For this hybrid QDD, the analogue to the cost
Hamiltonian is the full-batch the eﬀective phase operator
from (137),
ˆHc = J (ˆΦ, ˆ
Z)
(148)
Since this eﬀective phase function is dependent on both
the continuous parameter operators ˆΦ and on the Pauli
operators ˆ
Z, we need to add mixer terms of both the
continuous and discrete type. Thus, we chose the mixer
Hamiltonian
ˆHm = β
X
k∈S
ˆXk +
X
j∈C
ˆΠ2
j
(149)
where β is a hyperparameter which can serve as a modi-
ﬁer of the ratio between kinetic rates of the discrete and
continuous parameters. Now that we have deﬁned can
deﬁned our cost and mixer Hamiltonians, we can write
out the whole hybrid-parametric QDD unitary for mul-
tiple epochs as
ˆUhqdd =
Y
j
(e−iγj ˆ
Π2 ⊗e−iβγj ˆ
X)e−iηjJ (ˆΦ, ˆ
Z),
(150)
where we use the following notation for the discrete mixer
exponential
e−iβγj ˆ
X := e−iβγj
P
k∈S ˆ
Xk =
O
k∈S
e−iβγj ˆ
Xk.
(151)
In general, one could vary β for each epoch, i.e. β 7→βj
in (150). This would allow for an independently variable
kinetic rate speciﬁc to the discrete registers, as it could
then be chosen as diﬀerent from the continuous param-
eters' kinetic rate at each epoch. In general, one could
go as far as having speciﬁc kinetic and kicking rates for
each parameter, at the cost of having to optimize more
hyper-parameters.

30
Now, we see in equation (150) that the QDD unitary
becomes a hybrid continuous-discrete QAOA-type uni-
tary.
For a discrete QAOA [39], the hyperparameters
must usually be optimized in order to minimize the cost
function. In this case, our hybrid QAOA's cost function
is the QFB-induced phase J (ˆΦ, ˆ
Z), which is a function
of both the continuous and discrete parameters. By opti-
mizing the the hyperparameters {γj, βj, ηj} of the above
Hybrid QDD, we can expect to minimize the cost func-
tion.
We have established above that the hybrid QDD is
like a QAOA problem, with J (ˆΦ, ˆ
Z) as the QAOA cost
function (Hamiltonian). From previous literature on dis-
crete QAOA [39], we know we can ﬁnd an approximate
minimum of the cost function by optimizing the hyper-
parameters such as to minimize the cost function. These
hyper-parameters are themselves continuous parameters
and thus could be optimized via Meta-QDD or Meta-
MoMGrad approach (covered in the Quantum Meta-
Learning Section IV D) or via quantum-classical meth-
ods. After the QDD, as discussed in section III B, the
continuous parameters should concentrate near a local
minimum in the continuous landscape, and from discrete
QAOA [39] we expect a superposition of bitstrings in the
discrete parameters which statistically favors bitstrings
of low cost function value.
Thus by jointly measuring
both the continuous parameters with the discrete param-
eters, after applying the optimized hybrid QDD unitary,
one should then obtain a set of discrete and continu-
ous parameters for which the cost function is relatively
low value with high probability.
Once these measure-
ments yield a set of classical parameters deemed suﬃ-
ciently optimal, one can then perform inference with a
classical-parametric variant of the feedforward circuit, as
described in section III A 1.
3.
Continuous-Discrete Hybrid Momentum Measurement
Gradient Descent
Now that we have derived a hybrid continuous-discrete
variant of QDD, using the update rule derived in (144),
we can derive a hybrid variant of Momentum Measure-
ment Gradient Descent (MoMGrad).
To add to the intuition provided by the operator up-
date rule in (144), we can understand the full-batch ef-
fective phase kick as a conditional rotation of each qubit,
conditioned on other parameters. To see this let us ﬁrst
deﬁne the notation zb ≡(−1)b as the vector of eigenval-
ues for the bitstring b. We then can rewrite cost-phase
gate induced by the QFB circuit as a controlled-rotation
of the qubit k about its Z axis, for any k ∈S,
e−iηJ ( ˆΦ, ˆ
Z) = |Φ⟩⟨Φ|
O
j∈S\{k}
|bj⟩⟨bj| ⊗e−iη ˆ
Zk∂kJ (Φ,zb).
(152)
We see that, conditioned on all parameters other than
that of qubit k, the gate is eﬀectively a rotation of
the form eiϕk ˆ
Zk where the the angle ϕk of rotation is
ϕk = −η∂kJ (Φ, zb), i.e., proportional to the negative
gradient. This controlled-rotation interpretation further
provides intuition for the update rule derived in (144).
Now, using the update rule (144), we can see that given
an initial state of qubit k in the z-y plane of the Bloch
sphere, we will be able to read oﬀthe gradient given small
rotations. That is, given an initial state of the form
|S0⟩=
O
j∈S

cos(θj) |0⟩j + i sin(θj) |1⟩j

(153)
which all have ⟨ˆXk⟩= 0, and where the θj are hyper-
parameters, which we consider as classical parameters
for the time being.
By applying the QFB phase kick,
each qubit is eﬀectively rotated about the z axis, hence
the state travels laterally at a certain lattitude in the
Bloch sphere, as depicted in Figure 12.
This rotation
then converts initially null x component of the state to
one depending on the initial latitude on the Bloch sphere,
and on the gradient of the cost function, as depicted in
Figure 12. By measuring the expectation value ⟨ˆXk⟩after
the QFB phase kicks from (137), for pointer states of the
form of (153), we can get the gradient as follows,
⟨S0|eiηJ (ˆΦ, ˆ
Z) ˆXke−iηJ (ˆΦ, ˆ
Z) |S0⟩
= −2η sin(2θk) ⟨∂ˆ
ZkJ (ˆΦ, ˆ
Z)⟩+ O(η2).
(154)
We can then use this measurement of the gradient to up-
date the parameters θk 7→θk −ηγ ⟨∂ˆ
ZkJ (ˆΦ, ˆ
Z)⟩for all
k, where γ is a hyperparameter, while simultaneously
performing the MoMGrad for the continuous parame-
ters using update rules discussed in III C. Thus, one can
perform a continuous-discrete hybrid MoMGrad. Once
a suﬃcient number of iterations has been performed,
since the θ parameters are classical parameters which
are known, one can round each of the binary parameters
to the most probable value (b∗
k = ⌊sin2(θk)⌉). One can
then perform further MoMGrad on the continuous pa-
rameters Φ for the hybrid cost function with the classi-
cal binary parameters b∗in the feedforward, i.e., perform
continuous MoMGrad with the cost function J (ˆΦ, zb∗).
Finally one obtains suﬃciently optimal continuous pa-
rameters Φ∗which can then allow for inference with the
hybrid discrete-continuous classically parametrized oper-
ation ˆU(Φ∗, zb∗).
4.
Continuum-Embedded Discrete Optimization
In this section we discuss the possibility of perform-
ing optimization over a discrete subset of hypotheses by
embedding the problem into the continuum and adding
a regularizing potential which forces the weights to con-
verge onto the closest discrete value.
As was discussed above one can use discrete variable
quantum registers, such as a qubits, in order to perform

31
Figure 12. Bloch sphere diagram of single-qubit gradient esti-
mation. |Ψ1⟩= eiηJ (ˆ
Φ, ˆ
Z) |Ψ0⟩the longitudinal angle of rota-
tion relative to the z-y plane is given by 2η∂ˆ
ZkJ (ˆΦ, ˆ
Z), hence
allowing for estimation of the gradient of the cost function via
multiple runs and measurements of the expectation value of
the Pauli ˆ
X.
such a discrete optimization. These discrete optimiza-
tion approaches came with caveats, namely, the hybrid
MoMGrad necessitates multiple QFB runs and measure-
ments to get an accurate estimate of the gradient, while
the hybrid QDD requires hyperparameter optimization
to yields approximately optimal bitstrings. By embed-
ding the discrete parametric optimization into a continu-
ous parametric optimization, we can directly leverage the
continuous parameter variants of MoMGrad and QDD
from section III, rather than have to modify the lat-
ter to accommodate discrete parameters. The approach
which will be outlined in this subsection will be consist
of adding a regularization potential to the continuous pa-
rameters which eﬀectively turns these into a simulated
qubit (or qudit).
If we have some subset of parameters {Φj}j∈S (where
S is the subset of indices) which we would like to be either
0 or λj, then, for either quantum dynamical descent or
momentum measurement gradient descent, we can add
a regularizing potential to the cost: J (ˆΦ) 7→J (ˆΦ) +
VS(ˆΦ), where the regularizing potential is of the kind
VS(ˆΦ) ≡
X
j∈S
ω2
j
2
 
ˆΦj −λj
2
2
−

λj
2
2 2
(155)
which is a sum of double-well potentials, each with wells
centered at 0 and λj. To simulate QDD with this poten-
tial, one would need to apply the unitary
ˆUqdd =
Y
j
e−iγj ˆ
Π2e−iηjJ (ˆΦ)e−iηjVS(ˆΦ),
(156)
with the quartic potential exponential being applicable
through the use of multiple qubic phase gates with CV
techniques [67, 68], or in the DV case using O((log d)4)
4-local Pauli terms (where d is the range of the qudit
parameter register, see section II), similarly to how ex-
ponentials of ˆΦ2 are implemented, see section IV C 1 for
details.
Although an extensive analysis of the dynamics of
quartic oscillators is beyond the scope of this paper,
there has been extensive physics literature on the subject
[69], hence we will stick to a qualitative understanding
of its dynamics for our discussion. Notice that Taylor
expanding the above potentials at points Φj = {0, λ},
we see that each well is locally like a harmonic oscilla-
tor of harmonic frequency λjωj. The ground states of
each parameter are then approximately equal to a sym-
metric superposition of the ground states of each of the
wells. Thus the added potential induced by a cost func-
tion J (ˆΦ) can bias the eﬀective potential on the param-
eters and break this energetic degeneracy, a speciﬁc well
will then be favoured as having lower energy. Thus nat-
urally a metaheuristic like Quantum Dynamical Descent
or MoMGrad would nudge the parameter wavefunction
into the well which minimizes VS + J . Once the param-
eter wavefunction is concentrated into one of the wells,
assuming it approximates the ground state of the well,
its expectation value can be estimated with few mea-
surements (the determinant of the covariance should be
around ∼Q
j∈S(ωjλj)−1
2 due to the locally harmonic dy-
namics of the well). One can then round to the closest
value of each parameter on the lattice.
A near-term implementation of this approach might
favour using an analog ﬂux qubit for simplicity, but in
this case the poor readout capabilities will limit precision
and thus speed of execution of the optimization. Simu-
lating a similar system at a high-level of precision at the
logical level will allow for smoother state transitions, the
ability to resolve a continuum of momenta and parameter
values, and generally will allow for ﬁner-grained dynam-
ics by having the parameter query a continuum of possi-
bilities. This is thus the long-term favourable approach.
5.
Estimating Continuum Gradients with Single Qubits
Before we move on from this subsection, now that we
have treated how we can embed a discrete optimization
into continuous parameters, let us very brieﬂy mention
how we can use a low-dimensional discrete system such
as a qubit to perform apprximate MoMGrad (III C). This
is a straightforward application of the fairly general for-
malism developed in Section II. A reason this is worth
mentioning is because this single-qubit readout might be
relevant in the short-term for Noisy Intermediate Scale
Quantum devices [49], where the number of quantum de-
grees of freedom and level of control is limited. Large
qudits for the parameters should be more relevant in
the long-term post Quantum Error Correction and Fault-
Tolerance era of Quantum Computation.
We can use a single qubit for each parameter in MoM-
Grad, at the cost of having to perform more runs in order
to get an accurate gradient estimate. That is, we can use

32
a set of parameters for parametric controlled-unitaries
whose parameters are a mixture of classical oﬀset and a
qubit's standard basis operator, ˆΦ 7→Φ0 ˆI + ϵ ˆZ, where
ϵ > 0 is relatively small, i.e., Φ0 ≫ϵ. This is akin to
equation (11) from the background, for a qubit instead
of a qudit. Note a small enough ϵ is necessary for the dis-
crete gradient to estimate the continuous gradient. That
is, if we have some unitary parametrized with Φ0 ˆI + ϵ ˆZ,
then by deﬁnition of the discrete gradient (138), we have
∂ˆ
Z ˆU(Φ0 ˆI + ϵ ˆZ) = 1
2[ ˆU(Φ0 + ϵ) −ˆU(Φ0 −ϵ)].
(157)
In the case of ϵ ≪Φ0, the expression 1
ϵ ∂ˆ
Z ˆU(Φ0 ˆI + ϵ ˆZ)
will approach a notion of a continuous derivative.
As the goal of the quantum parameters is to sense the
phase kickback induced by Baqprop, one can use a de-
tector which has a very low-resolution readout. Using a
single qubit as the qudit from that equation (11), then we
get a very rough estimate of the kickback on the parame-
ters; this is equivalent to a single-qubit phase estimation;
from the nature of phase space we only get a single-bit
readout of the gradient. This then takes multiple runs so
that the continuous gradient can be estimated.
C.
Regularization & Variants
Regularization methods are useful tools for training
deep neural networks in the classical literature [17, 18].
The role of regularization is to ensure a smooth train-
ing process and avoid overﬁtting to a particular dataset.
Such techniques are thus indispensable when training
very large networks whose training dynamics can be
somewhat unwieldy, and ensures that the network is able
to generalize beyond the given dataset.
In this section we will mainly focus on techniques which
restrain the dynamics of the weights in a certain way,
to either avoid weight blowup, or avoid over-reliance on
certain connections in the network. hyper-parameter op-
timization, which is another important tool to avoid un-
der/overﬁtting, will be treated in Subsection IV D.
1.
Parameter/Weight Decay
A technique from classical machine learning which
allows one to dynamically bound the norm of the
weights/parameters is weight decay, or more generally
parameter decay.
The trick to weight decay is to add
a regularization term to the cost function, the canonical
choice being a simple quadratic penalty. For our quan-
tum weights, we can also add a quadratic potential,
J (ˆΦ) 7→J (ˆΦ) + λˆΦ2
(158)
where we use the notation ˆΦT ˆΦ ≡ˆΦ2. To see how this
inﬂuences the execution of Quantum Dynamical descent,
we can write
ˆUqdd =
Y
j
e−iγj ˆ
Π2e−iηjJ (ˆΦ)e−iηjλˆΦ2.
(159)
Note that the e−iηjJ (ˆΦ) and the e−iηjλˆΦ2 terms can be
executed simultaneously, partly due to the fact that these
operations on the parameters commute, but also because
the QFB eﬀective phase kick involves many steps not
involving every parameter. If some parameter were used
in every gate of the QFB algorithm, then the regularizing
potential could not be applied simultaneously. However,
since the QFB algorithm involves an exponentiated loss
operator which acts as the identity on the parameters,
then the regularizing potential on the parameters could
be applied at this stage.
That is, we could enact the
above unitary as
e−iηjL(ˆΦ)e−iηjλˆΦ2= ˆU( ˆΦ)†(e−iηjλˆΦ2 ⊗e−iηj ˆL) ˆU( ˆΦ).
(160)
Note that in the above ˆU( ˆΦ) is the feedforward oper-
ation, and the Hilbert space factorization is HΦ ⊗HC,
where HΦ and Hc are the parameter and computational
Hilbert spaces respectively. Alternatively, one could ap-
ply the regularizing potential phase shift for a given pa-
rameter at any other point in the QFB circuit where it
is not being used to implement a controlled operation.
As we have seen previously, both Quantum Dynami-
cal Descent and Momentum Measurement Gradient De-
scent have the parameters experiencing a force which is
induced by the cost function acting as a potential. In
the above case, adding a quadratic regularizing poten-
tial to each parameter register is eﬀectively like adding a
harmonic oscillator potential. For illustration, consider
performing quantum dynamical descent for a null cost
function, i.e., J (ˆΦ) = 0, then QDD becomes
ˆUqdd

J =0 =
Y
j
e−iγj ˆ
Π2e−iηjλˆΦ2.
(161)
For a certain set of hyper-parameters can be viewed as a
simulation of Trotterized evolution under a free Hamilto-
nian of the form ˆH ∼P
n(ˆΠ2
n + ωn ˆΦ2
n), which represents
a set of free (uncoupled) Harmonic oscillators. The cost
function J (ˆΦ) is responsible for the coupling between
the parameters during QDD. This allows the parameters
to entangle and dynamically inﬂuence one another.
2.
Meta-networked Interacting Swarm Optimization
An option for simultaneous parallelization and regular-
ization is to have multiple replicas, similar to the paral-
lelized minibatch method from IV A 3 above, which have
their parameters coupled to each other with an attractive
potential. Such a potential can be used to correlate the
dynamics of the replicas equilibrium point, while still al-
lowing for some degree of independent dynamics. We call

33
this approach Meta-networked Interacting Swarm Opti-
mization (MISO).
To precisely describe how to couple replicas, ﬁrst con-
sider a meta-network of replicas, which is a graph G =
{V, E}, where each vertex is a replica with parameters
ˆΦ[c], for c ∈V. The edges E of the graph G represent cou-
plings between replicas. Each edge's weight will represent
the coupling strength. The way this coupling will be in-
troduced into the parameter dynamics is via an added
potential.
Let ˆ¯Φ := (ˆΦ[c])c∈V be the operator-valued meta-vector
of all parameter vectors. The global added potential is
the sum of the coupling potentials,
V (ˆ¯Φ)=
X
{j,k}∈E
Vj,k(ˆΦ[j], ˆΦ[k]).
(162)
For example, we could choose each of these coupling po-
tentials of the form,
Vj,k(ˆΦ[j], ˆΦ[k]) = λjk (ˆΦ[j] −ˆΦ[k])T (ˆΦ[j] −ˆΦ[k])
= λjk
 ˆΦ2
[j] + ˆΦ2
[k] −2ˆΦ[j] · ˆΦ[k]

,
(163)
with all coupling scalars non-negative reals, λjk ∈R≥0,
∀{j, k} ∈E.
We see that each parameter in a given
replica is coupled to its corresponding parameters from
neighboring replicas, with locality of couplings deter-
mined by the graph of the replica network. We also see
that the ﬁrst two terms act as parameter decay terms to
keep the norm of the parameters contained. Note that
due to the fact that λjk ≥0, coupled parameters will
naturally want to correlate to minimize the third term,
which is the interaction term.
Depending on the topology of the meta-network, dif-
ferent joint dynamics will be induced on the set of pa-
rameters of the replicas.
The interesting advantage of
this approach is that it is highly adaptable to the given
interconnect capabilities of diﬀerent networks of quan-
tum processors; one can restrict the meta-network to be
tailored to the natural topology of the given implementa-
tion of the algorithm. We represent pictorially the meta-
network of replicas in Figure 13.
In the previous subsection IV A 3 on Coherently Ac-
cumulating Momentum Parallelization, diﬀerent replicas
were assigned to diﬀerent data points of a minibatch for
each iteration of the parameter optimization (i.e., each
momentum measurement or application of the kinetic
pulse). In this variant, we can consider assigning a diﬀer-
ent arrangement of minibatches D[j] := {M[j]
k }k to each
replica j ∈V. That is, we can consider each replica to
have eﬀectively a diﬀerent dataset, in cases where data is
scarce then one may simply shuﬄe the data points and
create new partitions for the diﬀerent replicas. For each
replica, we can then execute the minibatch accumula-
tion of momenta via the serialized or parallelized vari-
ants. In the parallelized variant as in subsection IV A 3,
each vertex of the meta-network would represent a pa-
rameter server node, which itself is connected to its sub-
replicas with which it executes CAMP. In a sense, these
Figure 13. Example of a graph G for meta-network of replicas
(right), with the weight of each edge {j, k} ∈E corresponding
to a coupling strength λjk, for couplings of the form (163).
The replicas' parameter registers are coupled one-to-one with
their corresponding parameter in coupled neighboring replicas
(left), all according to the same inter-replica coupling. Here
we give a simple neural network with synaptic weights as the
parameters which are coupled between replicas.
sub-replicas are used simply as ancillas to accumulate on
the parameter server node a phase shift equal to the cost
function of a minibatch in a parallelized fashion. We do
not count sub-replicas executing CAMP as part of the
meta-network, since the dynamics of CAMP are akin to
a single replica, that of the server.
Let us consider how to compile and execute this set of
transformations including the added rgularizing poten-
tial. Let us denote the cost function for the minibatch
M[j]
k assigned to the jth replica's kth parameter iteration
as
J [j]
k (ˆΦ[j]) ≡
1
|M[j]
k |
P
x∈B[j]
k Lx(ˆΦ),
(164)
where B[j]
k
is the index set of M[j]
k . We can write the
the global replica meta-network cost function for the kth
iteration as the sum of all the costs over the replicas in
the meta-network
Jk(ˆ¯Φ) =
X
j∈V
J [j]
k (ˆΦ[j]).
(165)
Consider the multi-iteration QDD unitary with Meta-
networked Interacting Swarm Optimization (MISO), for
an iteration index k ∈S. For now we assume uniformity
across replicas of the kicking and kinetic rates,
ˆUqdd.miso =
Y
k∈S
e−iγk ˆ¯
Π
2
e
−iηk

Jk(ˆ¯Φ)+V (ˆ¯Φ)

.
(166)
The kinetic terms can be applied in parallel across repli-
cas and parameters,
e−iγk ˆ¯
Π
2
=
O
j∈V
e−iγk ˆ
Π2
[j],
(167)
while the exponentials of the regularizing potential can be
executed during any part of the feedforward, phase kick,
and backpropagation operation, as long as a given pa-
rameter is not currently executing a controlled-operation

34
which only happens during the feedforward and uncom-
putation portions of QFB. This can be done in any or-
der since the phase shifts commute. As long as the ki-
netic term is not executed, there is freedom to choose
exactly how to compile the operation. A simple way is
sequentially adding the potential pulse before or after the
replica-parallelized QFB,
e
−iηk

Jk(ˆ¯Φ)+V (ˆ¯Φ)

=
 O
j∈V
e−iηkJ [j]
k (ˆΦ[j])e−iηk˜λ[j] ˆΦ2
[j]
 Y
{m,l}∈E
ei2ηkλlm ˆΦT
[l] ˆΦ[m],
(168)
where we denoted the coupling strength averaged over
all edges incident to a meta-network vertex as ˜λ[j] :=
P
k∈V λjk. Again, since all the above exponentials are
commuting, there is opportunity to combine the execu-
tion of all these terms in the potential in a more eﬃcient
manner than serially. Note that to execute a MoMGrad
optimization with MISO, one simply prepare a pointer
state of choice in all parameters of all replicas, as in (92).
Then, one applies the above MISO phase unitary from
(168), measures the momentum of all parameters and
updates them according to the regular MoMGrad update
rule from (117).
An option for the swarm approach is that one can have
multiple networks with the same architecture (hence the
name replica), but with diﬀerent hyper-parameters, i.e.,
diﬀerent initializations and/or kicking and kinetic rates
at diﬀerent iterations. This would mean a modiﬁcation
of the above formulas to having replica-speciﬁc rates, i.e.,
{γk, ηk} 7→{γ[j]
k , η[j]
k }, as well as replica-speciﬁc initial-
izations (mean and variance) for the weights. This can
allow a sort of eﬀective majority voting of where to go in
the parameter landscape, which may possibly kick repli-
cas with poor initializations out of a local well, but also
might perturb a replica performing well in terms of cost
optimization to get kicked oﬀof its trajectory to a low
cost function value. As this is a strategy which will in-
crease the training set error to possibly improve the test
set error, we consider it as a regularization technique.
As Quantum Dynamical Descent is eﬀectively a QAOA
approach to ﬁnding low energy states of a Hamiltonian,
we can see that MISO is eﬀectively like trying to ﬁnd
the ground state of a swarm of interacting particles. As-
suming uniform descent hyper-parameters, and consider-
ing full batch cost function, J (ˆ¯Φ) := P
k Jk(ˆ¯Φ), we can
write down this eﬀective Hamiltonian to be of the form
ˆ¯H = 1
2 ˆ¯Π
2
+ ω2
2 J (ˆ¯Φ) + ω2
2 V (ˆ¯Φ),
(169)
which resembles a lattice of oscillators with an added
non-linear potential proportional to J . Theoretically one
could expand J (ˆ¯Φ) about its minimum value to second
order and obtain a quadratic potential. The approximate
ground state would then be given by a Gaussian ground
state of the form (8). The important takeaway is that the
joint system of parameters is like a coupled network of
oscillators, with the intra-replica coupling induced by the
cost function and the inter-replica couplings due to the
meta-network's topology. There are many way to modify
the approach described above, in terms of how to manage
data, how to modify hyper-parameters, etc.. In the next
subsection IV D, we discuss how to leverage the quantum
phase backpropagation of errors and quantum dynamical
descent to optimize all these possible hyper-parameters
via quantum dynamical descent.
3.
Dropout
The method of dropout in classical machine learning
encompasses a set of techniques which add noise to the
training process in order to regularize the learning. The
addition of noise to the neural information processing ef-
fectively forces the network to learn to process informa-
tion in a redundant, robust manner. In a sense, adding
errors forces the neurons to not over-rely on a speciﬁc
neural pathway, and thus to split signals into multiple
pathways, thereby spreading the computation over neu-
ral elements in order to add noise resistance. Traditional
dropout consists of adding classical erasure noise to the
neural information processing, this consists of eﬀectively
blocking the path of the information ﬂowing forward
by stochastically dropping out certain neural elements.
Modern techniques for dropout also include Gaussian
multiplicative noise, or Gaussian additive noise [70] for
neural networks. In this section we focus on techniques
to use quantum registers as stochastic classical variables
which control whether certain subsets of parametric op-
erations are applied. Note that we will reuse much of the
machinery developed in this subsection in our subsection
on network architecture optimization via Quantum Meta-
Learning (section IV D 3), where instead of simply using
the quantum registers as a source of stochastic noise, we
can optimize over superpositions of network architectures
via a quantum meta-learning optimization loop.
As our parameters naturally have Gaussian noise in
both the gradient and parameter value due to our opti-
mization approach outlined in Section III using Gaussian
pointer state, the Gaussian multiplicative noise dropout
comes for free for our schemes. In a sense the Quantum
uncertainty of the wavefunction serves as natural regu-
larizing noise. For Gaussian additive noise dropout, re-
fer to Section V where we describe quantum parametric
circuits for neural networks.
In this section, the com-
putational registers are initialized in null-position qu-
dit or qumode eigenstates |0⟩. It would be straightfor-
ward to use computational registers which have some
added Gaussian noise to their position value, i.e., are
in a simulated squeezed state rather than a perfect posi-
tion eigenstate initially. Because these types of dropout
are straightforward to implement with our schemes, we
focus on operation dropout: stochastically removing cer-
tain subsets of parametric operations.

35
The goal of operation dropout is to probabilistically
create a blockage of information ﬂow in the feedforward
computational graph. Furthermore, another important
aspect of dropout is the ability to backpropagate errors
with knowledge of this erasure error. As our backprop-
agation approach relies on the ability to backpropagate
error signals through the quantum computational graph
via uncomputation after the feedforward operation and
phase kick, we will need to keep in memory the register
which controls the erasure. We use a quantum state's
computational basis statistics as the source of classical
stochasticity in this section for notational convenience,
but note that could equivalently replace these qubits with
classical random Bernoulli variables of equivalent statis-
tics.
Now, let us develop some formalism to characterize
how to leverage ancillary quantum registers in order to
stochastically control which architecture is used in the
quantum feedforward and Baqprop.
Whether it is a
quantum parametric circuit, as those discussed in Sec-
tion VI, or a neural network embedded into a set of quan-
tum parametric circuits, as discussed in Section V, we can
assume the parametric circuit ansatz can be written as a
layered circuit of unitaries, i.e.
ˆU(ˆΦ) =
L
Y
ℓ=1
ˆU (ℓ)(ˆΦ(ℓ)),
ˆU (ℓ)(ˆΦ(ℓ)) ≡
O
jℓ∈Iℓ
ˆUjℓ(ˆΦjℓ)
(170)
where ˆU (ℓ)(ˆΦ(ℓ)) is the multi-parameter unitary corre-
sponding to the ℓth layer, which can itself be composed
of multiple parametric unitaries { ˆUjℓ(ˆΦjℓ)}jℓ, and where
I = ∪L
ℓ=1Iℓis the partition of parameter indices for the
parameters of each layer.
Now, if we would like to parametrize whether a number
N of certain subsets of parametric unitaries are applied
or not, we need to ﬁrst index which unitaries are con-
trolled by the same variable. For this index, consider a
partition of the indices I = ∪N
j=0Aj, where Aj ⊂I ∀j.
For notational convenience, let us reserve the subset A0
as the set of unitaries over which we would not like to
be stochastically controlled, i.e., we want to implement
these with absolute certainty, the reason for this nota-
tion will be apparent below. To quantumly control the
application of these subsets of unitaries, we will need a
set of N ancillary qubits which index the architecture,
say we label these as Aj where the |1⟩Aj indicates we
are applying the unitaries in subset Aj. For notational
convenience, consider the following operator-valued func-
tion, which takes indices of operations from I and maps
them to operators on the architecture ancillas' Hilbert
space HA = NN
j=1 HAj; ˆC : I →B(HA),
ˆC(j) =
N
O
k=1
|1⟩⟨1|
1Ak (j)
Ak
(171)
where we denote 1Ak(j) as the indicator function for the
set Ak ⊂I, and |1⟩⟨1|0 = I. This operator can serve a
the control operator for a given index; essentially, given
an index of an operation, it is a projector onto |1⟩Ak
for the ancilla whose index corresponds to that of the
partition in which j belongs. Also note that the above
operator is a function of Pauli ˆZ's of the architecture
ancillas, hence it is only dependent on the vector of Paulis
ˆ
ZA = { ˆZAk}k.
We can consider the architecture index to be a
stochastically-determined hyper-parameter. We can then
modify our parametric unitary to become a hyper-
parametric unitary, which acts on both the Hilbert space
of architecture indices (used as controls) and the joint
computational and parameters' Hilbert spaces,
ˆ¯U(ˆΦ, ˆ
ZA) =
L
Y
ℓ=1
Y
jℓ∈Iℓ
ˆCA(jℓ) ⊗ˆUjℓ(ˆΦjℓ)
(172)
note this is essentially the same unitary as previously
(170), except now each unitary in I \ A0 is a controlled-
unitary, and the control qubit for each index j is that
which corresponds to the partition of inidices Ak such
that j ∈Ak.
Although the above operation may seem complex, the
circuit to execute the above may be compiled eﬃciently,
simply by adding a control to each operation. For exam-
ple, each parametric unitary (see VI A) is of the form
ˆUjℓ(ˆΦjℓ) =
X
Φjℓ
|Φjℓ⟩⟨Φjℓ| ⊗ˆUjℓ(Φjℓ)
(173)
now assuming each unitary is generated by a certain
Hamiltonian, i.e., ˆUjℓ(Φjℓ) = e−iΦjℓˆhjℓthen the above
becomes
ˆUjℓ(ˆΦjℓ) = e−iˆΦjℓ⊗ˆhjℓ,
(174)
which we see is an exponential with a generator ˆΦjℓ⊗
ˆhjℓ. In order to convert a certain parametric unitary of
index k ∈Aj to have an added qubit control register,
one simply has to exponentiate the modiﬁed generator
|1⟩⟨1|Aj ⊗ˆΦk ⊗ˆhk, i.e.
X
bj∈Z2
|bj⟩⟨bj|Aj ⊗ˆU bj
k (ˆΦ) = e
−i|1⟩⟨1|Aj ⊗ˆΦk⊗ˆhk
(175)
which can be synthesized into a product of (vk + 2)-local
exponentials of Paulis, where vk is the locality of ˆhk.
Now that we have covered how to modify the parame-
teric circuit ansatz to include quantum controls, we can
now describe how to modify the Quantum Feedforward
and Baqprop (QFB) to include dropout.
Suppose we
would like to perform the QFB for a certain iteration
where we have the loss operator ˆLj, the usual QFB op-
eration would consist of applying
ˆU †(ˆΦ)e−iη ˆLj ˆU(ˆΦ)
(176)

36
onto a computational register state |ξj⟩C, the eﬀective
phase on the parameters (see sec. III A 1) would then be
Lj(ˆΦ) = ⟨ξj| ˆU †(ˆΦ)ˆLj ˆU(ˆΦ) |ξj⟩C .
(177)
Now to modify QFB to include dropout, we simply mod-
ify the regular feedforward parameteric unitary to be the
controlled unitary from (172).
ˆ¯U †(ˆΦ, ˆ
ZA)e−iη ˆLj ˆ¯U(ˆΦ, ˆ
ZA),
(178)
and we act this hyper-parametric unitary on the same
computational registers' state |ξj⟩C and an initial state
|α0⟩A of our architecture qubits:
|α0⟩A =
N
O
k=1
(sin(θk) |0⟩Ak + cos(θk) |1⟩Ak)
(179)
where the θ = {θk}N
k=1 are hyper-parameters which will
control the probability of dropout; the probability of ap-
plying a set of operations of index Ak will be given by
cos2(θk). Tracing out the computational and architecture
registers, the resulting eﬀective phase on the parameters
will be
Lj(ˆΦ) = ⟨ξj|⟨α0| ˆ¯U †(ˆΦ, ˆ
ZA)ˆLj ˆ¯U(ˆΦ, ˆ
ZA) |ξj⟩C|α0⟩A .
(180)
Thus, we get the average cost function phase kick, aver-
aged over the possible architectures.
To see this more explicitly, we can expand the above
expression, to do so it will be convenient to deﬁne some
more notation. Let us begin with
λa ≡
N
Y
k=1
(sin(θk))1−ak(cos(θk))ak,
(181)
hence
the
state
from
(179)
could
be
written
as
|α0⟩= P
a∈ZN
2 λa |a⟩A.
Additionally, let ˆ¯Ua(ˆΦ) =
⟨a| ˆ¯U(ˆΦ, ˆ
ZA) |a⟩A be the unitary corresponding to the
parametric circuit of the following architecture
ˆ¯Ua(ˆΦ) ≡
L
Y
ℓ=1
Y
jℓ∈Iℓ∩Za
ˆU
ajℓ
jℓ(ˆΦjℓ).
(182)
where Za = {Ak : 0 ≤k ≤N, ak = 1}. This corresponds
to acting all unitaries of index j for which j ∈Ak for
some k such that ak is nonzero. Now, we can use the
above to expand equation (180)
Lj(ˆΦ) =
X
a∈ZN
2
λa ⟨ξj| ˆ¯U †
a(ˆΦ)ˆLj ˆ¯Ua(ˆΦ) |ξj⟩C ,
(183)
and we see that we get, on average, the expectation over
architectures of the eﬀective phase kick.
We can then
use tools from Section III to leverage this eﬀective phase
signal for optimization of the parameters via MoMGrad
or QDD.
Note that, just like the regular eﬀective phase kicking
for quantum data, the registers other than the parame-
ters must be reinitialized (refreshed) after each QFB run,
in order to get the averaged behaviour. If we were to keep
the same quantum ancillas indexing the architecture for
multiple runs of QDD, then the parameters would en-
tangle with the superposition of architectures, such as to
optimize the cost function for each architecture in each
individual branch of the superposition rather than opti-
mizing for the mixture of architectures. We harness this
very property of training diﬀerent network architectures
in superposition for meta-learning and architecture opti-
mization in section IV D 3.
As dropout is integral to training classical neural net-
works, the above technique is useful to have for training
classical neural networks on a quantum computer. This
"operation dropout" may also be useful for robust para-
metric circuit learning in certain settings. Since dropout
will emulate faulty execution of gates, this would force
the parametric circuit to not rely too much on a single
gate for a large change to the state, each parametric op-
eration would stay not too far from the identity; each
continuously parametrized gate would then have a small
angle, hence keeping ∥Φ∥2 small.
This becomes eﬀec-
tively similar to the parameter decay described in sec-
tion IV C 1. In general one would expect dropout will
have other eﬀects on the parameters that simple weight
decay alone cannot emulate.
For general quantum parametric circuits, one could
consider adding additional parametric unitaries which
stochastically drop in, potentially to emulate various
forms of noise. For example, we could consider adding
controlled-X and controlled-Z as additional operations
in a given parametric circuit ansatz. Using two qubits
for controls, one could then apply stochastically apply X
and/or Z at each site using techniques from above. One
could thus emulate a depolarizing channel for example.
Optionally, one could stochastically swap out or swap
in computational registers, again controlled by architec-
ture binary hyper-parameters.
This would simulate a
form of erasure noise. Generally, one could use this tech-
nique to add a great variety of types of noise. There are
many ways to add noise to a system, but dropout is used
to regularize the training networks. It is not yet clear
whether quantum parametric circuits need dropout for
better training, nor what kind of noise map would be
best, at this stage in the development of the ﬁeld.
D.
Quantum Meta-Learning
1.
Overview
In practical machine learning scenarios, it is often
better to rapidly ﬁnd a local minimum rather than a
global optimum (which has a cost of longer runtime).
This is where the low-depth limit becomes interesting.
Rather than having many pulses in order to minimize

37
the Suzuki-Trotter error approximating the adiabatic
path, it will often be better to have a higher phase
kicking and kinetic rate, and to variationally optimize
these hyper-parameters. This variational optimization is
done by training the model with a certain set of hyper-
parameters, and by checking the value of the cost func-
tion with respect to a subset of data called the test set.
Oftentimes this is done via trial and error and careful
hand-tuning, but there exists ways to automate this pro-
cess. Automation of this hyper-parameter optimization
is called meta-learning [71].
Instead of using a classical optimizer which would in-
volve ﬁnite-diﬀerence optimization, we can use the Quan-
tum Dynamical Descent method at the hyper-parameter
level. Hyper-parameter optimization methods commonly
used in classical deep learning, namely, grid search, ran-
dom search, manual search, or even Bayesian optimiza-
tion, come with multiple training cycles for optimization,
often scaling exponentially in overhead with the number
of hyper-parameters [72]. This problem of meta-training,
training the hyper-parameters, is what these techniques
address. Meta-learning has been used to boost the learn-
ing speed (decrease training set error in less iterations)
[73, 74], has allowed for better test set error and general-
ization error, and has been used to learn how to rapidly
adapt a network trained for a given task to perform a
new one, an approach known as transfer learning [75].
A recent approach to meta-learning has been to use
gradient descent on the hyper-parameters, often with an
additional neural network relating the choices of hyper-
parameters between diﬀerent iterations [74]. The opti-
mization of this hyper-parameter network is done via a
backpropagation of errors up the computational graph,
which traces back the inﬂuence of the hyper-parameters
on the output loss function.
The following techniques we will describe below are
analogous in a sense to this hyper-parameter gradient
descent. Each hyper-parameter inﬂuences either the ini-
tialization, the descent rates, or even the architecture of
the network. In the rest of this section we will explore
how to move from what we hitherto have considered to
be classical (ﬁxed) hyper-parameters, to quantum (con-
tinuous or discrete) parameters. By considering how to
perform the feedforward and backpropagation with quan-
tum hyper-parameters, we will then be able to perform
meta-Baqprop, once again using the quantum backpropa-
gation of phases principle. We will then be able to apply
either quantum dynamical descent or momentum mea-
surement gradient descent on the hyper-parameters, and
do so in an eﬃcient manner, as Baqprop does not re-
quire knowledge of analytic derivatives of each part of
the computation.
Finally, note that the Quantum Meta-Learning ap-
proach relies heavily on the possibility of entanglement
between the quantum hyper-parameters and the pa-
rameters/compute registers.
Given a superposition of
hyper-parameters, one can consider each branch of the
wavefunction of these hyper-parameters. As the hyper-
parameters inﬂuence the training of the network via
Quantum Dynamical Descent, each value of the joint
set of hyper-parameters will lead to a diﬀerent trained
network. Since the whole training process is kept quan-
tum coherent, the result is an entangled superposition of
hyper-parameters and their corresponding fully trained
networks.
At this point, applying a cost function ex-
ponential of choice for the network tags the diﬀerent
branches of the wavefunction with relative phases, and
unitarily uncomputing the training allows for a backprop-
agation of errors all the way up to the hyperparameters.
Thereby allowing for their optimization via a Meta-QDD
or Meta-MoMGrad approach.
2.
Quantum hyper-parameter Descent
In previous discussions of Quantum Dynamical De-
scent and Momentum Measurement Gradient Descent,
given a ﬁxed network architecture ansatz, there were sets
of classical hyper-parameters for the preparation of the
parameter's pointer states, denoted Θ = {Φ0, Π0, Σ0},
and some for the choice of kicking and kinetic rates for
each iteration, which were denoted Ξ = {γ, η}.
We
can then consider a parameter pointer state prepara-
tion unitary as a classically parametrized unitary ˆUp(Θ),
and similarly, the entire Quantum Dynamical Descent
unitary, as featured in equation (66), can be seen as a
unitary parametrized by classical hyper-parameters Ξ,
which acts both on computational registers and the pa-
rameter registers, ˆUqdd(Ξ). The key to our meta-learning
problem will be to view the combination of the prepara-
tion and quantum dynamical descent unitaries as hyper-
parametric circuits to be optimized.
The task of meta-learning usually involves optimizing
the initialization and execution of the training process
in order to minimize some cost function which assesses
either generalization or optimization performance. This
loss function can be the same as the training loss/cost
function, using the training data, or it can be some diﬀer-
ent cost function than that of the training, either through
the use of the same loss applied to diﬀerent data, or
some diﬀerent loss function altogether. In cases where
the learning comes from data, either classical or quan-
tum, the subset of data reserved for the hyper-parameter
training is called the test set, while the subset of data
reserved for the training of the parameters is called the
training set or development set (dev set). In any case,
there is a cost function which we want to optimize, whose
eﬀective phase we will call Jm subject to variations in the
hyper-parameter vectors {Θ, Ξ}.
Using the same approach as our parameter optimiza-
tion for regular learning, we can quantize the hyper-
parameters {Θ, Ξ} 7→{ ˆΘ, ˆΞ}, and using either Quantum
Dynamical Descent or Momentum Measurement Gradi-
ent Descent for quantum-enhanced optimization of these
hyper-parameters. We will refer to these approaches as
Meta-QDD and Meta-MoMGrad, respectively.
We re-

38
gard the meta-feedforward hyper-parametric unitary to
be
ˆUmeta( ˆΘ, ˆΞ) ≡ˆUqdd(ˆΞ) ˆUp( ˆΘ),
(184)
i.e., the parameter state preparation unitary followed by
the Quantum Dynamical Descent unitary.
Before we proceed with how to leverage such a uni-
tary, let us examine how exactly this upgraded quantum-
hyperparametric unitary can be synthesized into elemen-
tary gates. Note the Quantum Dynamical descent uni-
tary is now of the form
ˆUqdd(ˆΞ) =
Y
j
e−iˆγj⊗ˆ
Π2e−iˆηj⊗J (ˆΦ),
(185)
where the exponentials are now quantum-controlled. The
synthesis of the kinetic exponential is straightforward,
taking O(log3 d) 3-local exponentials of qubit Paulis to
enact, where d is the qudit dimension of our parameter
and hyper-parameter registers. For the hyper-parametric
eﬀective phase, one can apply the regular feedforward
unitary, but the exponential of the loss function now be-
ing quantum-parametric, i.e., apply
e−iˆηj⊗ˆLj(ˆΦ) = ˆU †(ˆΦ)e−iˆηj⊗ˆLj ˆU(ˆΦ)
(186)
and the expectation of the above for an input com-
putational state will give the quantum-parametric ef-
fective phase.
How to synthesize this exponential of
the loss function will vary.
In general for a compila-
tion of e−iˆηj⊗ˆLj down to Cliﬀord gates and Z-rotations
gates of the form eiβη ˆ
Z for some constants β, we can
then modify the classically parametric rotations to be
quantum-hyper-parametric eiβη ˆ
Z 7→eiβˆη⊗ˆ
Z which them-
selves can each be broken down into O(log d) exponen-
tials.
For more details on parametric circuit synthe-
sis see section VI A 1.
If the loss function is based
on η-parametric exponential-swap, as we will treat in
VI, we provide compilation of these into Fredkin and
Z-rotation, hence can be quantum-hyperparametrized
straightforwardly.
Finally, for the preparation uni-
tary, upgrading the hyper-parameters to quantum is
straightforward, since for Gaussian state preparation we
can have quantum-parametrized simulated continuous-
variable displacement and squeezing operators to quan-
tum parametrize the ﬁrst and second moments of the
Gaussian wavefunctions.
Now that we have covered how to synthesize the hyper-
parametric unitary, we can now proceed to leveraging
this unitary to perform the Quantum Feedforward and
Phase Kick Backpropagation procedure at the meta-level.
The cost function we are trying to optimize can be the
loss over some minibatch which corresponds to the test
data. Let ˆU(ˆΦ) be the parametric unitary acting on the
compute and parameter registers, the exponential of the
loss function for the meta-learning is the exponential loss
e−iµJm(ˆΦ) =
Y
j∈Bt
e−i˜µL(ˆΦ)
(187)
where Bt is the test set batch index and µ is the phase
kicking rate, ˜µ ≡µ/|Bt| is the same rate divided by the
test batch size.
Recall that to enact each of the loss
function eﬀective phase shifts exponentials, this entails
applying the QFB procedure for the parameter circuit
ˆU(ˆΦ), i.e.,
e−i˜µˆLj(ˆΦ) = ˆU †(ˆΦ)e−i˜µˆLj ˆU(ˆΦ)
(188)
and the expectation value of the above when the compu-
tational register is traced out is the eﬀective phase, as in
equation (53), hence to enact (187), multiple applications
of (188) must be applied, using multiple ancillas that are
swapped in and out of the compute register in the gen-
eral case of quantum data training. In the case of train-
ing classical neural networks on a quantum computer, as
described in section V, since the compute registers are
in an eigenstate of the QFB circuit, we can simply con-
catenate the phase kicks without the need for swapout,
simply need to ﬂip the input registers to the right input
after each round, which is done unitarily. For quantum
data training, if the phase kicking rates are kept small
during training, even if the compute register ancillas are
tossed away, as was shown in section III, the dynamics
of the weights are eﬀectively unitary to ﬁrst order in η.
Now, we have deﬁned the hyper-parametric unitary
and the exponential loss function to be applied, we can
consider applying the Meta-QFB (Quantum Feedforward
and Phase Kick Backpropagation) procedure, for an it-
eration of such a phase kick, one must apply
ˆU †
meta( ˆΘ, ˆΞ)e−iµJm(ˆΦ) ˆUmeta( ˆΘ, ˆΞ)
(189)
we can consider the eﬀective phase function induced by
the kickback from this meta-QFB. Let the compute and
parameters' initial state be labelled as |χ0⟩CP , then the
eﬀective phase of the meta-QFB on the hyper-parameters
can be labelled as
e−iµK( ˆ
Θ,ˆΞ)
≈⟨χ0| ˆU †
meta( ˆΘ, ˆΞ)e−iµJm(ˆΦ) ˆUmeta( ˆΘ, ˆΞ) |χ0⟩CP
(190)
which is true to ﬁrst order in µ. Now, we have reduced
the problem of hyper-parameter optimization to that of
optimizing an eﬀective exponential phase, as was the
case before for the base case of QDD and MoMGrad.
It is then straightforward to extend previous techniques
to hyper-parameter optimization.
First, for Quantum
Dynamical descent, suppose we have a set of prepara-
tion hyper-hyper-parameters Ω, i.e., classical parameters
which control how the initial quantum pointer states of
the quantum hyper-parameter are initialized, in a sense
the hyper-parameter analogue of Θ.
Let ˆUhp(Ω) be
the hyper-parameter state preparation unitary. Let Υ
act as the classical hyper-hyper-parameters representing
the meta-QDD or meta-MoMGrad kicking and kinetic
rates, i.e., the hyper-hyper-parameters Υ = {µ, ν} are

39
analogues of the hyper-parameters Ξ = {η, γ} for the
meta-optimization. The Meta-QDD algorithm, pictured
in ﬁgure 14, can be summarized as applying the hyper-
parameter preparation unitary, followed by the sequence
ˆUm-qdd =
Y
j∈Bt
ˆ
F †
he−iνj(ˆΩ2+ˆΞ2) ˆ
Fhe−iµjK( ˆ
Θ,ˆΞ)
(191)
where the ˆ
Fh is the component-wise Quantum Fourier
transform for all hyper-parameter registers.
For meta-MoMGrad, similarly, we can begin by prepar-
ing the quantum pointer states of the hyper-parameters,
using a parametric unitary which itself is dependent on
preparation hyper-hyper-parameters Ω, i.e., ˆUhp(Ω), fol-
lowing this we can apply the meta-QFB circuit from
equation (190) in order to apply the eﬀective phase kick
e−iµK( ˆ
Θ,ˆΞ). To complete Meta-MoMGrad, we can then
apply the component-wise Fourier transform ˆ
Fh on the
hyper-parameter registers, and then measure these regis-
ters in their computational bases. From this phase kick,
the shift in expectation value will be proportional to the
negative gradient of the eﬀective phase, we can see this
by looking at the Heisenberg picture,
Ad[eiµK( ˆ
Θ,ˆΞ)]( ˆ
F † ˆΘ ˆ
F )
= ˆ
F † ˆΘ ˆ
F −µ∇ˆ
ΘK( ˆΘ, ˆΞ) + O(µ2)
Ad[eiµK( ˆ
Θ,ˆΞ)]( ˆ
F †ˆΞ ˆ
F )
= ˆ
F †ˆΞ ˆ
F −µ∇ˆΞK( ˆΘ, ˆΞ) + O(µ2)
(192)
the computational basis hyper-parameter observables, af-
ter an Fourier transform, is shifted by the negative gra-
dient multiplied by the hyper-parameter phase kicking
rate.
Similar to MoMGrad for the regular parameters
(see (101), (102)), one can then update the prepara-
tion hyper-parameters for the next iteration, i.e., update
the initial expectation value of position and momentum,
which are hyper-hyper-parameters in the vector Ω, akin
to the σ, Φ0, and Π0 but for the hyper-parameters; the
ﬁrst and second moments of the pointer states. The rate
at which the mean hyper-parameter value is updated
can be multiplied by some constant ν, akin to (102)
but with ν replacing γ. This hyper-hyper-parameter ν
can be considered the eﬀective kinetic rate for the Meta-
MoMGrad. We represent an iteration of Meta-MoMGrad
in Figure 14.
Finally, note that the hyper-hyper-parameters {Υ, Ω}
remain to be optimized. Theoretically, just as we have
shown above that one can optimize the hyper-parameters
via MoMGrad/QDD if the parameters are being opti-
mized by QDD, we could consider performing a quan-
tum parameter descent on the hyper-hyper-parameters.
To do so, one could consider quantizing the hyper-hyper-
parameters {Υ, Ω} 7→{ ˆΥ, ˆΩ}, and applying a meta-
meta-optimization on these using MoMGrad or Quantum
Dynamical Descent, with Meta-QDD taking the role of
QDD. In a sense, QDD is self-concatenable to as many
Figure 14. Examples of the ﬁrst iteration of both optimization
strategies for quantum-enhanced hyper-parameter optimiza-
tion via Quantum Meta-Learning (QMetaL). Represented in
(a) is the Meta-QDD protocol, while in (b) is Meta-MoMGrad
protocol. Note that in the above, H2-P, H-P, and P are de-
note the hyper-hyper-parameters, the hyper-parameters, and
the regular parameters, respectively. C is the compute reg-
ister, while D.D and T.D denote the development (training)
data, and the test data, respectively. The process begins with
the preparation of the hyper-parameter pointer state using a
unitary ˆUhp(Ω), the meta-feedforward is then applied (eq.
(184)), the phase kick according to the test set error is then
applied (see eq.
(187)), and the meta-feedforward is then
uncompute. Finally, in the case of QDD, a kinetic pulse is
applied on the hyperparameters, whereas for MoMGrad the
gradient of the hyper-parameters is measured and the hyper-
hyper-parameters are updated for the next meta-iteration.
meta-levels of optimization as is desired.
Practically,
each additional level adds a nested QFB loop of opti-
mization, which grows the overhead of execution expo-
nentially. Additionally, the number of hyper-parameters
increases with the number of meta-optimizations, since
the parameter preparation hyper-parametric unitary has
multiple hyper-parameters per parameter.
For meta-
levels of concatenation to be useful (in the sense of achiev-
ing a lower expectation value of the cost function of
choice), one would need to consider a choice of hyper-
parameters which reduces the ratio of hyper-parameters
per parameter for each level of meta-optimization. Per-
haps one could take inspiration from classical machine
learning techniques [74] , where a recurrent neural net-
work is used to relate the diﬀerent rates of descent at
subsequent iterations, thus providing an educated ansatz
for how these should relate to each other, and thus re-
ducing the number of unique degrees of freedom in the
hyper-parameters. To incorporate such a technique into

40
QDD would require adding a hyper-hyper-parametric cir-
cuit/neural network to relate the hyper-parameters be-
tween iterations, which would require a modiﬁcation of
the QDD approach, we leave this for future work.
3.
Network Architecture Optimization
Another application of the Quantum Meta-Learning
principle is for Quantum Network Architecture Opti-
mization. In some instances, one may want to optimize
over various network architectures in order to improve
performance, e.g., one may optimize whether a certain
set of parametric circuit elements should be applied, or
optimize over a space of possible neural network connec-
tomes (topology of connections). This problem can be
seen as a meta-learning problem, as the goal is to pick
the network architecture which performs best once each
network is trained. As such, the optimization must be
done over a space of trained networks, and this space
of architectures is generally discretely parametrized. To
enact this optimization, we can adapt techniques of quan-
tum discrete parametric optimization from section IV B,
and combine it with some of the machinery from our
treatment of dropout IV C 3, along with the principles of
Meta-QDD or Meta-MoMGrad which were just discussed
above.
The key to network architecture optimization will be
to have ancillary quantum registers to index the architec-
ture. Luckily, we have already developed a formalism for
this in section IV C 3, as such, we will use the same no-
tation in this section. Recall our general decomposition
of the parametric unitary from (170),
ˆU(ˆΦ) =
L
Y
ℓ=1
ˆU (ℓ)(ˆΦ(ℓ)),
ˆU (ℓ)(ˆΦ(ℓ)) ≡
O
jℓ∈Iℓ
ˆUjℓ(ˆΦjℓ).
(193)
We can add a set of N control qubits ancillas (of Hilbert
space HA), which will each control whether a certain sub-
set of parametric unitaries is applied. These qubtits can
be seen as hyper-parameters, and as such we can con-
struct the hyper-parametric unitary (same as eq. (172))
of the form
ˆ¯U(ˆΦ, ˆ
ZA) =
L
Y
ℓ=1
Y
jℓ∈Iℓ
ˆC(jℓ) ⊗ˆUjℓ(ˆΦjℓ)
(194)
where I = ∪N
j=0Aj is the partition of indices which
groups operations for which we wish to share the same
control parameter (e.g. multiple parametric operations
of a neuron). The subset of indices A0 corresponds to
the set of indices of unitaries over which we would not
like to optimize. The operator ˆC(j) is deﬁned in equa-
tion (171), it is simply a way to index which control qubit
each unitaries is assigned. For further details on how to
compile this unitary refer to section IV C 3.
Now, we have outlined how to convert a given para-
metric circuit to a hyper-parametric circuit with architec-
ture index qubits, we can simply apply techniques from
the Meta-MoMGrad/Meta-QDD from subsection IV D 2,
combined with the adaptations of MoMGrad/QDD for
discrete optimization from section IV B. The key is to re-
place the parametric unitary ˆU(ˆΦ) from (193), with the
architecture-hyper-parametric unitary
ˆ¯U(ˆΦ, ˆ
ZA) from
(194).
For architecture Meta-Learning MoMGrad, we can
start in a pointer state of the architecture hyper-
parameter registers as in (144)
|α0⟩A =
N
O
k=1
(cos(θk) |0⟩Ak + i sin(θk) |1⟩Ak)
(195)
and a pointer state of choice for the regular parame-
ters |Ψ0⟩(see sec. III C). Onto this joint pointer state
of choice, we can then apply the modiﬁed feedforward
hyper-parametric unitary from ˆ¯U(ˆΦ, ˆ
ZA) (172), then the
usual loss function exponential, and then uncompute the
feedforward in order to complete the eﬀective hyper-
parametric phase kick unitary; e.g.
e−iη ˆLj(ˆΦ, ˆ
ZA) = ˆ¯U †(ˆΦ, ˆ
ZA)e−iη ˆLj ˆ¯U(ˆΦ, ˆ
ZA)
(196)
and by batching multiple kicks like the above into a mini-
batch Bk, we can enact an eﬀective phase kick on the joint
system of hyper-parameters and parameters,
e−iηkJ (ˆΦ, ˆ
ZA) =
Y
j∈Bk
e−i¯ηkLj(ˆΦ, ˆ
ZA).
(197)
This exponential eﬀective cost function can then be used
for a minibatched architecture-dependent Quantum Dy-
namical Descent, by interlacing some kinetic pulses on
the parameters just as in regular QDD,
ˆUaqdd( ˆ
ZA) =
Y
k∈B
e−iγk ˆ
Π2e−iηkJ (ˆΦ, ˆ
ZA).
(198)
Note that as opposed to our method in dropout (sec.
IV C 3), in this meta-learning approach the state for the
architecture qubits |α0⟩is kept in quantum memory be-
tween QFB runs and for multiple QDD iterations rather
than being reinitialized every run. Now, similar to (190)
and (189), one can perform a meta-QFB, using ˆUAQDD
as the meta-feedforward;
ˆU †
aqdd( ˆ
ZA)e−iµJm(ˆΦ, ˆ
ZA) ˆUaqdd( ˆ
ZA)
(199)
where e−iµJm(ˆΦ, ˆ
ZA) is a cost function hyper-parametric
phase kick for the test set of the data.
We can let
e−iµK( ˆ
ZA) be the the eﬀective phase induced on the ar-
chitecture hyper-parameters by the operation in (199).
To optimize the architecture hyper-parameters, we can
then either apply a discrete Meta-QDD,
Y
j
e−iνj ˆ
XAe−iηjK( ˆ
ZA)
(200)

41
where the hyper-hyper-parameters will need to be op-
timized. One option being combining this architecture
meta-optimization and the regular meta-learning from
the previous subsection into one meta-optimization loop.
We leave this as exercise to the reader.
Finally,
another option is to perform a discrete
Meta-MoMGrad by measuring ⟨ˆ
XA⟩after phase kicks
e−iηjK( ˆ
ZA) and updating the angles θj according to the
estimated gradient as prescribed in IV B. Another option
which might be beneﬁcial in this case would be to use
continuum-embedding for the discrete parameters, since
the gradient estimation can be much more ﬁne-grained.
V.
QUANTUM NEURAL NETWORK
LEARNING
In this section, we will elaborate upon the use of the
ideas presented in the previous section for the purpose
of quantumly training deep neural networks on a quan-
tum computer, to solve machine learning problems in-
volving classical data. Here we will present a quantum
neural network architecture which encodes classical neu-
ral networks as quantum parametric circuits, along with
an in-depth analysis of the phase kick backpropagation
procedure from the previous section, and how the error
signals backpropagate through the quantum neural net-
work.
A.
Quantum-Coherent Neural Networks
In this subsection we show how to encode a classical
feedforward neural network into a quantum computa-
tion and how to leverage the Quantum Feedforward and
Baqprop as well as optimization techniques introduced
in Sections III and IV for the training of such a network.
1.
Classical-to-Quantum Computational Embedding
A central principle employed in this section is the
ability to encode a classical computation into a quan-
tum computation [76].
In general, for an n-bit input,
x ∈Zn
2, and a computable function from n bits to m
bits, f : Zn
2 →Zm
2 , we can embed the classical compu-
tation as a unitary quantum computation ˆUf : Ha ⊗Hb
acting on n + m qubits [55]. This unitary takes compu-
tational basis state equivalent of the input, |x⟩, an maps
it as follows:
ˆUf |x⟩|0⟩= |x⟩|f(x)⟩.
(201)
Thus this quantum-converted classical function maps
computational basis states to computational basis states.
Note that, trivially by the linearity of quantum operators,
superpositions of computational basis states get mapped
to entangled superpositons between the possible inputs
and their corresponding standard basis outputs,
ˆUf(P
j ψj |xj⟩) |0⟩= P
j ψj |xj⟩|f(xj)⟩.
(202)
Of course, since the evaluation is unitary, the above com-
putation is fully reversible:
ˆU †
f
P
j ψj |xj⟩|f(xj)⟩

= (P
j ψj |xj⟩) |0⟩.
(203)
Notice that for such functions the probability ampli-
tudes are unaﬀected during the evaluation.
That is,
each branch of the wavefunction labelled by the xj's
evolves independently of the others. This property will
be harnessed during the computation and uncomputa-
tion stages of the Quantum Feedforward and Backwards
Quantum Propagation of Phase errors (QFB). That is,
we use the ability to query classical functions in super-
position in order to tag the output with relative phase
shifts, and follow this with by uncomputation. The com-
bination of all three of these steps causes appropriate
momentum kicks for the parameters which can be lever-
aged for optimization using techniques from Sections III
and IV.
Simply by the nature of the embedding of a classi-
cal computation into a quantum computation, by the re-
quirement of reversibility, we are forced to store the com-
putational graph of the classical computation in quan-
tum memory. For a Directed Acyclic Graph represent-
ing the ﬂow of classical variables being transformed by
a composing multivariate functions, such as is the case
for neural networks, this so-called computational graph
[77] then has to be embedded into an entangled set of
quantum registers which hold the history of the compu-
tation. The encoding of computation into multiple quan-
tum registers can be seen, in a sense, as embedding the
classical computational graph in quantum memory, it is
then natural that one can backpropagate a phase error
signal through the computational graph via uncomputa-
tion, which we know carries gradient information. This
generalized backpropagation through a general compu-
tational graph is called Automatic Diﬀerentiation (AD),
the specialization of AD to Neural Networks is what is
considered to be the error backpropagation algorithm. In
subsection V B we analyse in-depth how the phase signal
is carried through during the uncomputation, and how
one can rederive the classical neural network backprop-
agation principle from it.
Although we do not explic-
itly do so, this analysis could then easily be extendable
to a general computational graph, thereby providing a
demonstration of emergence of automatic diﬀerentiation
through quantum phase backpropagation in a general set-
ting.
Although recent progress has been made to perform
common classical operations eﬃciently on a quantum
computer [76], in general, synthesizing quantum circuits
for quantum-embedded classical computations may not
always be eﬃcient.
On the other hand, our focus is
on training neural networks, which only require certain

42
types of operations, namely multiplication, addition, and
the evaluation of activation functions for continuous val-
ues. In this section we will thus cover how to addition
and multiplication using machinery introduced in the
background section II A. Later in this section (see V C),
we cover possible implementations of activation functions
commonly used in classical machine learning.
2.
Classical Data Phase Kicking
First, let us begin by detailing how exactly to enact
the phase kicking according to a classical loss function.
For purposes of demonstrating the key concepts, we will
consider the employment of the QFB algorithm for an
classical supervised learning, although it could also be
used in other contexts. In classical supervised learning,
the goal is to build a model for a function f : x 7→y
based on training data {(xj, yj)}j.
The model con-
sists of a parametrized ansatz f(Φ, x) with parameters
Φ. Every set of parameters gives a prediction denoted
˜y = f(Φ, x). As above, the Hilbert space for the pa-
rameters will be denoted HΦ. The Hilbert space for the
computation requires registers for the inputs and the pre-
diction: HC = Hx⊗H˜y. Note that in the case of training
with a superposition of data, one would also requires a
set of registers for the output, Hy. For the moment we
will only consider using a single data point at a time, so
each yi will only enter the loss functions as a classical
parameter, although the extension to encoding the out-
puts in a quantum register is straightforward, depending
on the loss function.
For now, consider a single input-output pair (x, y).
The parametrized algorithm for classical training is a uni-
tary, ˆUf( ˆΦ), that computes f(Φ, x), i.e.,
ˆUf( ˆΦ) : |Φ, x, 0⟩7→|Φ, x, f(Φ, x)⟩.
(204)
Later in this section, we will be constructing explicit
circuits (quantum-coherent neural networks) that imple-
ment ˆUf( ˆΦ). For now, we will write this unitary some-
what abstractly as
ˆUf( ˆΦ) =
X
Φ,x
|Φ⟩⟨Φ| ⊗|x⟩⟨x| ⊗e−if(Φ,x) ˆp˜
y
= e−if( ˆΦ,ˆx)· ˆp˜
y,
(205)
where ˆp˜y is the generator of shifts in the prediction reg-
ister. Our notation will be suggestive of continuous reg-
isters, although this can be achieved for discrete registers
as well.
Now we apply a loss function which compares the out-
put to the prediction:
e−iηL(ˆ˜y,y).
(206)
For example, the loss function could be
L(ˆ˜y, y) = ∥ˆ˜y −y∥2
2,
(207)
note that this is still an operator which acts on H˜y. The
loss exponential of such a mean-squared error loss is eﬃ-
ciently compilable into a tensor product of second-order
phase exponentials of each register.
In principle, this
loss function could be any classical computable function
which maps the output to the set of reals.
After uncomputing with ˆUf( ˆΦ)†, the entire QFB cir-
cuit is
ˆUQFB = eif( ˆΦ,ˆx)· ˆp˜
ye−iηL(ˆ˜y,y)e−if( ˆΦ,ˆx)· ˆp˜
y
= e−iηL(ˆ˜y+f( ˆΦ,ˆx),y)
(208)
Applied to the momenta of the parameters, we have that
Eq. (209) gives
ˆU †
QFB ˆΠk ˆUQFB = ˆΠk −η ∂
∂ˆΦk
L(ˆ˜y + f( ˆΦ, ˆx), y).
(209)
In particular, we see that all of the higher order terms
vanish since all the operators in L commute and hence
L commutes with its partial derivatives.
For classical
data, all of the terms in the above update rules for the
momentum truncate at ﬁrst order in η. Thus, for training
a classical machine, the momentum of each parameter
gets shifted by an amount equal to the partial derivative
of the loss function.
We also have the important fact that the parameter
and computational registers are not entangled at the end
of the QFB circuit, hence the parameters will experience
no decoherence due to these operations. Of course, this
is assuming perfect position eigenstates for the compu-
tational registers Hx and H˜y; the parameters will expe-
rience some decoherence if this is not the case (e.g., if
one is using ﬁnitely squeezed continuous variable pointer
states).
Notice that ˆUQFB applied to the initial state yields:
ˆUQFB :
X
Φ
ψ(Φ) |Φ⟩⊗|x, 0⟩
7→
X
Φ
e−iηL(f(Φ,x),y)ψ(Φ) |Φ⟩⊗|x, 0⟩.
(210)
Since ˆUQFB leaves |x, 0⟩∈HC invariant, then the QFB
circuit simply tags diﬀerent values of Φ with a phase de-
pending on the corresponding output of the circuit. In
this case, we get a true phase kickback. Because ˆUQFB
acting on this initial state does not generate entangle-
ment between the parameter and the computational reg-
isters, then for further data points, it is simple to coher-
ently re-initialize |x, 0⟩to input a new data point |x′, 0⟩.
For multiple data points in a minibatch, {(xj, yj)}j∈B,
we begin in a state
X
Φ
ψ(Φ) |Φ⟩⊗|0, 0⟩∈HΦ ⊗Hx ⊗H˜y.
(211)
For each data point, we can ﬁrst shift the input register
to the appropriate xj, apply the QFB circuit with the

43
appropriate output yj in the loss function, and then shift
the input register back to zero and repeat for all of the
data points in the minibatch. Explicitly, the algorithm
is:
Y
j∈B
eixj· ˆpxe−iηL(ˆ˜y+f( ˆΦ,ˆx),yj)e−ixj· ˆpx
=
Y
j∈B
e−iηL(ˆ˜y+f( ˆΦ,ˆx+xj),yj).
(212)
This maps the parameter momenta and the state to (re-
spectively):
ˆΠk 7→ˆΠk −η
X
j∈B
∂
∂ˆΦk
L(ˆ˜y + f( ˆΦ, ˆx + xj), yj),
(213)
and
X
Φ
ψ(Φ) |Φ⟩⊗|0, 0⟩
7→
X
Φ
e−iη P
j∈B L(f(Φ,xj),yj)ψ(Φ) |Φ⟩⊗|0, 0⟩.
(214)
We see that the momenta of the parameters and the
phase induced in the ﬁnal state is according to the cost
function
J = 1
|B|
X
j∈B
L(f(Φ, xj), yj),
(215)
and accumulated kicking rate η|B|.
Note that this discussion also applies if f is comprised
of multiple layers:
f(ˆΦ, ˆx) = fN(ˆΦN, · · · f2(ˆΦ2, f1(ˆΦ1, ˆx))),
(216)
with parameters are divided up among these layers as
ˆΦ = ˆΦN ⊕· · · ⊕ˆΦ2 ⊕ˆΦ1. The update rule for the mo-
menta of the parameters that we derived above also holds
in this special case, so abstractly we can conclude that
the uncomputation step of the QFB algorithm indeed
propagates gradient information back through the com-
putational graph. In Section V B we will explore in-depth
how this mechanism behaves in the context of backprop-
agation of error in neural-network type computations, as
a special case of the above analysis.
A ﬁnal note about implementation of the loss function
for classical data problems. Occasionally it may be more
practical to use an auxiliary register to store the compu-
tation of the loss function, rather than to exponentiate
the loss function as a phase kick. That is, suppose we
added another register HL and appended a computation
ˆUL(y) to the feedforward operation:
ˆUL(y) ◦ˆUf(ˆΦ) : |Φ, x, 0, 0⟩
7→|Φ, x, f(Φ, x), L(f(Φ, x), y)⟩
(217)
which we can denote abstractly as ˆUL(y) = e−iL(ˆ˜y,y)ˆpL.
Then instead of exponentiating the loss function as a
phase kick, we simply apply a linear phase shift, e−iηˆxL,
to this new register before uncomputing the modiﬁed
feedforward circuit. In all, this modiﬁed QFB algorithm
is
ˆUqfb+l
= eif(ˆΦ,ˆx)·ˆp˜
yeiL(ˆ˜y,y)ˆpLe−iηxLe−iL(ˆ˜y,y)ˆpLe−if(ˆΦ,ˆx)·ˆp˜
y
= eif(ˆΦ,ˆx)·ˆp˜
ye−iη(xL+L(ˆ˜y,y))e−if(ˆΦ,ˆx)·ˆp˜
y
= e−iη(xL+L(ˆ˜y+f(ˆΦ,ˆx),y)).
(218)
We see that if we initialize the new register HL to
|xL = 0⟩, then this is equivalent to (208).
Now we will proceed to discuss the construction of the
circuit ˆUf( ˆΦ) which computes the output to a neural net-
work with quantum parameters. We will also discuss in
detail the feedforward and backpropagation mechanisms
in this setting in order to make some of the previous dis-
cussions more concrete.
3.
Abstract Quantum Neuron
Classical neurons usually act by taking as input a col-
lection of signals, adding up these contributions in a
weighted fashion, and applying a nonlinearity to this sum
to ﬁnally generate an output. A simple example, given a
vector of inputs x, weights w, and bias b, the mapping
corresponding to the neuron is given by x 7→σ(w ·x+b)
where σ : R →R is a nonlinear activation function.
To embed this mapping into a quantum computation,
we need to make the whole process reversible, as quantum
computation ultimately has to be enacted by unitary,
hence invertible, operations. To do this, we can assume
that the weights, the inputs, and the outputs (activa-
tion), are all quantum number registers (either continu-
ous variable or a discrete variable binary approximation
thereof). The quantum neuron should ideally map
|x⟩i |w, b⟩w |0⟩a 7→|x⟩i |w, b⟩w |σ(w · x + b)⟩a
(219)
which could be implemented via an idealized unitary
which enacts the above map:
e−iσ( ˆ
w·ˆx+b)ˆpa,
(220)
where ˆa is the position quadrature of the activation reg-
ister, and ˆpa is its canonical conjugate: [ˆa, ˆpa] = i. In
Figure 15 we picture such an abstract neuron and a cor-
responding abstract quantum circuit.
As the above form is quite abstract, let us brieﬂy de-
scribe how we could unpack the execution of the above
feedforward operation, while remaining fairly abstract.
In section V C, we outline various circuits and physical
scenarios which would practically enact such a mapping,
either using nonlinear optics, or using ancilla registers

44
Figure 15. Diagram of abstract quantum neuron model. Left
is a representation of the neuron itself, right is an abstract
quantum circuit representing its feedforward operation.
and phase estimation. In both cases, the weighted con-
tributions of the input are ﬁrst accumulated in collector
register, c, as such: |x⟩i |w, b⟩w |0⟩c 7→|x⟩i |w, b⟩w |z⟩c,
where z = w · x + b.
The remaining operation is to
take the stored in the collector register, and synthesis
the computation of the activation function σ : R →R
as a quantum circuit, |z⟩c |0⟩a 7→|z⟩c |σ(z)⟩a, where a
is the label for the (continuous) activation register. For
a general classically computable activation function for
which we know a classical circuit, one could directly con-
vert it to a quantum circuit using Toﬀoli gates [55], or
more eﬃcient coherent implementations of basic classical
functions [76], although this may end up being somewhat
ineﬃcient. For more details see section V C for various
examples of low-overhead implementations of certain ac-
tivation functions.
In ﬁgure 16 we represent a neuron
with a collector degree of freedom and the corresponding
two-stage abstract circuit.
Until we reach V C, for sake of compactness and gen-
erality of our analysis, we will use the ideal form of the
feedforward unitary from equation (220).
4.
Quantum Neural Network Feedforward & Baqprop
A typical feedforward neural network is comprised of
a collection of neurons organized into layers. Each layer
can be thought of as a unit which takes the activations
of the neurons of the previous layer and produces a col-
lection of output activations based on some simple non-
linear function of the input activations. The composition
of many layers produces an output activation for the en-
tire network, which overall can be seen as a nonlinear
function of the input decomposed into the simpler func-
tions of each layer. The output of the network produces a
prediction for the supervised learning problem. The pa-
rameters of the function consist of the weights and biases
of the collection of neurons in the network.
In our above notation, the feedforward step of comput-
ing the prediction of the neural network (on a quantum
computer) is the computation of the unitary
ˆUf( ˆΦ) : |Φ, x, 0⟩7→|Φ, x, f(Φ, x)⟩.
(221)
Figure 16. Diagram of a neuron with collector, and its corre-
sponding feedforward quantum circuit. The controlled-adders
are of the form (2), and the control-control adder are of the
form (3). The operator involving ˆUσ computes the non-linear
activation function σ on the collector register and stores the
result in the activation.
Recall for each data point, the quantum phase kick back-
propagation consists of three steps:
the feedforward,
cost-function phase kick, and backpropagation.
The quantum neural network described here will con-
sist of a set of quantum number registers for the input to
the network, as well as the weights, biases, and output
activations for each neuron in the network. Let the neu-
rons in a single layer ℓbe indexed by nℓ= 1, . . . , Nℓ, and
let the layer index run from ℓ= 1, . . . , L . Recall that
ideally the neuron nℓenacts
|aℓ−1⟩Aℓ−1 |wnℓ, bnℓ⟩Wnℓ|0⟩Anℓ7→
|aℓ−1⟩Aℓ−1 |wnℓ, bnℓ⟩Wnℓ|σ(wnℓ· aℓ−1 + bnℓ)⟩Anℓ
(222)
using a unitary
e−iσ( ˆ
wnℓ·ˆaℓ−1+ˆbnℓ)ˆpanℓ
(223)
which acts on the Hilbert space of the activations of the
layer ℓ−1 as well as those of the weights and activation
of neuron nℓ, i.e., HAℓ−1 ⊗HWnℓ⊗HAnℓ. Of course, our
notation implies HAℓ:= NNℓ
nℓ=1 HAnℓ, so, for example,
ˆaℓ:= (ˆanℓ)nℓ(i.e., ˆaℓis a vector of operators whose nth
ℓ
component is ˆanℓ).
Combining the action of all the neurons in layer ℓ, we

45
have
|aℓ−1⟩Aℓ−1
Nℓ
O
nℓ=1
|wnℓ, bnℓ⟩Wnℓ|0⟩Anℓ7→
|aℓ−1⟩Aℓ−1
Nℓ
O
nℓ=1
|wnℓ, bnℓ⟩Wnℓ|σ(wnℓ· aℓ−1 + bnℓ)⟩Anℓ.
(224)
To compress the notation a little, let us write
Wℓ:= (wT
nℓ)nℓ
bℓ:= (bnℓ)nℓ
σ(Wℓaℓ−1 + bℓ) := (σ(wnℓ· aℓ−1 + bnℓ))nℓ
(note that Wℓis a matrix with rows wT
nℓ, and σ(·) acts
σ(·) componentwise on elements of the vector Wℓaℓ−1 +
bℓ), and
|Wℓ, bℓ⟩Wℓ:= NNℓ
nℓ=1 |wnℓ, bnℓ⟩Wnℓ
|aℓ⟩Aℓ
:= NNℓ
nℓ=1 |anℓ⟩Anℓ.
The previous equation for the action of layer ℓin this
notation is then
|aℓ−1⟩Aℓ−1 |Wℓ, bℓ⟩Wℓ|0⟩Aℓ7→
|aℓ−1⟩Aℓ−1 |Wℓ, bℓ⟩Wℓ|σ(Wℓaℓ−1 + bℓ)⟩Aℓ,
(225)
under the unitary
e−iσ( ˆ
Wℓˆaℓ−1+ˆbℓ)· ˆpaℓ.
(226)
The feedforward for the entire network consists of a
concatenation of these unitaries:
ˆUff := e−iσ( ˆ
WL ˆaL −1+ˆbL )· ˆpaL ×
· · · e−iσ( ˆ
W2ˆa1+ˆb2)· ˆpa2e−iσ( ˆ
W1 ˆx+ˆb1)· ˆpa1
=
L
Y
ℓ=1
e−iσ( ˆ
Wℓˆaℓ−1+ˆbℓ)· ˆpaℓ
(227)
where ˆa0 := ˆx (i.e., the input to the network).
The
feedforward unitary maps
|x⟩I
L
O
ℓ=1
|Wℓ, bℓ⟩Wℓ|0⟩Aℓ
7→|x⟩I
L
O
ℓ=1
|Wℓ, bℓ⟩Wℓ|aℓ⟩Aℓ,
(228)
where the al's satisfy the recursion relation,
aℓ= σ(Wℓaℓ−1 + bℓ)
a0 := x.
(229)
Of course, the output of the network is aL (satisfying
the above recursion), which corresponds to the predic-
tion of the network upon input x. Notice that this is
indeed of the form of (221), with the input register |x⟩I,
parameter registers ⊗L
ℓ=1 |Wℓ, bℓ⟩Wℓ, and prediction reg-
ister |aL ⟩AL , along with auxiliary registers for the in-
termediate activations ⊗L −1
ℓ=1 |aℓ⟩Aℓ.
At the end of the feedforward, the phase kick for data
point (x, y) is generated by
e−iL(ˆaL ,y) : |aL ⟩AL 7→e−iL(aL ,y) |aL ⟩AL
(230)
The state after the phase kick is
e−iL(aL ,y) |x⟩I
L
O
l=1
|Wl, bl⟩Wl |al⟩Al
(231)
After the phase kick, ˆU †
ff is employed for backpropaga-
tion. The phase is not aﬀected by the backpropagation;
ˆU †
ff simply uncomputes the activations of each layer in
the reverse order of the feedforward. For example, the
ﬁrst uncompute is:
eiσ( ˆ
WL ˆaL −1+ˆbL )· ˆpAL : e−iL(aL ,y) |x⟩I |WL , bL ⟩WL |aL ⟩AL
L −1
O
ℓ=1
|Wℓ, bℓ⟩Wℓ|aℓ⟩Aℓ
7→e−iL(aL ,y) |x⟩I |WL , bL ⟩WL |0⟩AL
L −1
O
ℓ=1
|Wℓ, bℓ⟩Wℓ|aℓ⟩Aℓ.
(232)

46
This continues until we arrive back at the initial state
along with a phase:
e−iL(aL ,y) |x⟩I
L
O
ℓ=1
|Wℓ, bℓ⟩Wℓ|0⟩Aℓ,
(233)
where in the phase we still have
aℓ= σ(Wℓaℓ−1 + bℓ),
a0 := x.
(234)
This demonstrates more concretely how the quantum
phase kick backpropagation algorithm can be performed
for a quantum neural network. In the next section we
examine in further detail the quantum mechanism be-
hind the backpropagation of the error signal during the
uncomputation step, and explicitly show how the Quan-
tum Phase Error Backpropagation relates to the classical
Backpropagation of Errors.
B.
Quantum Phase Error Backpropagation:
Layerwise Analysis
Although we have already examined the trajectory of
the state of the entire network under the QFB circuit
and have a general form for the parameter momentum
updates, here we want to examine the internal mecha-
nisms of the feedforward and backpropagation more con-
cretely. For instance, we showed before that under the
full QFB circuit, ˆUqfb = ˆU †
ffe−iηL(ˆaL ,y) ˆUff, the mo-
menta of the parameters are shifted by ˆU †
qfb ˆΠ ˆUqfb =
ˆΠ −η∂L( ˆU †
ffˆ˜y ˆUff, y)/∂ˆΦ. In this case, we have ˆ˜y = ˆaL
and ˆΦ abstractly represents the collection of weights and
biases { ˆ
Wℓ, ˆbℓ}L
ℓ=1. However, here the purpose is to ex-
amine the propagation of impulses in the network, layer-
by-layer, to better understand the behavior of the net-
work during training algorithm.
A key observation of this section will be that during the
training, the activations of a layer, ˆaℓ, are always inﬂu-
enced only by the activations of previous layers, whereas
the momenta of the activations, weights, and biases (ˆpaℓ,
ˆpWℓ, and ˆpbℓ, respectively), are directly aﬀected by ac-
tivations of previous layers along with momenta of later
layers. Ultimately, this is what allows the feedforward
operation to propagate signals forward in the network
and the uncomputation to propagate momentum updates
backward through the network.
For convenience, we will write the feedforward unitary
for layer ℓas
ˆUℓ:= e−iσ( ˆ
Wℓˆaℓ−1+ˆbℓ)· ˆpaℓ,
(235)
and the feedforward from layer ℓ′ to ℓ(with ℓ′ < ℓ) as
ℓ> ℓ′
ˆU (ℓ,ℓ′)
ff
:= ˆUℓˆUℓ−1 · · · ˆUℓ′+1 ˆUℓ′.
(236)
Of course, the feedforward for the entire network is ˆUff =
ˆU (L ,1)
ff
.
Notice that each of the operators ˆaℓ, ˆpaℓ, ˆpWℓ, and
ˆpbℓare only directly aﬀected by one of these unitaries.
Of course, they can depend indirectly on the others. For
example, the activation for layer ℓ, ˆaℓ, is only aﬀected
by ˆUℓon the forward pass and ˆU †
ℓon the backward pass,
since these are the only operators in the QFB circuit
containing the conjugate operator, ˆpaℓ.
The feedforward unitary for layer ℓchanges the acti-
vation by
ˆU †
ℓˆaℓˆUℓ= ˆaℓ+ σ( ˆ
Wℓˆaℓ−1 + ˆbℓ).
(237)
The operation in the backpropagation, ˆU †
ℓ, just changes
the sign of the shift
ˆU †
ℓˆaℓˆUℓ= ˆaℓ−σ( ˆ
Wℓˆaℓ−1 + ˆbℓ).
(238)
We see that the activation in one layer depends on the
activation of the previous layer as well as the weights in
the current layer. Of course in the full feedforward cir-
cuit, the activations in the previous layer will also depend
on the preceeding layers, so we get a recursion:
ˆU (ℓ,1)†
ff
ˆaℓˆU (ℓ,1)
ff
= ˆaℓ+ σ( ˆ
WℓˆU (ℓ−1,1)†
ff
ˆaℓ−1 ˆU (ℓ−1,1)
ff
+ ˆbℓ),
(239)
which ends with
ˆU †
1 ˆa1 ˆU1 = ˆa1 + σ( ˆ
W1 ˆx + ˆb1).
(240)
Of course these expressions are unaﬀected by the remain-
ing feedforward operations, ˆU (L ,ℓ+1)
ff
, so we could also
write
ˆU †
ffˆaℓˆUff = ˆaℓ+ σ( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ).
(241)
In the backpropagation steps, we see that the activa-
tion is still only aﬀected by the activations of the previous
layers:
ˆUffˆaℓˆU †
ff = ˆU (L ,ℓ)
ff
ˆaℓˆU (L ,ℓ)†
ff
= ˆaℓ−σ( ˆ
Wℓˆaℓ−1 + ˆbℓ).
(242)
Therefore, we see clearly that the domain of inﬂuence of
the activations consists only of activations (and weights)
of the preceeding layers. Furthermore, since the activa-
tions are not directly aﬀected by the phase kick at the
output, e−iηL(ˆaL ,y), the entire QFB circuit simply com-
putes and then uncomputes the activations:
ˆU †
qfbˆaℓˆUqfb
= ˆU †
ffeiηL(ˆaL ,y) ˆUffˆaℓˆU †
ffe−iηL(ˆaL ,y) ˆUff
= ˆU †
ffeiηL(ˆaL ,y) 
ˆaℓ−σ( ˆ
Wℓˆaℓ−1 + ˆbℓ)

e−iηL(ˆaL ,y) ˆUff
= ˆU †
ff

ˆaℓ−σ( ˆ
Wℓˆaℓ−1 + ˆbℓ)

ˆUff
= ˆaℓ+ σ( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)
−σ( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)
= ˆaℓ.
(243)

47
This fact could have been deduced more easily by writ-
ing,
ˆUqfb
=
ˆU †
ffe−iηL(ˆaL ,y) ˆUff
=
e−iηL( ˆU †
ffˆaL ˆUff,y),
and noticing that in the above recursion relation for
ˆU †
ffˆaL ˆUff that no ˆpaℓ's appear. However, the purpose
of this exercise was to demonstrate that the activations
only depend on the values of the activations and weights
in the previous layers. Hence, insofar as the activations
are concerned, there is only a forward propagation of in-
formation in the network.
Now we will discuss the momenta of the activations and
the weights/biases. We will see that these will be aﬀected
by both earlier and later layers in the network. In partic-
ular, these respond to the activations in previous layers
and momentum kicks in succeeding layers. Therefore, to
propagate information forward in the network, we have
to act on the activations, and to propagate backwards we
have to act on the momenta of the activations.
The momenta of the activations in layer ℓ, ˆpaℓ, are
only aﬀected by the unitary ˆUℓ+1. The single exception is
ˆpaL , which is aﬀected only by the phase kick e−iηL(ˆaL ,y).
For the ﬁnal layer, we get
eiηL(ˆaL ,y) ˆpaL e−iηL(ˆaL ,y) = ˆpaL −η∂L(ˆaL , y)/∂ˆaL ,
(244)
and for ℓ< L , we have
ˆU †
ℓ+1 ˆpaℓˆUℓ+1 = ˆpaℓ−ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1ˆaℓ+ ˆbℓ+1) ⊙ˆpaℓ+1]
(245)
where σ′ is the derivative of the nonlinear activation
function acting on components of the vectorial argument,
and ⊙denotes componentwise multiplication, i.e.,

x1
y1

⊙

x2
y2

=

x1x2
y1y2

.
(246)
Also, note that ˆUℓ+1 ˆpaℓˆU †
ℓ+1 is the same expression
with the opposite sign for the shift.
We see explicitly
that the shift in the momentum of the activation for a
layer depends on the activation of that layer as well as
the momentum of the activation (and the values of the
weights/biases) of the following layer. For the full feed-
forward circuit, we get
ˆU †
ff ˆpaℓˆUff
= ˆU (ℓ+1,1)†
ff
ˆpaℓˆU (ℓ+1,1)
ff
= ˆpaℓ
−ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1( ˆU (ℓ,1)†
ff
ˆaℓˆU (ℓ,1)
ff
) + ˆbℓ+1) ⊙ˆpaℓ+1]
(247)
Note that the momenta get kicked on the forward pass
(not just in the backpropagation) since the shift depends
on the current activation, which in turn implicitly de-
pends on activations and weights/biases earlier in the
network due to the feedforward ˆUff.
Now, if we look at the backpropagation in isolation
(without the preceding feedforward and phase kick), we
get
ˆUff ˆpaℓˆU †
ff
= ˆU (L ,ℓ+1)†
ff
ˆpaℓˆU (L ,ℓ+1)
ff
= ˆpaℓ+ ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1ˆaℓ+ ˆbℓ+1)
⊙ˆU (L ,ℓ+2)
ff
ˆpaℓ+1 ˆU (L ,ℓ+2)†
ff
]
(248)
Which, as before, is shifted according to the activation in
the current layer as well as momenta and weights/biases
in the following layer. However, the full backpropagation
also carries inﬂuences from later in the network through
ˆU (L ,ℓ+2)
ff
ˆpaℓ+1 ˆU (L ,ℓ+2)†
ff
.
In summary, we see that, roughly, the activations carry
information forward through the network (via the feed-
forward operations), and the momenta of the activations
carry information backward through the network (via
the uncomputation operations). Therefore, for the entire
QFB circuit, we feedforward the activations to make the
prediction, kick the momentum of the output activation,
and then this momentum kick propagates back to the re-
maining activation momenta and returns the activations
to their original state. Explicitly, for ℓ< L ,
ˆU †
qfb ˆpaℓˆUqfb = ˆU †
ffeiηL(ˆaL ,y) ˆUff ˆpaℓˆU †
ffe−iηL(ˆaL ,y) ˆUff
= ˆU †
ffeiηL(ˆaL ,y) 
ˆpaℓ+ ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1ˆaℓ+ ˆbℓ+1) ⊙ˆU (L ,ℓ+2)
ff
ˆpaℓ+1 ˆU (L ,ℓ+2)†
ff
]

e−iηL(ˆaL ,y) ˆUff
= ˆU †
ff

ˆpaℓ+ ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1ˆaℓ+ ˆbℓ+1) ⊙eiηL(ˆaL ,y) ˆU (L ,ℓ+2)
ff
ˆpaℓ+1 ˆU (L ,ℓ+2)†
ff
e−iηL(ˆaL ,y)]

ˆUff
= ˆpaℓ−ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1( ˆU (ℓ,1)†
ff
ˆaℓˆU (ℓ,1)
ff
) + ˆbℓ+1) ⊙ˆpaℓ+1]
+ ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1 ˆU †
ffˆaℓˆUff + ˆbℓ+1) ⊙ˆU †
ffeiηL(ˆaL ,y) ˆU (L ,ℓ+2)
ff
ˆpaℓ+1 ˆU (L ,ℓ+2)†
ff
e−iηL(ˆaL ,y)] ˆUff
= ˆpaℓ−ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1( ˆU †
ffˆaℓˆUff) + ˆbℓ+1) ⊙ˆpaℓ+1]
+ ˆ
W T
ℓ+1[σ′( ˆ
Wℓ+1 ˆU †
ffˆaℓˆUff + ˆbℓ+1) ⊙ˆU †
qfb ˆpaℓ+1 ˆUqfb].
(249)

48
We have a shift which is a sum of the shift on the
forward pass and the backward pass. A more illustrative
way to look at this is in terms of diﬀerences:

ˆU †
qfb ˆpaℓˆUqfb −ˆpaℓ

= ˆ
W T
ℓ+1
h
σ′( ˆ
Wℓ+1 ˆU †
ffˆaℓˆUff + ˆbℓ+1)
⊙

ˆU †
qfb ˆpaℓ+1 ˆUqfb −ˆpaℓ+1
i
.
(250)
This shows that the diﬀerences of the activation momenta
before and after the QFB circuit propagate back recur-
sively, i.e., here from ∆ˆpaℓ+1 to ∆ˆpaℓ.
Of course, the
recursion ends with the output of the network, where
we apply the loss function to kick the output activation
momentum,
ˆU †
qfb ˆpaL ˆUqfb −ˆpaL = −η∇L( ˆU †
ffˆaL ˆUff, y),
(251)
where the derivative on the loss function is understood
to be with respect to the ﬁrst argument. This propagates
back via the above recursion to kick the momenta of the
activations throughout the network.
These activation momentum updates in turn aﬀect the
momenta of the weights and biases, which are the shifts
that we are actually interested in for the training. The
calculation is similar to that for ˆpaℓ. It is simple to show
that for a single feedforward step,
ˆU †
ℓˆpWℓˆUℓ= ˆpWℓ−[σ′( ˆ
Wℓˆaℓ−1 + ˆbℓ) ⊙ˆpaℓ]ˆaT
ℓ−1,(252)
ˆU †
ℓˆpbℓˆUℓ= ˆpbℓ−σ′( ˆ
Wℓˆaℓ−1 + ˆbℓ) ⊙ˆpaℓ,
(253)
where we note that here we have, respectively, a matrix
and a vector of operators. For the full feedforward and
uncomputation, we get (respectively),
ˆU †
ff ˆpWℓˆUff
= ˆpWℓ−[σ′( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ) ⊙ˆpaℓ] ˆU †
ffˆaT
ℓ−1 ˆUff,
(254)
ˆU †
ff ˆpbℓˆUff = ˆpbℓ−σ′( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ) ⊙ˆpaℓ, (255)
and
ˆUff ˆpWℓˆU †
ff = ˆpWℓ+ [σ′( ˆ
Wℓˆaℓ−1 + ˆbℓ) ⊙ˆUff ˆpaℓˆU †
ff]ˆaT
ℓ−1,
(256)
ˆUff ˆpbℓˆU †
ff = ˆpbℓ+ σ′( ˆ
Wℓˆaℓ−1 + ˆbℓ) ⊙ˆUff ˆpaℓˆU †
ff. (257)
Using these, one obtains for the full algorithm that

ˆU †
qfb ˆpWℓˆUqfb −ˆpWℓ

=
h
σ′( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)
⊙

ˆU †
qfb ˆpaℓˆUqfb −ˆpaℓ
i
ˆU †
ffˆaT
ℓ−1 ˆUff,
(258)

ˆU †
qfb ˆpbℓˆUqfb −ˆpbℓ

= σ′( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)
⊙

ˆU †
qfb ˆpaℓˆUqfb −ˆpaℓ

.
(259)
Therefore, the update for the momentum of the weights
is directly related to the update of the momentum of the
activation of the same layer. With the formula we derived
before for the update of the activation momentum, the
kick in the activation momentum of this layer depends
on the updates of the following layers back to the kick
at the output of the network. Together, the equations
(250), (258), and (259) provide the key insight into the
physics of the backpropagation of errors in the quantum
neural network.
1.
Operator Chain Rule
There is yet another way of viewing backpropagation
in the Heisenberg picture, by directly applying the chain
rule to the loss function. This perspective of the back-
propagation of errors is not as vivid as in the previous
section, but is more closely related to classical backprop-
agation, which would be written schematically as
∂L
∂Wℓ
=
∂L
∂aL
·
∂aL
∂aL −1
· · · ∂aℓ
∂Wℓ
.
(260)
Recall that from above we have the QFB circuit for the
neural network as ˆUqfb = e−iηL( ˆU †
ffˆaL ˆUff,y). Therefore,
we can write
ˆU †
qfb(ˆpaℓ)i ˆUqfb −(ˆpaℓ)i
= iη∇T L( ˆU †
ffˆaL ˆUff, y)[ ˆU †
ffˆaL ˆUff, (ˆpaℓ)i],
(261)
where (ˆpaℓ)i denotes the ith component of the vector
ˆpaℓ. It is straightforward to write a similar expression
with (ˆpaℓ)i replaced by (ˆpWℓ)ij or (ˆpbℓ)i. Note that the
term on the right-hand side is analogous to writing
∂L
∂aℓ
=
∂L
∂aL
· ∂aL
∂aℓ
,
(262)
which is akin to forward mode accumulation of automatic
diﬀerentiation. One typically continues with backpropa-
gation by iterating this procedure of using the chain rule.
In our operator picture, this proceeds by successively us-
ing the following identity,
[ ˆU †
ffˆaℓˆUff, (ˆpaℓ′)i] =σ′( ˆ
WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)
⊙ˆ
Wℓ[ ˆU †
ffˆaℓ−1 ˆUff, (ˆpaℓ′)i],
(263)
which holds for ℓ> ℓ′. One can check that this com-
mutator vanishes for the cases where ℓ< ℓ′. Hence this
backpropagation procedure terminates at ℓ= ℓ′, where
one can show that

49
h
ˆU †
ff(ˆaℓ)k ˆUff, (ˆpaℓ)ii
= iδki
(264)
h
ˆU †
ff(ˆaℓ)k ˆUff, (ˆpWℓ)iji
= iδki[ek · σ′(WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)] ˆU †
ff(ˆaℓ−1)j ˆUff
(265)
h
ˆU †
ff(ˆaℓ)k ˆUff, (ˆpbℓ)ii
= iδki[ek · σ′(WℓˆU †
ffˆaℓ−1 ˆUff + ˆbℓ)]
(266)
where ek denotes the kth standard basis vector.
It is
simple to show that these expressions can be used to
derive the equations (250), (258), and (259) from the
previous section.
C.
Implementations of Quantum Coherent Neurons
Recall that the idealized neuron takes a vector of in-
puts, combines it with a vector of weights and scalar bias,
and outputs a scalar activation as a nonlinear function
of this combination:
e−iσ( ˆ
w·ˆx+b)ˆpa : |x⟩I |w, b⟩W |0⟩A
7→|x⟩I |w, b⟩W |σ(w · x + b)⟩A .
(267)
The linear operations can be implemented in a straight-
forward manner, using digital or continuous adders (gen-
eralized CNOTs), and the multiplications from two regis-
ters into a third can be done using generalized CCNOTs,
all of which were outlined in Section II.
The step which is less palpable is the application of the
nonlinear activation function σ. Two activation functions
which are commonly used in classical neural networks are
the sigmoid function,
σβ(z) =
1
1 + e−βz ,
where β ∈R,
(268)
and the rectiﬁed linear unit (ReLU),
σ(z) = max(0, z).
(269)
(The parameter β in the sigmoid function controls the
sharpness of the transition. In the limit β →∞, it be-
comes a step function.)
In this section, we will discuss means of approximating
the sigmoid and ReLU activation functions with quantum
circuits, for the purpose of implementing the quantum
neural network described above. We will ﬁrst examine an
implementation using a hybrid discrete-continuous vari-
able (or simulated continuous variable) system, which is
based on the phase estimation algorithm. Although using
phase estimation requires some overhead of gates, projec-
tion onto the positive subspace of the input can be done
easily. The second method is a fully continuous variable
(or simulated continuous variable) implementation.
In
this case, projection onto the positive subspace of the in-
put requires some overhead to enact a non-linear phase
gate and also requires squeezed states for precision. Of
course this second issue can be overcome if using simu-
lated continuous variables on a suﬃciently large quantum
computer.
In both cases of hybrid CV-DV neurons and CV-only,
we will separate the procedure of applying the non-linear
activation into stages. The ﬁrst will be simply to assume
the combination of inputs, weights, and bias are stored
in a continuous variable collector register, c. That is,
we will assume that we have prepared |x⟩i |w, b⟩w |0⟩c 7→
|x⟩i |w, b⟩w |z⟩c, where z = w · x + b. The aim is to take
the value stored in the collector register, and approximate
the computation |z⟩c |0⟩a 7→|z⟩c |σ(z)⟩a, where a is the
label for the (continuous) activation register.
1.
Hybrid CV-DV Neurons
For the current case of hybrid discrete-continuous vari-
able neurons, we will also make use of an intermediate
discrete variable ﬁlter register, f, which will be taken to
be a collection of N qubits. The purpose of this inter-
mediate ﬁlter is to determine the sign of the value of the
collector. This will allow for an implementation of a step
function (as an approximation to the sigmoid function)
as well as ReLU.
The ﬁrst stage of this version of the neuron will be to
perform phase estimation on the collector using the ﬁlter
subsystems as the pointer system. We will use the nota-
tion of Section II and write a simulated position operator
ˆΦd,f for the ﬁlter system, where d = 2N. The spectrum of
ˆΦd,f should be taken to encompass the range of expected
values of the collector variable z. For convenience, we
will assume that the range is symmetric about the ori-
gin, and will denote the maximum value by R. Thus, the
discrete variable system aims to provide a simulation of
the collector variable z on the interval [a, b] = [−R, R].
The phase estimation step can then be written as
ω−ˆzc ˆΠd,f
d
|z⟩c |0⟩f = |z⟩c ⊗
X
k∈Zd
∆

z
d −1
2R

−k

|k⟩f
= |z⟩c ⊗
1
X
x1,...,xN=0
∆
 
(2N −1) z
2R −
N
X
n=1
xn2n−1
!
|x1, . . . , xN⟩f .
(270)

50
Note that although we only wish to determine the sign
of z, thus only the value of the most signiﬁcant qubit,
xN, the use of additional qubits aids in suppressing the
probability of error (as discussed in Section II).
Now, we can proceed to implement the non-linear ac-
tivation by conditioning on the value of the most signiﬁ-
cant qubit after the phase estimation step. For example,
the sigmoid function can be approximated with a step
function by acting the unitary
e−i
2 (1−ˆ
Z(N)
2,f )ˆΠa = |1⟩⟨1|(N)
f
⊗e−iˆΠa +|0⟩⟨0|(N)
f
⊗ˆIa, (271)
where 1
2(1 −ˆZ(N)
2,f ) = |1⟩⟨1|(N)
f
is the projector onto the
value 1 of the most signiﬁcant qubit in the ﬁlter register.
Therefore, if the value of this register is 1, which corre-
sponds to z > 0, the activation register is shifted to a
value of 1 (otherwise it retains its original value of 0).
The case of ReLU can be approximated similarly with
the unitary
e−i
2 ˆzc(1−ˆ
Z(N)
2,f )ˆΠa = |1⟩⟨1|(N)
f
⊗e−iˆzc ˆΠa + |0⟩⟨0|(N)
f
⊗ˆIca.
(272)
Here, we see that if z > 0, the unitary which is im-
plemented is eﬀectively an adder |z⟩c |0⟩a 7→|z⟩c |z⟩a,
otherwise it is just the identity.
2.
CV-only
The case of a fully continuous variable implementation
of the quantum neurons does not involve a ﬁlter register,
but a single unitary applied to the collector and activa-
tion registers,
e−iP (ˆzc)ˆΠa : |z⟩c |0⟩a 7→|z⟩c |P(z)⟩a ,
(273)
where P is some polynomial.[67] The idea here is to
choose a polynomial to approximate the desired activa-
tion function on a particular interval [a, b].
Suppose we wish to approximate the activation func-
tion with a polynomial of ﬁxed degree N, so that P(z) =
PN
n=0 cnzn. One possibility is to truncate a Taylor se-
ries of the activation function σ (if it exists) to order N.
Another possibility would be to choose the coeﬃcients
{cn}N
n=0 to minimize the distance between this polyno-
mial and the desired activation function σ in some norm.
For example, one could choose a weighted L2 norm on
the interval [a, b] and minimize the mean-squared error
MSE = 1
2
Z b
a
w(z)dz |σ(z) −P(z)|2.
(274)
The weight function, w(z), can be used to demand more
accuracy on particular regions of the interval which are
of interest. The minimum is achieved by choosing coeﬃ-
cients which solve the matrix equation:
N
X
m=0
 Z b
a
w(z)dz zn+m
!
cm =
 Z b
a
w(z)dz znσ(z)
!
.
(275)
Solving for these coeﬃcients amounts to inverting the
Hankel matrix with elements Tnm :=
R b
a w(z)dz zn+m,
where n, m = 0, . . . , N, and applying the inverse to the
right-hand side of the equation.
For a sigmoid func-
tion, σβ(z) = 1/(1 + e−βz), and uniform weight func-
tion w(z) = 1, the right-hand side involves calculating
a collection of incomplete Fermi-Dirac integrals. How-
ever, if we approximate the sigmoid function with a step
function or in the case where we are using ReLU as the
activation function, then evaluation of the elements of the
right-hand side is trivial (assuming a simple weight func-
tion). One can also straightforwardly use this technique
to build a polynomial approximation to other non-linear
activation functions, provided one can calculate (or ap-
proximate) the integrals on the right-hand side of the
above equation.
VI.
QUANTUM PARAMETRIC CIRCUIT
LEARNING
Quantum Deep Learning of quantum data will gener-
ally consist of having to learn a certain quantum map.
As all quantum operations can be seen as unitaries in a
dilated Hilbert space (possibly along with a standard ba-
sis measurement), learning a certain quantum map will
often reduce to optimizing over a space of candidate uni-
taries in order to minimize some loss function of the out-
put. In general, a certain unitary transformation over a
large Hilbert space of multiple registers can be decom-
posed into a composition of unitaries which are unitary
on smaller sets of registers. Each unitary can be seen
as a form of generalized rotation in the Hilbert space of
its registers. It is then natural to consider parametrized
ansatze constructed by composition of such generalized
rotations, each with a given "direction" (Hamiltonian
generator) and a certain angle. We call parametric quan-
tum circuits such hypothesis classes of unitaries com-
posed of multiple unitaries with are each parametrized
by real numbers. The key to learning is then to leverage
eﬃcient optimization strategies to search over the space
of possible parameters in order to minimize some loss
function.
The traditional approach to the optimization of these
parameters has been a classical-quantum hybrid ap-
proach. In this case the circuit for a certain set of param-
eter values would be executed, and the expectation value
of the loss function for a given set of parameters would be
estimated. Then, by querying the expectation value for
multiple values of the parameters for multiple runs, one
could use a classical optimizer to ﬁnd a suitable set of pa-
rameters which minimize the loss to a satisfying degree.
For example, a ﬁnite-diﬀerence gradient method [26, 27]
is often used, but this approach necessitates O(N) (where
N is the number of parameters) runs to obtain enough
expectation values of the loss for various values of the
parameters in order to estimate the gradient.
Instead of using a hybrid quantum-classical method

51
based on estimation of multiple expectation values of the
loss function for the optimization of quantum parametric
circuits, we can harness the Backwards Quantum Prop-
agation of Phase Errors (Baqprop) principle to descend
the optimization landscape more eﬃciently. Given a way
to quantum coherently evaluate the exponential of the
loss function of a potential candidate solution, one will
be able to use either Momentum Measurement Gradient
Descent or Quantum Dynamical Descent to optimize over
the set of possible circuits.
In this section, we will explore various use cases of
parametric quantum circuits, explain in greater detail
how to query exponential loss functions for various cases,
and explore how the update rule derived in previous sec-
tions specializes in these various cases.
A.
Parametric Ansatze & Error Backpropagation
Before we talk about applications of parametric cir-
cuits to various problems and how to adapt the Quantum
Feedforward and Baqprop procedure to each application,
let us brieﬂy review parametric circuits in a formal man-
ner, and provide an overview of how error signals back-
propagate through the circuit during uncomputation.
1.
From Classically- to Quantumly-Parametrized Ansatze
Let us ﬁrst consider a generic classically parametrized
circuit ansatz. Consider a set of indices for the param-
eteric operations, partitioned into the indices for each
layer, I = ∪L
ℓ=1Iℓ, we can write the parametric unitary
as
ˆU(Φ) =
L
Y
ℓ=1
ˆU (ℓ)(Φ(ℓ)),
(276)
where ˆU (ℓ)(Φ(ℓ)) is the multi-parameter unitary corre-
sponding to the ℓth layer, which can itself be composed
of multiple parametric unitaries { ˆUjℓ(Φjℓ)}jℓas follows,
ˆU (ℓ)(Φ(ℓ)) ≡
O
jℓ∈Iℓ
ˆUjℓ(Φjℓ).
(277)
Now, suppose we wish to optimize some loss operator
ˆLj, for the above parametric unitary applied onto an ini-
tial state |ξj⟩the typical approach to optimizing this is
to compute the expectation value of the loss operator for
this feedforwarded state
⟨ˆLj⟩Φ := ⟨ξj| ˆU †(Φ)ˆLj ˆU(Φ) |ξj⟩Φ .
(278)
A classical optimizer is then tasked to ﬁnd the set of
parameters which minimize the cost function which in
general can be the su of multiple loss operators, i.e.
argminΦ(P
j∈Bk ⟨ˆLj⟩Φ).
In general, for a quantum-
classical optimization procedure, multiple expectation
values of the loss operators will need to be estimated.
For example, one may perform ﬁnite-diﬀerence gradient
descent by estimating derivatives of each loss at a time
∂Φk ⟨ˆLj⟩Φ

Φ∗≈1
ϵ

⟨ˆLj⟩Φ∗+δk −⟨ˆLj⟩Φ∗

(279)
where (δk)j = ϵδjk, ϵ ≪1. For an N-parameter ansatz
and M terms in the loss function, in order to estimate the
gradient, this requires O(M · N) expectation value esti-
mations, which in some cases must each taken in separate
feedforward runs.
Instead of classically parametrizing the circuits, as we
have covered extensively in this paper, we can use quan-
tum parameters in order to leverage either MoMGrad
or QDD. As we know from section III, gradients can
then be estimated via MoMGrad in O(M) feedforward
and Baqprop queries, which we then gave techniques to
fully parallelize this gradient acquisition over the mini-
batch (sec. IV) with only O(log M) added depth over
the single-replica QFB operation.
To convert a classically parameterized a circuit of the
form (276) to a quantumly-parametrized circuit, we con-
vert ˆU(Φ) 7→ˆU(ˆΦ) where
ˆU(ˆΦ) :=
L
Y
ℓ=1
ˆU (ℓ)(ˆΦ(ℓ)),
ˆU (ℓ)(ˆΦ(ℓ)) ≡
O
jℓ∈Iℓ
ˆUjℓ(ˆΦjℓ),
(280)
and
each
unitary
is
converted
to
a
continuously-
controlled unitary with a quantum parameter register,
ˆUjℓ(ˆΦjℓ) =
X
Φjℓ
|Φjℓ⟩⟨Φjℓ| ⊗ˆUjℓ(Φjℓ).
(281)
Now assuming each unitary is generated by a certain
Hamiltonian, i.e., ˆUjℓ(Φjℓ) = e−iΦjℓˆhjℓthen the above
becomes
ˆUjℓ(ˆΦjℓ) = e−iˆΦjℓ⊗ˆhjℓ,
(282)
which we see is an exponential with a generator ˆΦjℓ⊗ˆhjℓ.
Let us examine how to synthesize such an exponen-
tial into basic gates. For a given index j ∈I, suppose
we know a way to synthesize the classically parametrized
gate e−iΦjˆhj (with Φj as the classical parameter) into a
product of non-parametric unitaries and of one or multi-
ple parametric unitaries of the form {e−iβkj Φj ˆ
Z}kj where
all βkj ∈R.
We can then convert this synthesis of
the classically parametric gate into a synthesis for its
respective quantum-parametric analogue by converting
all the parametric exponentials of Φj ˆZ into quantum-
parametric exponentials of ˆΦj ⊗ˆZ, i.e.
{e−iβkj Φj ˆ
Z}kj 7→{e−iβkj ˆΦj⊗ˆ
Z}kj.
(283)
Each quantum-parametric exponential e−iβkj ˆΦj ˆ
Z is es-
sentially like a single-qubit observable phase estimation

52
unitary; as discussed in section II B 1, it can be can be
broken up into ⌈log(d)⌉exponentials of ˆZ ⊗ˆZ where d is
the eﬀective qudit dimension of the parameter register.
Often, the generators of these exponentials are chosen
to be simple (e.g. n-local Paulis Pn [50]), hence as an
explicit example, we can consider a case where ˆhj is a
Pauli operator on n qubits. For any ˆh ∈Pn, there exists
a ˆV ∈Cn, where Cn is the n-qubit Cliﬀord group [50],
such that ˆh = ˆV † ˆZ(r) ˆV , where ˆZ(r) is the Pauli Z on a
register of choice, which we label as having an index r.
To decompose Cliﬀord group operator ˆV into basic Clif-
ford gates there are multiple known algorithms for this
synthesis [78] and Cliﬀord gates are very eﬃciently im-
plementable on error-corrected quantum computers [79].
For such an operator ˆh, a parametric exponential of the
form
e−iΦˆh = e−iΦ ˆV † ˆ
Z(r) ˆV = ˆV †e−iΦ ˆ
Z(r) ˆV
(284)
thus to convert this parametric exponential into a
quantum-parametric exponential, we need to apply
e−iˆΦ⊗ˆh = ˆV †e−iˆΦ⊗ˆ
Z(r) ˆV
(285)
the quantum-phase-estimation-like exponential in the
middle can then be broken down into ⌈log(d)⌉exponen-
tials of Paulis between the qubits of the parameter regis-
ter and that of the r register. As a side note, for analog
quantum computers, for parameter registers which are
physical qumodes, the quantum-parametric exponential
e−iˆΦ⊗ˆ
Z can be implemented using an interaction Hamil-
tonian of the form
ˆHint = λˆΦ ⊗ˆZ
(286)
where ˆΦ is a quadrature of a qumode and λ some coupling
strength. Such an interaction should be feasible to im-
plement in various quantum computing implementations
of today [80].
Now that we have seen how to execute quantum-
parametric unitaries, let us recall that in order to op-
timize the parameters Φ such as to minimize some loss
operator on the output ˆLj, we can execute the quantum
feedforward and quantum phase error backwards prop-
agation (QFB) procedure with quantum-parametric cir-
cuits, and leverage techniques from section III for opti-
mization. Recall that the QFB consists of applying the
quantum-parametric feedforward operation, an exponen-
tial of the loss function, followed by the uncomputation
of the feedforward,
e−iη ˆL(ˆΦ) = ˆU( ˆΦ)†e−iη ˆLj ˆU( ˆΦ).
(287)
Recall (54) that for an input state |ξj⟩, to ﬁrst order
in η, the momenta of the parameters get kicked by the
gradient
ˆΠ
7→
eiηL(ˆΦ) ˆΠe−iηL(ˆΦ) + O(η2)
= ˆΠ −η ∂L(ˆΦ)
∂ˆΦ
+ O(η2).
(288)
where the eﬀective loss function is given by
L(ˆΦ) := ⟨ξ| ˆL(ˆΦ) |ξ⟩.
(289)
We can then leverage this momentum shift to optimize
the parameters via MoMGrad or QDD (see sec. III). No-
tice that all components of the momentum get kicked,
but each component of the parameters comes into con-
tact with the compute at a diﬀerent time during both
the feedforward and Baqprop phases. In order to under-
stand how exactly the error signal backpropagates and
inﬂuences the various parameter's momenta during the
uncomputation, we can further examine how the param-
eters get kicked in a layerwise fashion, which we do now
below.
2.
Quantum Parametric Circuit Error Backpropagation
In Section V B, we elaborated upon the mechanism
through which the QFB circuit propagates the errors,
layer-by-layer, for quantum-coherent neural networks
through the recursive formulas (250), (258), and (259).
Here, we will brieﬂy discuss a layerwise analysis of the
quantum phase error backpropagation for layered quan-
tum parametric circuits. Of course, since we are using a
very general ansatz for the quantum parametric circuits,
we cannot repeat the analysis in the same level of detail
as for the quantum-coherent neural networks.
Consider once again a parametrized circuit decom-
posed into layers:
ˆU(ˆΦ) :=
L
Y
ℓ=1
ˆU (ℓ)(ˆΦ(ℓ)),
ˆU (ℓ)(ˆΦ(ℓ)) ≡
O
jℓ∈Iℓ
ˆUjℓ(ˆΦjℓ).
(290)
where ˆΦ = {ˆΦ(ℓ)}L
ℓ=1 is the operator vector of all the
parameters, and ˆΦ(ℓ) = {Φjℓ}jℓ∈Iℓis that of the param-
eters for a single layer.
For convenience, let us write the circuits of operations
before and after the layer k as:
ˆU (<k)(ˆΦ(<k)) :=
k
Y
ℓ=1
ˆU (ℓ)(ˆΦ(ℓ)),
ˆU (>k)(ˆΦ(>k)) :=
L
Y
ℓ=k
ˆU (ℓ)(ˆΦ(ℓ)).
(291)
Recall the QFB circuit for the entire circuit is:
ˆU †(ˆΦ)e−iη ˆL ˆU(ˆΦ)
(292)
Now suppose we would like to focus on a certain layer ℓin
the QFB circuit above, we could group the feedforward,
phase kick and uncomputation operations for layers be-
yond layer ℓas
ˆU (>ℓ)†(ˆΦ(>ℓ))e−iη ˆL ˆU (>ℓ)(ˆΦ(>ℓ)) := e−iη ˆL(ˆΦ(>ℓ)) (293)

53
we see that this is just a loss exponential with respect to
a diﬀerent loss operator
ˆL(ˆΦ(>ℓ)) := ˆU (>ℓ)†(ˆΦ(>ℓ))ˆL ˆU (>ℓ)(ˆΦ(>ℓ))
(294)
which is eﬀectively a backpropagated loss operator in the
Heisenberg picture.
Similarly, we can group the oper-
ations for layers below the layer ℓ, combined with the
backpropagated loss exponential from above, the whole
QFB circuit can then be seen as
ˆU (<ℓ)†(ˆΦ(<ℓ)) ˆU (ℓ)†(ˆΦ(ℓ))
× e−iη ˆL(ˆΦ(>ℓ)) ˆU (ℓ)(ˆΦ(ℓ)) ˆU (<ℓ)(ˆΦ(<ℓ))
(295)
which is eﬀectively like a single-layer QFB, with the back-
propagated loss, and a modiﬁed input state being the
fedforward input state.
In a sense, we can view the above picture as a quan-
tum form of automatic diﬀerentiation [77]. In classical
automatic diﬀerentiation, for a composite of functions
composed in layers, in order to compute the gradient
of the output with respect to a certain parameter, the
gradient of layers beyond that of the parameter are com-
puted layerwise starting from the output. Using both this
backpropagated gradient and the value of the fedforward
input up to the layer of the given parameter of interest,
one can compute the gradient for the said parameter. We
can try to examine how automatic diﬀerentiation is nat-
urally executed in each branch of the multi-parameter
wavefunction by the Quantum Phase Error Backpropa-
gation.
Let us label eigenstates of all parameters other than
those of layer ℓas |Φ(¬ℓ)⟩:= N
j̸=ℓ|Φ(j)⟩where ˆΦ(¬ℓ) =
{ˆΦ(ℓ)}j̸=ℓare the correponding parameter operators.
Furthermore, consider the very initial input state to the
whole QFB circuit to be |ξ⟩, and let us deﬁne the condi-
tional feedforwarded state up to layer ℓas
|ξΦ(<ℓ)⟩:= ˆU (<ℓ)(Φ(<ℓ)) |ξ⟩.
(296)
Suppose we consider each branch of the wavefunction
of parameters of layers other than ℓ, e.g., each term in
P
Φ(¬ℓ) ψΦ(¬ℓ) |Φ(¬ℓ)⟩then conditioning each branch of
this wavefunction, we get an eﬀective phase kick on the
parameters of layer ℓ. Equation (295) becomes the fol-
lowing conditional eﬀective phase on the parameters of
layer ℓ,
X
Φ(¬ℓ)
|Φ(¬ℓ)⟩⟨Φ(¬ℓ)| ⊗LΦ(¬ℓ)(ˆΦ(ℓ))
(297)
where
L(ℓ)(ˆΦ(ℓ))
=⟨ξΦ(<ℓ)| ˆU (ℓ)†(ˆΦ(ℓ))e−iη ˆL(Φ(>ℓ)) ˆU (ℓ)(ˆΦ(ℓ))|ξΦ(<ℓ)⟩.
(298)
We see above that for each case (branch of the parameter
values wavefunction for value Φ(<ℓ)) there is an incoming
state to layer ℓ(|ξΦ(<ℓ)⟩) and there is a backpropagated
phase kick operator (e−iη ˆL(Φ(>ℓ))). This is similar in vein
to classical automatic diﬀerentiation, but this happens in
every branch of the wavefunction in parallel. In a sense,
it is automated automatic diﬀerentiation. Because each
parameter can take gradients of the loss conditioned on
previous and later layers' quantum states, all parame-
ters' momenta can thus get nudged simultaneously by
the gradient of the conditional loss in each branch of the
wavefunction. This allows for single-sweep gradient esti-
mation of all parameters, in contrast to some other tech-
niques for parametric circuits which require each deriva-
tive to be computed one at a time [81].
Now, recall from section V, in the case of the quantum
neural networks, we rewrote analysed how the backprop-
agating error signal is carried between parameter regis-
ters by the compute registers. In the case of coherent
neural networks, the phase kick corresponding to the er-
ror signal would kick the activation's momenta (which in
turn kicks the momenta of the weights and biases). Here,
to see which operator is getting kicked, one would need to
examine more concretely the conjugate of the generator
of the unitaries in each layer of the circuit. Performing
such an analysis could shed some light as to what makes
a good choice parametric circuit ansatz such as to avoid
the vanishing gradient problem of most currently known
ansatze [51]. We leave this remaining analysis for future
work.
B.
Quantum State Exponentiation
In this subsection, we will delve into greater detail into
the ways to enact a certain set of loss function exponen-
tials for quantum data. In previous section III, we showed
how we could harness the MoMGrad and QDD optimiza-
tion procedures given access to a phase kick (complex
exponential) of a loss function operator for which we
would like to minimize the error. For many applications
of quantum parametric circuit learning, it will be useful
to create the phase kick for a loss function which will pro-
vide a notion of distance between the output state and
the target state, and in our case this notion of metric
will be induced by some form of inner product between
states.
1.
Single state exponentiation
Well-known in quantum information is the notion of ﬁ-
delity between quantum states. For pure quantum states,
the ﬁdelity F between states |ψ⟩and |φ⟩is simply the
magnitude of the inner product F(φ, ψ) = | ⟨φ|ψ⟩|. Note
that clearly ﬁdelity itself is not a metric, but one can cre-
ate a proper metric on the space of states by considering
the sine distance S [55], which is related to the ﬁdelity by
the equality S =
√
1 −F. In order to perform gradient
ascent on the ﬁdelity in the case of pure state learning

54
(which we will treat in-depth in the next subsection) we
will need to be able to exponentiate states, i.e., perform
e−i|ψ⟩⟨ψ| given multiple copies of |ψ⟩in memory.
That is, given a set of n copies of pure states |ψ⟩⊗n held
in memory, we would like to execute the unitary e−iη|ψ⟩⟨ψ|
to a certain precision by consuming some of these copies.
More generally, for a set of mixed states ˆρ⊗n held in
memory, we would like to be able to enact the unitary
e−iηˆρ on our target state. As we will see in VI C 1, the
exponential of mixed states will induce a gradient ascent
on the Hilbert-Schmidt inner product rather than the
ﬁdelity.
This task is referred to as quantum state exponentia-
tion (QSE) [82]. The original protocol to perform quan-
tum state exponentiation was ﬁrst formulated by Lloyd,
Mohseni, and Rebentrost [20].
This approach was re-
cently proven to be optimal for the Quantum State Ex-
ponentiation task [83]. For the target state ˆσ and a copies
of mixed states in data, the original QSE protocol applies
the map
ˆσ ⊗ˆρn 7→e−iˆρηˆσeiˆρη = Ad[e−iˆρη](ˆσ)
(299)
up to an error accuracy ϵ in the diamond norm, by using
n ∼O(η2/ϵ) steps, each consuming a copy of ˆρ.
More explictly, this quantum state exponentiation ap-
proach consists of approximating within ϵ diamond norm
error the ﬁnal target state
Ad[e−iˆρη](ˆσ) = ˆσ −i[ˆρ, ˆσ]η −1
2![ˆρ, [ˆρ, ˆσ]]η2 + . . . (300)
with n steps each consisting of partial-swapping of a copy
of ˆρ onto the target ˆσ using an exponential swap oper-
ation e−iδ ˆS, where δ = ϵ/η, for a total of n ∼O(η2/ϵ)
steps/copies. In Figure 17, we provide further detail as to
the implementation of exponential swaps via more stan-
dard gates.
If we look at the eﬀective operation acted upon the on
the target register, we have
tr2
 e−iδS(ˆσ ⊗ˆρ)eiδS
= ˆσ −i[ˆρ, ˆσ]δ + O(δ2)
= Ad[e−iˆρδ](ˆσ) + O(δ2),
(301)
thus, by repeating this process n times, we get
Ad[e−iˆρnδ](ˆσ) + O(nδ2) ≈Ad[e−iˆρη](ˆσ) + O(ϵ)
(302)
for n ∼O(η2/ϵ) and δ = ϵ/η.
This is represented in
Figure 18.
2.
Sequential Exponential Batching
There are multiple ways to perform this exponentiation
of the mixed state, one of which is to perform a serially
batched state exponentiation [82]. Assuming our mixed
state is a classical mixture of pure states of the form
ˆρ =
1
|M|
X
j∈M
|ψj⟩⟨ψj|
(303)
Figure 17. Given two states ρ and σ each supported on n
qubits, one can perform an ancilla-assisted exponential swap
e−iηS↔as above [20]. Using an ancilla qubit initially in the
|+⟩state, by applying individual controlled-swaps sequen-
tially, with the ancilla as control and corresponding qubit
registers of ˆρ and ˆρ as targets, then applying an exponen-
tial e−iη ˆ
X on the ancilla, and later undoing the control-swap
sequence, as the reader can readily check, the ancilla is left
unchanged, and an eﬀective unitary exponential of swap be-
tween sets of registers e−iηS↔is thus applied.
Figure 18. Given n copies of a state ˆσ, we can batch expo-
nential swaps (pictured in ﬁgure 17) with the target state ˆρ,
for angles ˜η = ϵ/η to induce a phase e−iηˆσ on ˆρ up to an error
O(ϵ) for a number of copies scaling as n ∼ϵ/η.
then, from the Baker-Campbell-Hausdorﬀlemma, notice
we can split the exponential of the mixed state into a
sort of Trotterization [82] of exponentials, sequentially
exponentiating each state one at a time and performing
multiple sweeps over the data set. Suppose we perform
N sweeps over the dataset, let ˜η ≡η/|M|, we can then
approximate the exponential as
e−iηˆρ = e−i˜η P
j∈M|ψj⟩⟨ψj|
=
N
Y
n=1
Y
j∈M
e−i ˜
η
N |ψj⟩⟨ψj|
+ O( |M|˜η2
N
)
(304)
where the error is of order O( |M|˜η2
N
) = O(
η2
|M|N ) in
the diamond norm [82].
We can call this sequential
mini-batching of quantum state exponentiation.
Triv-
ially, a similar bound can be derived for a decomposi-
tion of the mixed state into other mixed states, e.g. if

55
ˆρ = |M|−1 P
j∈M ˆρj we can then batch the state expo-
nential as
e−iηˆρ = e−i˜η P
j∈M ˆρj =
N
Y
n=1
Y
j∈M
e−i ˜
η
N ˆρj
+ O( |M|˜η2
N
).
(305)
Since we will be considering both mixtures of mixed
states and pure state as input the above techniques are
an important option. Note this batching is used for the
data loading, which is diﬀerent from batching phase kicks
on the parameters Quantum Feedforward and Baqprop
iterations as discussed in IV.
3.
QRAM Batching
Another option to create the mixed state is to use a
Quantum Random Access Memory (QRAM). Although
using a QRAM is not essential, the QRAM will create
a mixture of various states, thus eﬀectively preparing a
mixed state. Given a set of states {|ψj⟩}j∈M, using a
QRAM with a uniform superposition over addresses in
the index set M, we can prepare a state
1
√
|M|
X
j∈M
|j⟩a 7→
1
√
|M|
X
j∈M
|j⟩a |ψj⟩d
(306)
where A is the quantum address index and D is the data
register, using a tree-like network of Fredkin gates, of
depth O(log |M|) [24].
The reduced state of the data
register with the address traced out is the desired mixed
state
ˆρd =
1
|M|
X
j∈M
|ψj⟩⟨ψj|d .
(307)
Through multiple queries of the QRAM, multiple copies
of the mixed state ˆρd can be obtained, then using the
same single-state exponentiation techniques as described
above in VI B 1, for a number n ∼ϵ/η copies, we can
enact the exponential e−iηˆρd within an error ϵ.
Note that apart from requiring a lower depth, there
is no clear advantage of using a QRAM batching over
sequential batching. Once again, this batching of state
exponentiation is only for data lodaing, one can also use a
QRAM for minibatching of the descent of the wavefunc-
tion in the parameter landscape, as discussed in subsec-
tion IV A 4. Then again, there does not seem to be a
necessity for QRAM in that scenario either.
C.
Quantum State Learning
Quantum state learning can be seen as the quantum
analogue of unsupervised learning. In classical ML, given
samples from a certain distribution, using neural network
anstaze such as Restricted Boltzmann machines, autoen-
coders, or Generative Adversarial Networks, one learns
a way to sample for the underlying distribution of the
data.
The statistics of the classical probability distri-
bution are replicated by learning a map which can take
as input simple (often taken to be uncorrelated) random
variables, called the latent variables, and transforms their
joint distribution into an approximation of the data's un-
derlying distribution.
In quantum mechanics, instead of strictly classical
probability distributions, there are wavefunctions, and
classical distributions of wavefunctions. These are known
as pure states and mixed states respectively. Similarly
to the classical case, we can learn a way to map simple
distributions, such as tensor products of pure states, or
tensor products of mixed states, to the quantum distri-
bution which underlies the data.
We begin by learning how to generate pure states,
given many copies of the same state from data. Following
this, we will cover a way to recover mixed states, given
copies of the mixed state or access to pure state samples
from the distribution.
1.
Quantum Pure State Learning
The pure state learning task is the following: given n
copies of an unknown state, |ψ⟩, we would like to learn
a circuit decomposition which prepares the state, | ˜ψ⟩,
with a high ﬁdelity to the desired state |ψ⟩.
One can
achieve this by employing the framework of this paper of
optimizing over a family of parametrized circuits, ˆU(ˆΦ),
which are applied to an initial resource state, |ψ0⟩. This
resource state, for example, could be the computational
null state, N
j |0⟩j, of a collection of qubits. Depending
on the complexity of the pure state to be learned, it may
be advantageous to exploit any available prior knowledge
to begin in a state which is closer to the target state.
Now we will explain how this task can be solved using
the Quantum Feedforward and Phase-Kick Backpropa-
gation (QFB) algorithm in conjunction with either Mo-
mentum Measurement Gradient Descent (MoMGrad) or
Quantum Dynamical Descent (QDD). Recall that a sin-
gle run of QFB entails an application of the parametrized
unitary, ˆU(ˆΦ), on the input state, |ψ0⟩, followed by the
exponentiated loss function, e−iη ˆL, and the uncompute,
ˆU †(ˆΦ). In the present task of pure state learning, the
loss function will be ˆL = −|ψ⟩⟨ψ|. Exponentiation of
this loss function can be achieved, using multiple copies
of |ψ⟩, through the methods described in Section VI B.
This circuit is illustrated in Figure 19.
For this loss function, the eﬀective phase which gener-
ates the kick in the momenta of the parameters is:
L(ˆΦ) = ⟨ψ0| ˆL(ˆΦ) |ψ0⟩
= −| ⟨ψ| ˆU(ˆΦ) |ψ0⟩|2.
(308)
Recall that above we deﬁned ˆL(ˆΦ) := ˆU †(ˆΦ)ˆL ˆU(ˆΦ), i.e.,

56
Figure 19. The QFB circuit for quantum pure state learning.
This consists of a feedforward unitary, ˆU(ˆΦ), controlled by
quantum parameters ˆΦ, a phase kick achieved through state
exponentiation of n copies of |ψ⟩in the lower registers (and
classically-controlled by the hyper-parameter η), followed by
the uncomputation ˆU †(ˆΦ). The initial state on the computa-
tional registers is an input resource pure state |ψ0⟩.
the evolution of the cost function under the parametrized
algorithm ˆU(ˆΦ).
Notice that the eﬀective phase (for
each value of Φ) is minus the squared ﬁdelity between
the output of the parametrized circuit on the input re-
source state with the desired state. Since the momenta
are kicked according to ˆΠ 7→ˆΠ −η∂L(ˆΦ)/∂ˆΦ + O(η2),
we see that the use of QFB along with MoMGrad or
QDD performs gradient ascent on the squared ﬁdelity of
the output of the parametrized circuit with the state we
wish to learn.
2.
Quantum Mixed State Learning
The task of mixed state learning is similar to the case
of pure states:
given n copies of an unknown state,
ˆρ ∈B(H), one would like to learn a parametrized cir-
cuit which prepares a state close to ˆρ.
The methods
presented here will use the notion of proximity induced
by the Hilbert-Schmidt inner product on B(H).
The parametrized circuit, ˆU(ˆΦ), will act on a pure ini-
tial resource state, |ψ0⟩, on a larger Hilbert space, ˜H, of
suﬃcient size to be capable of containing the puriﬁca-
tion of the state to be learned. We will then identify a
subsystem of ˜H as the Hilbert space H, so that we can
decompose ˜H = H⊗Hc. The goal is for the reduced state
on H, after applying the parametrized circuit to the in-
put state, to approximate ˆρ. Let us denote this reduced
state as
ˆ˜ρ(ˆΦ) := trHc[ ˆU(ˆΦ) |ψ0⟩⟨ψ0| ˆU †(ˆΦ)].
(309)
For example, if the state ˆρ is a mixed state on N qubits,
then one can take the extended Hilbert space to be a
space containing 2N qubits. Then the goal is to create a
mixed state on a subset of N qubits which approximates
ˆρ.
The loss function will be ˆL = −ˆρ ⊗ˆIHc acting on ˜H =
H ⊗Hc. As before, exponentiation of this loss function
can be achieved using the methods of Section VI B given
multiple copies of the state. It is straightforward to show
that the eﬀective phase will be minus the Hilbert-Schmidt
inner product between the desired state and the reduced
state on H after applying the parametrized circuit on the
input:
L(ˆΦ) = −⟨ψ0| ˆU †(ˆΦ)ˆρ ⊗ˆIHc ˆU(ˆΦ) |ψ0⟩
= −trH[ˆρ trHc[ ˆU(ˆΦ) |ψ0⟩⟨ψ0| ˆU †(ˆΦ)]]
= −trH[ˆρˆ˜ρ(ˆΦ)].
(310)
Therefore, the training algorithm will perform gradient
ascent on this inner product. The circuit for this proce-
dure is illustrated in Figure 20.
Figure 20. The QFB circuit for quantum mixed state learn-
ing. Again, the phase kick is achieved through quantum state
exponentiation using n copies of the mixed state ˆρ (lower reg-
isters). The phase kick gate is also classically-controlled by
the hyper-parameter η. The feedforward and uncomputation
unitaries act on a dilated Hilbert space with initial pure re-
source state |ψ0⟩. The task of mixed state learning is for the
feedforward unitary to prepare the desired mixed state on a
subset of these registers (those upon which the phase kick
acts).
D.
Quantum Unitary & Channel Learning
1.
Supervised Unitary Learning
One means of learning a unitary operator, ˆV , is via
samples of input/output pairs, {(|ψi
j⟩, |ψo
j ⟩)}j. Ideally,
these pairs are such that |ψo
j ⟩= ˆV |ψi
j⟩for all j. How-
ever, it is possible that the source of these samples is
noisy, in which case one may need to assume some of
the data states are not pure and hence be represented as
mixed states related through a channel. Such a situation
will be subsumed by the following subsection where we
describe the process for supervised channel learning. In
that context, one can use a unitary ansatz for the chan-
nel mapping between mixed states. For this section, we
will focus on the more particular case where the data
states are pure, and we want to learn a unitary which
approximates the ideal unitary, ˆV .
For each input/output data pair, indexed by j, the
input to the parametrized algorithm, ˆU(ˆΦ), is |ψi
j⟩. The
loss function will be ˆLj = −|ψo
j ⟩⟨ψo
j |, which, as opposed
to state learning, will be diﬀerent for every data pair j.
Again, this loss function can be implemented as a phase
using state exponentiation, given multiple copies of the

57
state. Using these, the eﬀective phase on the parameters
for the data pair j will be:
Lj(ˆΦ) = −| ⟨ψo
j | ˆU(ˆΦ) |ψi
j⟩|2,
(311)
i.e., the negative squared ﬁdelity between the output of
the parametrized algorithm (upon input |ψi
j⟩) and the
desired output, |ψo
j ⟩. This is quite similar to the phase
obtained for pure state learning, but here the input and
loss functions are diﬀerent for every kick of the momenta.
This setup is illustrated in Figure 21.
Figure 21. QFB circuit for supervised unitary learning. The
data points (|ψi
j⟩, |ψo
j ⟩) are ideally generated by some unitary
operator ˆV , which we wish to approximate with ˆU(ˆΦ). This is
achieved by using |ψi
j⟩as an input to the QFB circuit, and the
corresponding projector onto |ψo
j ⟩is used as a loss function
via state exponentiation.
2.
Supervised Channel Learning
Supervised learning of a quantum channel, Λ, requires
input/output pairs, {(ˆρi
j, ˆρo
j )}j, which will generally be
mixed states acting on a Hilbert space H. Ideally, these
pairs satisfy ˆρo
j = Λ(ˆρi
j), but of course there may be noise
in the dataset.
In a similar fashion to mixed state learning, we will
employ a parametrized unitary, ˆU(ˆΦ), acting on an ex-
tended Hilbert space ˜H := H ⊗Hc. We will then train
this algorithm so that, when restricted to H, the algo-
rithm approximates the channel Λ. Explicitly, for each
data pair j, we will have the parametrized unitary, ˆU(ˆΦ),
act on ˆρi
j and an initial resource state |ψ0⟩∈Hc. Tracing
out Hc after the unitary gives a quantum-parametrized
channel:
Λ(ˆΦ) : ˆρi
j 7→trHc[ ˆU(ˆΦ)ˆρi
j ⊗|ψ0⟩⟨ψ0| ˆU †(ˆΦ)].
(312)
We will also denote the output of this channel, for input
ˆρ, as Λ(ˆΦ)[ˆρ]. The goal is to parametrize the channel so
that, for each j, this output is close to ˆρo
j .
To this end, we will take the loss operator to be ˆLj =
−ˆρo
j ⊗ˆIHc, similar to the case of mixed state learning.
The eﬀective phase we obtain is:
Lj(ˆΦ) = tr ˜
H[ˆL ˆU(ˆΦ)ˆρi
j ⊗|ψ0⟩⟨ψ0| ˆU †(ˆΦ)]
= −trH[ˆρo
j Λ(ˆΦ)[ˆρi
j]],
(313)
which is negative the Hilbert-Schmidt inner product be-
tween the output of the parametrized channel (upon in-
put ˆρi
j) and the desired output state, ˆρo
j .
The QFB circuit for this task is illustrated in Figure 22.
Figure 22. QFB circuit for supervised channel learning. Sim-
ilar to unitary learning, the data points (ˆρi
j, ˆρo
j) ideally cor-
respond to the input and output of a quantum channel Λ.
The goal of supervised channel learning is to ﬁnd a unitary
on a dilated Hilbert space, such that the desired channel is
approximated when this unitary is restricted to a subset of
the input and output registers.
3.
Unsupervised Unitary Learning
Another situation in which the methods presented
herein can be used to learn a unitary, ˆV , is when one
is given an oracle for ˆV which can be queried, rather
than a set of input/output data pairs. The basic idea
is to turn the problem into that of state learning on the
Choi state of the unitary. The oracle for ˆV will be used
to create the desired Choi state in order to use it as a
loss function. This technique can also be used to learn
the Choi state of a channel (next section), but ﬁrst we
will describe the special case of learning a unitary.
To generate the appropriate loss function, we employ
the unitary oracle mapping ˆV : H →H. First, let us
denote |φ+⟩:=
1
√
dim H
P
j |jj⟩as a maximally entangled
state on H⊗2, equivalent to the identity map in the Choi-
Jamiolkowski picture. The loss function will be the Choi
state, obtained by acting the oracle on one of the two
subsystems of this maximally entangled state:
ˆL = −(ˆIH ⊗ˆV ) |φ+⟩⟨φ+| (ˆIH ⊗ˆV †) =: −ˆσ ˆV .
(314)
Exponentiation of this state to obtain a phase operator
will require multiple queries to the oracle.
The parametrized algorithm, ˆU(ˆΦ), will similarly be
applied to one of the two subsystems of |φ+⟩∈H⊗2 as
an input state, i.e., (ˆIH⊗ˆU(ˆΦ)) |φ+⟩. Then the above loss
function will be applied as a phase, yielding an eﬀective

58
phase on the parameters:
L(ˆΦ) = −| ⟨φ+| (ˆIH ⊗ˆV †)(ˆIH ⊗ˆU(ˆΦ)) |φ+⟩|2
= −trH⊗2[ˆσ ˆV ˆσ ˆU(ˆΦ)]
= −| trH[ ˆV † ˆU(ˆΦ)]|2.
(315)
Notice we have deﬁned, analogous to ˆσ ˆV ,
ˆσ ˆU(ˆΦ) := (ˆIH ⊗ˆU(ˆΦ)) |φ+⟩⟨φ+| (ˆIH ⊗ˆU †(ˆΦ)).
(316)
This eﬀective phase can be seen in terms of either the
Hilbert-Schmidt inner product on the Choi states of the
two unitaries or the square of the Hilbert-Schmidt in-
ner product of the parametrized unitary and the desired
unitary.
The setup for this task is illustrated in Figure 23.
Figure 23.
QFB circuit for unsupervised unitary learning.
Using an oracle for ˆV , one can prepare multiple copies of the
Choi state of the unitary for the purposes of state exponenti-
ation. The QFB circuit ﬁrst involves creating the Choi state
of the parametrized ansatz, ˆU(ˆΦ), as the feedforward, then
using the desired Choi state as a loss function before the un-
computation.
4.
Unsupervised Channel Learning
Unsupervised channel learning will be very similar to
unsupervised unitary learning, with the addition of us-
ing a parametrized unitary, ˆU(ˆΦ), acting on an extended
space ˜H = H ⊗Hc as in mixed state learning and su-
pervised channel learning.
Here, we assume access to
an oracle for a quantum channel, Λ, and the task is to
use this to learn a set of parameters for the unitary,
ˆU(ˆΦ), acting on ˜H, so that the parametrized channel,
Λ(ˆΦ) : B(H) →B(H), given by
Λ(ˆΦ) : ˆρ 7→trHc[ ˆU(ˆΦ)ˆρ ⊗|ψ0⟩⟨ψ0|Hc ˆU †(ˆΦ)],
(317)
approximates Λ. Note that |ψ0⟩∈Hc is some resource
state, as described in the mixed state learning section.
As in the previous section, we will use the oracle Λ
and a maximally entangled state, |φ+⟩, to generate a loss
function which will be the Choi state of Λ:
ˆL = −(I ⊗Λ)(|φ+⟩⟨φ+|) =: −ˆσΛ.
(318)
The procedure, then, is to apply (ˆIH ⊗ˆU(ˆΦ)) to the
input state |φ+⟩|ψ0⟩∈H⊗2 ⊗Hc, apply e−iη ˆL, followed
by the uncompute. After tracing over everything except
the parameter registers, we obtain an eﬀective phase:
L(ˆΦ) = trH⊗2⊗Hc ˆL(ˆIH ⊗ˆU(ˆΦ))(|φ+⟩⟨φ+|H⊗H
⊗|ψ0⟩⟨ψ0|Hc)(ˆIH ⊗ˆU †(ˆΦ))

= −trH⊗H[ˆσΛˆσΛ(ˆΦ)],
(319)
where the Choi state of the parametrized channel is:
ˆσΛ(ˆΦ) := (I ⊗Λ(ˆΦ))(|φ+⟩⟨φ+|).
(320)
Hence, the eﬀective phase is the Hilbert-Schmidt inner
product between the Choi state of the parametrized chan-
nel with that of the desired channel.
The setup for unsupervised channel learning is illus-
trated in Figure 24.
Figure 24.
QFB circuit for unsupervised channel learning.
Given an oracle for the channel Λ, one can create multiple
copies of the Choi state of the channel, ˆσΛ, for state expo-
nentiation in the phase kick step of QFB. The ansatz for the
channel consists of a parametrized unitary on a dilated Hilbert
space. The goal is for this unitary to approximate the channel
Λ on a subset of the input and output registers. The feed-
forward step of QFB involves creating the Choi state of the
parametrized channel on this subset of registers. The phase
kick applies the Choi state of the desired channel as a loss
function on the output of the feedforward. Of course this is
followed by uncomputation. The input to the parametrized
unitary on the dilation of the input space of the channel is
some initial resource state |ψ0⟩.

59
E.
Quantum
Classiﬁcation/Regression/Measurement Learning
1.
Overview
Classiﬁcation is the task of associating collections of
objects with some set of discrete labels. Regression is
essentially a similar task, but where the labels are con-
tinuous. The present discussion will apply to both cases
of discrete and continuous labels, hence we will not re-
strict the discussion to either case and simply denote the
labels by a parameter α.
Here, we will describe how one can train a quantum
algorithm to assign labels to quantum states, using a set
of training examples. Let us denote the set of labelled ex-
ample quantum states by {ˆραj
j }j ⊂B(H), with αj denot-
ing the label for example of index j. The set of labels will
be denoted A. The goal of the classiﬁcation/regression
task is to build a measurement scheme so that, upon in-
put of a state, the measurement outcome corresponds to
the appropriate label. Therefore, this task could also be
called measurement learning.
Ideally, the labels for the example states are exactly
characterized by a POVM with eﬀects { ˆEα}α, so that
tr( ˆEαˆραj
j ) = δαj
α .
Thus, we wish to design a set of
quantum-parametrized eﬀects { ˆEα(ˆΦ)}α to approximate
this assignment of labels.
Note that if the example states are joint eigenstates of
some collection of observables, then the problem is essen-
tially classical since we would simply be assigning labels
to elements of the conﬁguration space. Also, for the cases
where all of the example states are pure, one may imag-
ine attempting to build a measurement scheme by using a
unitary to map to a ﬁxed basis of label states, |α⟩, which,
upon measurement in this basis, would provide a label
α. This problem would correspond to learning a PVM.
However, it is clear that this task is simply providing ex-
act labels to some basis of the Hilbert space, which again
is essentially a classical labelling task.
Of course, the
classical task of learning a PVM will be included here as
a special case, but here we will focus on the more general
case of learning a POVM.
Naimark's dilation theorem reduces the problem of
learning a POVM to learning a unitary and a projective
measurement on an extended space. The projective mea-
surements can be the projectors onto the label states, |α⟩,
and the unitary will be a parametrized algorithm, ˆU(ˆΦ),
acting on an extended Hilbert space ˜H = H ⊗Hc, with
an initial resource state |ψ0⟩in Hc.
For the input ˆραj
j
on H to the parametrized algo-
rithm, a possible choice of loss operator is ˆLj = −ˆIH ⊗
|αj⟩⟨αj|Hc. In the next subsection we discuss various loss
function options which share the same optimum.
The
corresponding eﬀective phase on the parameters is:
Lj(ˆΦ) = −trH( ˆEαj(ˆΦ)ˆραj
j ),
(321)
where the parametrized eﬀects, ˆEα(ˆΦ) : H →H, are
ˆEα(ˆΦ) := ⟨ψ0| ˆU †(ˆΦ) |α⟩⟨α| ˆU(ˆΦ) |ψ0⟩.
(322)
Note that this is similar to the result obtained for super-
vised channel learning. The diﬀerence is that, here, the
loss function penalizes the incorrect label states on Hc,
rather than the incorrect output states on H.
The setup for this task is illustrated in Figure 25.
Figure 25.
QFB circuit for quantum measurement learn-
ing.
The parametrized ansatz for a POVM consists of a
parametrized unitary acting on a dilated Hilbert space fol-
lowed by a standard basis measurement. The loss function is
a projector onto the corresponding basis state assigned to a
particular label. Naimark's theorem ensures that this mea-
surement can be performed solely on the registers extending
the original Hilbert space of the states to be classiﬁed.
2.
Output Encodings & Implementation Options
There exists multiple ways of encoding the output, es-
pecially when considering both continuous-variable and
discrete labels. As such, there exists multiple options for
our choice of loss function, which all reward having the
correct label but may penalize incorrect labels diﬀerently.
It is worth discussing these options as some have varying
implementation and compilation overheads.
In all cases, if we denote the output label registers as A,
the negative projector onto the correct label state ˆLj =
−|αj⟩⟨αj|A gives us a valid loss function which clearly
has minimal value when the correct label is assigned in
each case. Let us denote the label state n-qubit projector
|αj⟩A =
n
O
k=1
|α(k)
j ⟩Ak
(323)
in which αj is an n-bit string of bit values α(k)
j
for the
kth bit of the jth label, and in which we denote the quan-
tum registers of each qubit in this label as Ak. To im-
plement an exponential of this loss function, since the
label states |αj⟩A are computational basis states, for
an n-qubit projector we can implement the exponen-
tial of this projector by applying ˆUαjeiη|1⟩⟨1| ˆU †
αj where
ˆUαj ≡N
k ˆX
¬α(k)
j
k
is the product of bit ﬂips correspond-
ing to the bitwise-negated label bit string. To implement
the exponential of the multi-|1⟩state, we can use an ad-
ditional ancilla work register W, onto which we apply

60
a Cn-NOT (i.e., and n-qubit control generalized Toﬀoli
gate, which itself can be broken down into a linear num-
ber of Toﬀolis [55]), then apply an exponential of ˆZ on the
work register, and undo the multi-control-Toﬀoli, that is
Cn-NOTaweiη ˆ
ZwCn-NOTaw |0⟩w = eiη|1⟩⟨1|a ⊗|0⟩w.
Hence, we have described how to enact the exponen-
tial of any given bit-string represented label. Now, the
cost function is a quite sparse in the Hilbert space of the
possible bit string states for the label. It might then be
advantageous in some cases to have a cost function whose
representation in the computational basis has a greater
support (larger rank) than a single-state projector, such
as to nudge the optimization of parameters even when
the output of the network for a given set of parameters
is wrong with high probability. To do so, we can con-
struct a Hamiltonian whose ground state coincides with
that of the correct label. For example, for the one-hot en-
coded label |αj⟩= N
k∈A |δjk⟩k, we can use the following
Hamiltonian for which it is the ground state:
ˆLj ≡−
X
k∈A
(−1)δjk ˆZk.
(324)
One of the draws of this approach is that this loss func-
tion exponential is easy to synthesize using a product of
individual qubit exponentials;
e−iη ˆLj =
O
k∈A
eiη(−1)δjk ˆ
Zk
(325)
which is much easier than synthesizing a single-state pro-
jector. Additionally, the rank of this Hamiltonian is the
same as that of dimension of the label space, i.e., of |A|,
this can, in turn, provide a better kickback on the pa-
rameters being optimized, especially for the sectors of
the wavefunction which have minimal overlap with the
correct label.
In the case of continuous-label classiﬁcation (i.e., re-
gression), we can imagine having each class label be a ten-
sor product of multiple qudit-computational basis states.
That is, |αj⟩= N
k∈A |α(k)
j ⟩Ak where each component
α(k)
j
is a d-ary number, and the states of each label sub-
register are qudit states; |α(k)
j ⟩ak = N
j∈A ˆXα(k)
j
|0⟩ak
where ˆXα(k)
j
are qudit shifts.
In terms of cost function, one option is to use once
again the negative projector on the joint label eigen-
state, i.e., ˆLj = −|αj⟩⟨αj|A. To apply an exponential
of this projector, we can apply ˆUαjeiη|0⟩⟨0| ˆU †
αj where
ˆUαj ≡N
k ˆXα(k)
j . To apply an exponential of the joint
null state, one could consider using the same trick as
outlined above, using multi-controlled Toﬀolis, but now
multi-qudit-controlled generalize Toﬀolis. If each qudit
is made of qubits, one can shift the state of each qu-
dit from |0⟩to whichever state has all qubits be in their
|1⟩state, then use a CN-NOT gate with an ancilla work
qubit as before, where N = n⌈log2 d⌉is the total number
of qubits. This can be achieved in O(N) gates.
Another possible choice of loss function is the mean-
squared loss, where we consider the loss as
ˆLj = −
X
k∈A
(ˆφAk −αk)2
(326)
where ˆφk is the simulated position operator of the qudit
register, similar to the ˆΦj operators of the parameters.
Note that the state |αj⟩A is the ground state of this loss
Hamiltonian, hence optimizing the above will also result
in the correct label being output, and there is a less sparse
error signal since the rank of this loss function spans the
whole space of possible labels, rather than being rank 1
in the case of the projector.
In terms of implementation of the exponential loss,
(ˆφAk −αk)2 = ˆXα(k)
j
ˆφ2
Ak ˆXα(k)†
j
, hence a simple way to
enact the exponential loss is by applying
e−iη ˆLj = ˆUαjeiη ˆφ2
Ak ˆU †
αj,
(327)
which is similar to the weight decay exponentials de-
scribed in section III, and can be synthesized into a cir-
cuit of depth O(⌈log2 d⌉2).
F.
Quantum Code Learning
In this section we consider how to automate the learn-
ing of quantum codes for compression and error correc-
tion. In both cases, there exists a skew subspace HG of
the input Hilbert space H which we would like to isolate
into a subset of registers. This nonlocal subspace could
be the subspace where most of the input space has its
support, or the logical subspace of a quantum error cor-
recting code. Finding the code (transformation) which
concentrates this non-locally encoded subspace onto a
subset of registers will be the task we will automate with
quantum learning. To ﬁnd a good transformation of the
input space, we can optimize over a family of paramet-
ric quantum circuits, this can be achieved by imposing
cost functions which either maximize the ﬁdelity of re-
construction (after encoding and decoding), or minimize
the information leakage to the environment, or maximize
the ﬁdelity of the state in the logical subspace. We will
brieﬂy introduce the information theoretic task in each
case, and outline how to evaluate the cost function and
execute the Quantum Feedforward and Phase Backprop-
agation (QFB) procedure in each case. This leaves all
options discussed in section III for optimization over the
space of parameters open.
1.
Quantum Autoencoders: Compression Code Learning
We ﬁrst consider regular quantum autoencoders and
later consider the more specialized case of denoising
quantum autoencoders.
The information theoretic task automated by autoen-
coders is that of compression of a source's signal, also

61
known as the quantum source coding task [84] in quan-
tum Shannon theory.
Consider a quantum source to
be akin to a sender of a quantum messages, where the
sender picks from a set of possible quantum states to
send through, and the variable representing the decision
to send a speciﬁc state is modelled by a classical random
variable.
More speciﬁcally, we can consider having a classi-
cal random variable X with a probability distribution
p(X = x) ≡px. This classical random variable is an in-
dex for a certain alphabet of states, which we can consider
to be either a set of pure states {|ψj⟩}j∈X or mixed states
{ˆρj}j∈X. Each incoming message can be represented as a
classical mixture of states in the alphabet, with the clas-
sical probability distribution being that of the alphabet
index, ˆρ = P
j∈X pj |ψj⟩⟨ψj| or ˆρ = P
j∈X pj ˆρj.
In general, this message will be send using an alphabet
made of states of multiple registers, whether these be
qubits, qudits, or qumodes. The goal of compression is
to map these states to a space of fewer qubits/qudits,
while retaining suﬃcient information so that they can be
recovered with high probability.
The theoretical optimum rate (i.e., number of qubits
per message) at which we can encode our messages with-
out loss (considering the asymptotic limit of sending
many messages), is given by the Von Neumann entropy
of the mixed state
S(ˆρ) = −tr [ˆρ log(ˆρ)] = −
X
λ∈spec(ˆρ)
λ log(λ),
(328)
and the scheme which achieves this optimal rate is called
Schumacher's quantum data compression protocol.
In the following, we will outline how one can train a
parametrized unitary as an encoder to perform this com-
pression task. Note that for the case of the regular au-
toencoder, we consider the source to be noiseless, i.e.,
the messages are brought to the network as is. When
we consider the denoising autoencoder later in this sec-
tion we will consider adding noise to the input. Thus for
the regular autoencoder the information theoretic task
is akin to noiseless Shannon compression, except that
in general there is no guarantee to reach the theoretical
entropy limit, nor to be completely lossless.
The inputs to the quantum autoencoder will run
through the collection of states in the alphabet, on the
Hilbert space H. For simplicity, we will denote a general
input state to the autoencoder as ˆρ. The autoencoder
will consist of a parametrized unitary, ˆU(ˆΦ), acting on
H. We will factorize the Hilbert space at the output of
the unitary into H = Hg ⊗Ha, where Hg is the sector
containing the compressed representation of the input
state and Ha corresponds to trash registers.
Before we can discuss appropriate loss functions, ﬁrst
we must determine a means of characterizing the success
of an encoder. One means of characterizing the success of
the encoder is by measuring the ﬁdelity between the state
at the input of the encoder with that of a decoding of the
compressed state. A decoding scheme would be to input
the compressed state along with a reference state into
ˆU †(ˆΦ). Explicitly, let us introduce a new register, Ha′,
to denote the source of the reference state used during
the decoding. Then, an encoding followed by a decoding
involves applying ˆU(ˆΦ) to ˆρga (where the subscripts g,
a have been introduced to specify the appropriate sub-
systems), then applying a swap, Saa′, between Ha and a
reference state |ψ0⟩∈Ha′, followed by ˆU †(ˆΦ) acting on
Hga. Then we can write the decompressed state as:
ˆ˜ρga =
tra′[ ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)ˆρga ⊗|ψ0⟩⟨ψ0|a′ ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)].
(329)
Then the success of the compression is quantiﬁed by the
ﬁdelity between ˆρga and ˆ˜ρga: F(ˆρga, ˆ˜ρga).
An alternative, and for our purposes more convenient,
means to quantify the quality of the encoding begins with
the observation that any information lost during the com-
pression will manifest itself as entropy in the trash regis-
ter after the encoding. Therefore, we can train the algo-
rithm to minimize the entropy in the trash register.
Figure 26. QFB circuit for the regular autoencoder. In the
feedforward step, the parametrized unitary acts on the input
state to be compressed. The loss function is a projector onto
a pure resource state on the trash registers at the output of
the encoding.
or
Figure 27. Reference state exponentiation options. The loss
function in the QFB circuit is a projector onto a pure resource
state |ψ0⟩. The exponentiated projector can be constructed
either through a unitary transformation of the exponentiated
null projector (top), or through state exponentiation using
multiple copies of the resource state (bottom).

62
Here, we will describe two diﬀerent loss functions that
may be used for training. The ﬁrst is based on maxi-
mizing the ﬁdelity of the trash register with the refer-
ence state |ψ0⟩∈Ha. Therefore, in order to enact this,
we will use the projector onto the pure resource state,
|ψ0⟩∈Ha, as the loss function: ˆL = −ˆIg ⊗|ψ0⟩⟨ψ0|a.
Of course, any other pure state would suﬃce, but such a
state can be related to |ψ0⟩via a unitary operator which
can be absorbed into ˆU(ˆΦ). Illustrations of this setup
are provided in Figures 26 and 27.
The eﬀective phase we obtain for this loss function is:
L(ˆΦ) = −trH[|ψ0⟩⟨ψ0|a ˆU(ˆΦ)ˆρga ˆU †(ˆΦ)]
= −F

trg[ ˆU(ˆΦ)ˆρga ˆU †(ˆΦ)], |ψ0⟩⟨ψ0|a

.
(330)
(Note that throughout this section, for convenience of no-
tation, it should be understood that these ﬁdelity func-
tions remain operator-valued since we have not traced
over the Hilbert space of the parameters.) Thus, as de-
sired, the eﬀective phase is the negative ﬁdelity between
the state on the trash registers at the output of the algo-
rithm and the pure reference state.
One can relate this ﬁdelity to the ﬁdelity of reconstruc-
tion in the following manner:
F(ˆρga, ˆ˜ρga) = F

ˆρga, tra′[ ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)ˆρga ⊗|ψ0⟩⟨ψ0|a′ ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)]

= F

ˆU(ˆΦ)ˆρga ˆU †(ˆΦ), tra′[Saa′ ˆU(ˆΦ)ˆρga ⊗|ψ0⟩⟨ψ0|a′ ˆU †(ˆΦ)Saa′]

≤F

trg[ ˆU(ˆΦ)ˆρga ˆU †(ˆΦ)], trga′[Saa′ ˆU(ˆΦ)ˆρga ⊗|ψ0⟩⟨ψ0|a′ ˆU †(ˆΦ)Saa′]

= F

trg[ ˆU(ˆΦ)ˆρga ˆU †(ˆΦ)], |ψ0⟩⟨ψ0|a

.
(331)
Note that in the ﬁrst step of the above calculation, we
can pull the unitary out of the partial trace since ˆU(ˆΦ)
does not act on Ha′. Then we use the unitary invariance
property of the ﬁdelity, i.e., F(ˆρ, ˆU †ˆσ ˆU) = F( ˆU ˆρ ˆU †, ˆσ).
In the second step we use the monotonicity of the ﬁ-
delity under trace preserving operations (e.g., partial
trace): F(ˆρ, ˆσ) ≤F(Λ(ˆρ), Λ(ˆσ)). In the last step we used
the simple fact that: trga′[Saa′ ˆρga ⊗|ψ0⟩⟨ψ0|a′ Saa′] =
|ψ0⟩⟨ψ0|a.
Hence, we see that the algorithm will train to maxi-
mize an upper bound to the reconstruction ﬁdelity. Al-
though maximizing an upper bound does not guarantee
that we are maximizing the reconstruction ﬁdelity, max-
imizing the ﬁdelity of the trash state relative to a pure
reference state will indirectly enforce a maximization of
purity of the trash state. If we consider the entire com-
pression procedure as a channel, i.e., the composition of
enacting the unitary, swapping out the trash state for a
fresh copy, and acting the reverse of the encoder, then
enforcing the purity of the trash state will enforce a null
entropy leakage to the environment.
The coherent in-
formation of this channel [84] will be the maximum over
isometric extensions of the input state of the diﬀerence
between the entropy of the output of the channel minus
the entropy of the environment:
Ic = max
ψ [S(B) −S(E)],
(332)
where the maximization over ψ denotes maximization
over isometric extensions of the input. Thus minimizing
the entropy leakage to the environment will necessarily
increase our coherent mutual information of our channel.
As a proxy for this entropy, we can use the purity as
an alternative loss function for training the quantum au-
toencoder, as it is operationally easier to implement as
a cost function. However, note that one must use the
state of the trash register at the output of the encoding
along with the compressed state in order to later decom-
press the state. By simply maximizing the purity of the
trash registers, and not training the register to map to
a particular state (as before), we will not be able to de-
compress unless we also perform state learning on this
trash state. Thus we see this means of performing the
compression task involves splitting the problem into two
tasks: encoding and state learning. In some cases, this
may prove to be advantageous instead of enforcing a par-
ticular ancilla state on Ha and training a possibly more
complicated encoder, ˆU(ˆΦ). Here, we will proceed to de-
scribe the training of the encoder, and one can use the
methods of Section VI C 2 to learn the state of the ancilla.
In order to accomplish the training using the purity as
a loss function, one must run two copies of the algorithm
in parallel, but which can be trained simultaneously by
"tenting" the weights. We will show that one can ob-
tain the purity of the trash state as an eﬀective phase
by using a swap gate, ˆL = −Saa′, as a loss function. A
means of exponentiating this loss function was described
in Section VI B.
Let us denote the state after the parametrized unitary
by ˆρga(ˆΦ) := ˆU(ˆΦ)ˆρga ˆU †(ˆΦ) and the trash state after
the compression as ˆρa(ˆΦ) := trg ˆρga(ˆΦ) (and similar for
g′ and a′). The eﬀective phase we obtain for the param-

63
eters is:
L(ˆΦ) = −trgag′a′[Saa′ ˆρga(ˆΦ) ⊗ˆρg′a′(ˆΦ)]
= −traa′[Saa′ ˆρa(ˆΦ) ⊗ˆρa′(ˆΦ)]
= −tra[ˆρa(ˆΦ)2],
(333)
i.e., the purity of the trash state at the output of the
autoencoder.
The QFB circuit for this version of the
autoencoder is shown in Figure 28
Figure 28.
QFB circuit for the purity-based autoencoder
training. We run two copies of the feedforward parametrized
unitary, ˆU(ˆΦ), in parallel acting on two copies of the input
state. Both parallel unitaries are controlled by the same pa-
rameter registers. The phase kick is an exponentiated swap
operator applied to the trash registers of the two instances.
After uncomputation, the eﬀective phase on the parameters
is the (negative) purity of the trash registers.
2.
Denoising Quantum Autoencoder
In this section, we will examine a task similar to the
previous. The diﬀerence is that we will assume that the
state we wish to compress has ﬁrst gone through a some
noise channel. The goal here will be to train an autoen-
coder to not only compress, but also denoise the state
after having passed through the noise channel. Ideally,
the network will learn how to ﬁlter noise into the trash
registers, creating a more robust autoencoder.
The algorithm will be trained as follows.
The feed-
forward will consist of applying both the encoding and
decoding maps.
Ideally, we would like this encod-
ing/decoding process to recover the initial state |ψi⟩, i.e.,
after compression and denoising it should recover the
state at the input of the noise channel. Therefore, we
will apply the projector onto this state as a loss function
at the output of the decoder (as opposed to the previous
case), in order to penalize the algorithm if it does not
output the correct state. As before, to employ QFB, the
uncompute will consist of the inverse of the feedforward.
In this case, this inverse is comprised of the encoding,
swap with the ancilla register, and decoding.
More concretely, let us assume that we have multiple
copies of the input states, |ψi⟩, available for the training,
as well as an oracle for the noise channel N. The ﬁrst
step for the training is to send a copy of |ψi⟩through the
noise channel to obtain ˆρ := N(|ψi⟩⟨ψi|). We then pro-
ceed analogously to the previous autoencoder. We apply
a parametrized ansatz for the encoder, ˆU(ˆΦ), acting on
H = Hg⊗Ha (where g indexes the Hilbert space contain-
ing the compressed state and a the trash register). This
is followed by performing a swap operation, Saa′, between
the trash register and a pure resource state |ψ0⟩∈Ha′.
Now, as opposed to the previous case, we ﬁrst apply the
decoding map, ˆU(ˆΦ), before applying the loss function
ˆL = −|ψi⟩⟨ψi|ga on the output. The eﬀective phase we
obtain on the parameters is:
L(ˆΦ) = −trgaa′[|ψi⟩⟨ψi|ga ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)N(|ψi⟩⟨ψi|ga) ⊗|ψ0⟩⟨ψ0|a′ ˆU †(ˆΦ)Saa′ ˆU(ˆΦ)]
= −trga[ˆρga(ˆΦ)ˆ˜ρg(ˆΦ) ⊗|ψ0⟩⟨ψ0|a]
= −trg[⟨ψ0| ˆρga(ˆΦ) |ψ0⟩a ˆ˜ρg(ˆΦ)],
(334)
where we have denoted the noisy input state after the
encoding as ˆ˜ρga(ˆΦ) := ˆU(ˆΦ)N(|ψi⟩⟨ψi|ga) ˆU †(ˆΦ), its par-
tial trace on a as ˆ˜ρg(ˆΦ) := tra[ˆ˜ρga(ˆΦ)], and the noise-
less pure state, |ψi⟩, after the encoding as ˆρga(ˆΦ) :=
ˆU(ˆΦ) |ψi⟩⟨ψi|ga ˆU †(ˆΦ).
Then we see that the eﬀective
phase is the Hilbert-Schmidt inner product between the
encoded noiseless input state with the compressed state
reduced to the g register along with the pure resource
state on the trash register.
An illustration of this procedure is provided in Fig-
ure 29.
3.
Quantum Error Correcting Code Learning
The ﬁnal parametric coding task we will examine is
that of quantum channel coding. The scheme considered
here will ﬁrst involve a parametrized encoding unitary,
ˆU(ˆΦ), which acts on the logical sector of the Hilbert
space, Hl, as well as the syndrome Hilbert space, Hs.

64
Figure 29. Denoising autoencoder. The input states to the de-
noising autoencoder are created from feeding the desired state
through an oracle to the noise channel. The feedforward of
the QFB circuit consists of the entire encoding, swapping out
of the trash registers, and decoding circuit. The loss function
is the input state to the noise channel, whose exponentiation
requires multiple copies.
The output of this encoding then passes through a noise
channel, N. We then apply a parametrized recovery map,
ˆW(ˆΦ), to the output of the channel along with a set of re-
fresh qubits |0⟩∈Hr. This is followed by a decoding map
consisting of the inverse of the encoding unitary, ˆU †(ˆΦ).
The goal is to simultaneously train the parametrized en-
coding and recovery maps to counteract the noise chan-
nel. Hence, we want to train these unitaries so that this
full channel is the identity channel on the logical sector.
Let us denote the full channel by:
Λlsr(ˆΦ) := trsr ◦Ad[ ˆU †
ls(ˆΦ) ˆWlsr(ˆΦ)] ◦Nls ◦Ad[ ˆUls(ˆΦ)],
(335)
where, for convenience, we have included subscripts to
denote the Hilbert space factors that each operator acts
on. Note that we will use the symbol ˆΦ to encompass the
parameters of both the encoder and the recovery map,
although generically these maps would not share any pa-
rameters. Thus, we could decompose ˆΦ = ˆΦU ⊕ˆΦW ,
where ˆΦU are the parameters for ˆU and ˆΦW are the pa-
rameters for ˆW.
Note that this task is essentially the same as the chan-
nel learning task we have described before. As before,
we will describe two means of training the channel. The
ﬁrst is analogous to supervised channel learning, where
the channel is trained on a set of logical input states. The
second is similar to unsupervised channel learning.
In order to perform training, we must have access to an
oracle or an implementation of the noise channel, N (e.g.,
this channel could be learned using the channel learning
techniques described above). Furthermore, to apply the
uncomputation of the channel, we must dilate the noise
map with an auxiliary Hilbert space Hp to a unitary op-
erator. In the following we will not need to refer to this
unitary operator explicitly, but we will assume access to
the dilation for QFB.
Supervised
QEC
Learning.[53] For supervised
learning, one can simply input diﬀerent logical states of
Hl into the channel Λ(ˆΦ), and train the parameters to
learn the identity map. In order to simplify the imple-
mentation of the loss function (as we shall see below),
it will be more convenient to describe the generation of
these logical states as acting unitaries, ˆVl, on some logical
reference state |0⟩∈Hl. For example, if Hl = (C2)⊗k,
then we could choose |0⟩= |0⟩⊗k. These unitaries can be
chosen from a set which forms a unitary 2-design, in or-
der to provide a uniform set of sample data for the input
in the logical space.
Without loss of generality, let us also denote the input
states on Hs and Hr each as |0⟩.
The feedforward for the training algorithm involves
acting ˆVl on the logical input reference state, applying
the channel Λlsr, and then uncomputing the logical op-
erator ˆVl. Since we want to train the channel to learn
the identity on the logical sector, one should choose the
loss function to be (negative) projector onto the logical
input reference state: ˆL = −|0⟩⟨0|l. With this, one can
see that the corresponding eﬀective phase is the ﬁdelity
between the logical state after the channel and the input
logical state:
LV (ˆΦ) = −trl[|0⟩⟨0|l ˆV †
l Λlsr(ˆΦ)[ ˆVl |0⟩⟨0|lsr ˆV †
l ] ˆVl]
= −F(Λlsr(ˆΦ)[ ˆVl |0⟩⟨0|lsr ˆV †
l ], ˆVl |0⟩⟨0|l ˆV †
l )
(336)
where |0⟩lsr ≡|0⟩l ⊗|0⟩s ⊗|0⟩r. As discussed in VI E,
acting an exponential of a projector can be slightly costly
to synthesize into gates. A good alternating to the loss
function ˆL = −|0⟩⟨0|l is to use ˆL ≡−P
k∈l ˆZk. This
loss function shares the same ground state as the projec-
tor but is an operator of higher rank hence provides a
richer error signal for the quantum parameters when the
output is far from correct. Synthesizing exponentials of
such a loss function is more straightforward;
e−iη ˆLj =
O
k∈l
e−iη ˆ
Zk
(337)
which is much easier than synthesizing a single-state pro-
jector.
Now, since we would like to learn the identity chan-
nel for all ˆVl, we could draw these from a unitary 2-
design { ˆVj}N
j=1.
If this were done in parallel (or in a
minibatch) for each element in the 2-design, then if the
eﬀective phases were combined, we would obtain an ef-
fective phase,
¯L(ˆΦ) := 1
N
N
X
j=1
LVj(ˆΦ)
(338)
which would correspond to the (negative) average code
ﬁdelity.
Unsupervised QEC Learning. The unsupervised
version of learning channel codes is more straightforward.
Instead of generating various logical states at the input
using unitaries ˆVl, here we act the channel Λ(ˆΦ) on one

65
of the subsystems of a maximally entangled state |φ+⟩∈
Hl′ ⊗Hl, where Hl′ ∼= Hl is an auxiliary copy of the
logical space.
Since we want to train the algorithm to learn the iden-
tity map on the logical sector, the loss function should
be ˆL = −|φ+⟩⟨φ+|ll′. One can use state exponentiation
or some other means to prepare the exponential of this
state. The eﬀective phase we obtain for this process is:
L(ˆΦ)
= −trl′l[|φ+⟩⟨φ+|l′l Λlsr(ˆΦ)[|φ+⟩⟨φ+|l′l ⊗|0⟩⟨0|sr]]
= −trll′[ˆσIˆσΛ(ˆΦ)],
(339)
where we have denoted ˆσΛ(ˆΦ) := Λlsr(ˆΦ)[|φ+⟩⟨φ+|l′l ⊗
|0⟩⟨0|sr] as the Choi state of the channel from l to l, and
ˆσI = |φ+⟩⟨φ+| as the Choi state of the identity channel.
If we write the eﬀective phase in this manner, we see
that, similar to unsupervised channel learning, it is the
Hilbert-Schmidt inner product between these two Choi
states.
G.
Generative Adversarial Quantum Circuits
1.
Classical Generative Adversarial Networks Review
Generative adversarial networks [11] are a class of net-
works used in classical machine learning which allows
for the generation of new samples from a given dataset,
hence the name generative, by pitting two sub-networks
against each other in an adversarial game. One of these
sub-networks is dubbed the generator, while the other is
dubbed the discriminator. The goal of the generator is
to mimic samples from the given dataset, while the dis-
criminator attempts to discern which datapoints came
from the generator and which came from the dataset.
By progressively training both the discriminator and the
generator, the networks can converge to a Nash equilib-
rium, where the generator is particularly good at gen-
erating convincing samples mimicking the data, and the
discriminator particularly good at ﬁltering out uncon-
vincing samples.
Let us brieﬂy review how to train these classical net-
works. The classical approach is to ﬁrst sample a set of
random noise variables independently from some simple
probability distribution. Typical choices for this proba-
bility distribution would be a Bernoulli distribution for
discrete random variables, or a Gaussian distribution for
continuous random variables. These samples, {rj}j, are
used as random seeds for the generator. That is, they are
the input to the generator network, G, which outputs a
candidate datapoint, G(rj), which is supposed to mimic a
datapoint from the actual dataset, {xj}j. More precisely,
the generator is trained so that the distribution of out-
puts, {G(rj)}j, matches the distribution of the dataset
{xj}j. Before considering how the generator should be
trained, let us discuss how to train the discriminator.
The discriminator network, in the most simple case,
is taken to be a binary classiﬁer (a network with a sin-
gle bit as output). To train the discriminator network,
D, ﬁrst we sample a single Bernoulli random variable
(coin ﬂip), denoted lj ∈{0, 1}. Based on the value of lj
we feed in to the discriminator either a point from the
real dataset, xj, or a fake datapoint from the genera-
tor, G(rj). This datapoint (real or fake) is fed forward
through the discriminator, and the loss at the classiﬁer's
output is some function which is minimized when the dat-
apoint is correctly classiﬁed as originating from either the
real dataset or the generator. There is some ﬂexibility in
the choice of this loss function, and the gradient can be
backpropagated through the discriminator network. (At
this stage only the parameters of the discriminator net-
work are trained, and the generator network parameters
are held ﬁxed.) This process is repeated for a few data
points (each time ﬂipping a coin to decide whether the
input is from the real or fake datasets), and then perform
minibatch gradient descent on the classiﬁer.
After a few iterations of gradient descent on the dis-
criminator's parameters, we can begin to train the gen-
erator network. Training the generator network involves
connecting the output of the generator to the input of
the discriminator, and then maximizing the error of the
discriminator by performing gradient ascent on the pa-
rameters of the generator network (while keeping the pa-
rameters of the discriminator network ﬁxed).
To summarize, we can consider the random bit lj dur-
ing the discriminator training to be the ground truth
label for the real or fake datapoint.
If we denote the
output of the discriminator by oj, then we can frame
the problem as the discriminator trying to enforce cor-
relation, lj ⊕oj = 0, while the generator tries to en-
force anti-correlation, lj ⊕oj = 1 (where ⊕is the binary
exclusive-or/modulo 2 addition). Phrasing the training
in this manner will help formulate the quantum version
of the problem, which we will now consider.
2.
Generative Adversarial Quantum Circuits
Now that we have reviewed how to train a typical clas-
sical Generative Adversarial Network (GAN), we can de-
scribe how to make a quantum parametric circuit equiva-
lent of these GANs, which we call Generative Adversarial
Quantum circuits (GAQs).
Similar to GANs, GAQs can be used to generate sam-
ples from a certain distribution. Since we are considering
quantum data, GAQs will be used to replicate samples
from a distribution of quantum states. The datasets we
consider can be a mixture of pure states or mixed states:
ˆρ =
X
j
pj |ψi
j⟩⟨ψi
j|
or
ˆρ =
X
j
pj ˆρj.
(340)
The goal of the generator will be to mimic states that are
part of this distribution, while the discriminator network

66
will attempt to discern the real quantum states from the
generated ones.
The generator network will be a parametric quantum
circuit which takes in some quantum randomness as in-
put, and outputs candidate quantum states to mimic
samples from the data distribution. We will denote this
generator's parametric circuit as ˆG(ˆΦg), where ˆΦg are
the parameters for the generator. The randomness is pro-
vided in the form of a state, |r⟩ge, where G and E are the
Hilbert spaces of the input to the generator, and the en-
vironment, which is simply the puriﬁcation of this input.
Since there generally can be entanglement across the G-
E bipartition, the input to the network will generally be
a mixed state, ρr ∈B(Hg). We consider the preparation
unitary for the puriﬁed state, |r⟩ge = ˆUr(θ) |0⟩ge, to be
dependent on a set of preparation hyper-parameters, θ.
Hence, we can append these to our preparation hyper-
parameters Θ (which also includes our pointer state
preparation hyper-parameters). Thus, for a given set of
parameters, Φg, the puriﬁed output mixed state of the
generator is given by ˆG(Φg) |r⟩ge. Tracing this over the
environment E gives us the mixed state of samples gen-
erated by the generator, ˆG(Φg)ˆρr ˆG†(Φg), which we will
feed to the discriminator network.
The discriminator is simply a binary quantum classi-
ﬁer, as treated in Subsection VI E, with a parametric cir-
cuit ˆD(ˆΦd) and corresponding parameters Φd. We write
the standard basis Pauli operator of the output regis-
ter to be ˆZo. As a ﬁrst version of the GAQ, for training
the discriminator, we can consider having the the ground
truth label for the iteration j to be a classical random bit
lj. We thus sample a random Bernoulli distribution to
determine lj.
If lj = 1, we perform the QFB on the
discriminator by feeding it a datapoint (quantum state)
sampled from the dataset {ˆρj}j. In the case of lj = 0, we
feed the state output by the generator to perform QFB.
In both cases the loss function is,
ˆL(d)
j
= (−1)lj+1 ˆZo.
(341)
Training the parameters to minimize this loss will move
to positively correlate the output of the discriminator
with the ground truth label lj. The eﬀective phase we get
(on average) for the discriminator parameters (assuming
an unbiased coin ﬂipped for the truth label lj) is
Lj(ˆΦd) = 1
2tr[ ˆD†(ˆΦd) ˆZo ˆD(ˆΦd)ˆρj]
−1
2tr[ ˆD†(ˆΦd) ˆZo ˆD(ˆΦd) ˆG(Φg)ˆρr ˆG†(Φg)].
(342)
(Note that the traces in all of the formulas in this subsec-
tion are understood to be taken over everything except
the parameter Hilbert spaces.) The parameter optimiza-
tion here is only for the discriminator parameters, ˆΦd,
which are quantum and are optimized quantum dynam-
ically. The generator parameters, Φg, can be kept kept
classical (or equivalently in an eigenstate of ˆΦg) in the
case of MoMGrad, or can be kept ﬁxed (no kinetic pulse)
in the case of QDD For concreteness, if we were to train
a few iterations using QDD, the unitary to be applied
would be
ˆUqdd =
Y
j
e−iγj ˆ
Π2
de−iηjLj(ˆΦd),
(343)
where ˆΠd is the vector of canonical conjugate operators
of ˆΦd.
To train the generator network, we connect the gen-
erator directly into the discriminator network, i.e., the
feedforward unitary becomes
ˆU(ˆΦ) = ˆD(ˆΦd) ˆG(ˆΦg),
(344)
which acts upon the input resource quantum random
state |r⟩ge.
The parameters of the adversary network
(discriminator) are ﬁxed, i.e., we can consider the param-
eters registers, ˆΦd, to be classical or to be in an eigen-
state of parameter values. We can perform the Quantum
Feedforward and Phase Kick Baqprop (QFB) procedure
on this joint network with the loss function
ˆL(g)
j
= ˆZo,
(345)
which, when minimized via either of the quantum param-
eter descent techniques, drives the generator's parame-
ters to fool the discriminator. That is, the generator's
weights will be optimized so that, for current discrimi-
nator's parameters, there is an increased chance for the
discriminator to output Zo = 1 when fed the output of
the generator. The eﬀective phase induced on the gener-
ator's parameters via the QFB procedure with this loss
function is given by
Lj(ˆΦg) = tr[ ˆG†(ˆΦg) ˆD†(Φd) ˆZo ˆD(Φd) ˆG(ˆΦg)ˆρr]. (346)
Thus, by alternating the training of discriminator net-
work and the generative network, both networks should
reach an adversarial equilibirum [11], and near this equi-
librium the generator should be able to provide good can-
didate states to mimic the quantum data distribution.
An option to simplify the number of steps involved in
the training algorithm and to train both networks simul-
taneously is to use a qubit for the ground truth label.
With this, we will be able to make the entire algorithm
fully coherent, and we can use the same loss function
for both networks, except that the discriminator will be
trained to descend the loss function landscape while the
generator will be trained to ascend. This setup, which we
will now proceed to describe, is illustrated in Figure 30.
We ﬁrst replace the Bernoulli random variable lj, rep-
resenting the ground truth label for iteration j, with a
qubit beginning in a state of uniform superposition of
two label values, i.e., |+⟩l =
1
√
2(|0⟩l + |1⟩l).
Now, we keep the generator and quantum randomness
seed the same, but the input to the discriminator will be
swapped in based on the computational value of the label
qubit. That is, we use the label qubit as the control for

67
both a Fredkin (controlled-SWAP) gate and a negated
Fredkin gate (i.e., a Fredkin gate conjugated by qubit
ﬂips ˆXl), as depicted in Figure 30.
The ﬁrst of these
will be used to swap in a sample from the real data set,
ˆρj, in the branch of the superposition of the label qubit
corresponding to |1⟩l. The second will swap in the output
of the generator network (which, along with the quantum
randomness seed will remain the same as in the non-
coherent version of the network). With this setup, we
can phase kick the entire network at the output of the
discriminator network with the loss function,
ˆLj = −ˆZl ⊗ˆZo,
(347)
where ˆZl is the Pauli-Z operator for the label qubit, and
ˆZo is the Pauli-Z operator for the output classiﬁer of the
discriminator circuit. Thus, this cost function is mini-
mized when the output of the discriminator is positively
correlated with the ground truth label. Hence, the train-
ing of the discriminator will aim to minimize this loss,
whereas the training of the generator will aim to maxi-
mize it.
First, let us consider the eﬀective phase, which can be
shown to recover the formula from before,
Lj(ˆΦ) = 1
2tr[ ˆD†(ˆΦd) ˆZo ˆD(ˆΦd)ˆρj]
−1
2tr[ ˆD†(ˆΦd) ˆZo ˆD(ˆΦd) ˆG(ˆΦg)ˆρr ˆG†(ˆΦg)].
(348)
For training the parameters of the discriminator, one can
employ either MoMGrad or QDD as in other situations
we have considered. For the parameters of the generator,
since we want to ascend the average landscape of this ef-
fective phase, we can act a squared Fourier transform on
the parameters of the generator, denoted ˆ
F 2
g , before and
after the kinetic term of QDD, or before the measure-
ment of the parameters in the case of MoMGrad. The
squared Fourier transform acts eﬀectively as a NOT gate
on the parameter registers, and hence will act to update
the parameters in the opposite direction as we have seen
before. Concretely, if we were to perform QDD for this
network, we would enact
ˆUqdd =
Y
j∈M
ˆ
F †2
g e−iγj ˆ
Π2 ˆ
F 2
g e−iηjLj(ˆΦ),
(349)
where ˆΠ2 = ˆΠ2
g ⊗ˆΠ2
d is the kinetic term for all regis-
ters, while ˆ
F 2
g is the squared Fourier transform in each
of the generator's registers.
Thus, negating the phase
kick eﬀectively forces the generator network to ascend
the cost function rather than descend, which will drive
the generator network to anti-correlate the output of the
discriminator with the ground truth. Note that, in prac-
tice, although we used the same kicking and kinetic rates
for both the generator's and discrimnator's parameters
in (349), it might be best to use diﬀerent rates for both
networks as attaining the adversarial equilibrium may re-
quire some hyper-parameter ﬁne-tuning.
Figure 30. QFB procedure for the fully coherent Generative Adversarial Quantum circuit. The input to the parameter-controlled
discriminator, ˆD(ˆΦd), is swapped in from either the real data set, with sample ˆρj, or from the output of the generator network,
ˆG(ˆΦg).
The determination of which sample to swap in is controlled by a label qubit in the state |+⟩.
The sample ˆρj is
connected to the discriminator input via a controlled-SWAP (CSWAP) gate with the label qubit as the control. The output of
the generator network is connected to the discriminator input via a negated CSWAP gate (the negation is depicted by a white
circle in the control register). The phase kick is applied with the loss function acting on the output of the discriminator and
the label qubit. The phase kick is followed by an uncomputation of the entire feedforward circuit as prescribed by the QFB
procedure.

68
H.
Parametric Hamiltonian Optimization
Parametric Hamiltonian optimization algorithms con-
sist of a broad class of algorithms [29, 39] where the goal is
to optimize over a parametrized hypothesis class of states
in order to minimize the expectation value of a certain
Hamiltonian, ˆH. That is, if we denote the parametrized
class of states as |ψ(Φ)⟩, then we want to ﬁnd
argmin
Φ
⟨ψ(Φ)| ˆH |ψ(Φ)⟩.
(350)
Such algorithms includes the Variational Quantum
Eigensolver (VQE) [29],
which is used to ﬁnd ap-
proximate eigenstates of non-commuting Hamiltonians
in chemistry, the Quantum Approximate Optimization
Algorithm (QAOA) [39], which is used for quantum-
enhanced optimization, as well as other parametric cir-
cuit ansatze like the Deep Multiscale Entanglement
Renormalization Ansatz (DMERA) [85], which is a
hierarchically-structured ansatz which allows for sam-
pling statistics of local observables in strongly-correlated
quantum systems.
Such an optimization problem ﬁts very naturally
within the framework introduced in this paper. In our
case, we consider the optimization over the hypothesis
class of states as the task of optimizing of a class of quan-
tum parametric circuits acting upon a reference state:
|ψ(Φ)⟩= ˆU(Φ) |ψ0⟩. Then we can simply use the Hamil-
tonian as the loss function we wish to minimize:
ˆL = ˆH.
(351)
The main challenge with the implementation of a general
Hamiltonian as a loss function is to construct its expo-
nentiation, i.e., enacting the operator
e−iη ˆL = e−iη ˆ
H.
(352)
For a Hamiltonian which is a sum of various terms of
index X,
ˆH =
X
j∈X
ˆHj,
(353)
the task of exponentiating such a Hamiltonian is the same
as that of quantum simulation of the time evolution gen-
erated by this Hamiltonian [86]. This is a task for which
there is much literature, as it is a core concept of quantum
computing [55]. There exist many techniques to approx-
imate such an exponential, and for a given desired oper-
ator norm error, the overhead will depend on the locality
and operator norms of the Hamiltonian terms [86]. A the-
oretically simple approach is the Suzuki-Trotter method,
which is a divide-and-conquer method where each term
is exponentiated independently,
e−iη ˆ
H ≈(
Y
j∈X
e−iη ˆ
Hj/M)M.
(354)
The operator norm error ϵ in this approximation [86, 87]
is ϵ = η2 P
j,k∈X ∥[ ˆHj, ˆHk]∥/2M + O(η3). Therefore, as
long as we choose M ∼P
j,k∈X ∥[ ˆHj, ˆHk]∥, we have an
error of order ϵ ∼O(η2).
Now, for the QFB procedure, if we begin in a reference
state |ψ0⟩, apply the parametric unitary ˆU(ˆΦ), apply a
quantum simulated exponential of ˆH (with error ϵ), fol-
lowed by an uncomputation of the parametric unitary,
then we arrive at the eﬀective phase kick on the param-
eters generated by,
L(ˆΦ) = ⟨ψ0| ˆU †(ˆΦ) ˆH ˆU(ˆΦ) |ψ0⟩,
(355)
up to an error of order O(ϵ).
Recall that, in general,
the eﬀective phase kick is only accurate to ﬁrst order
in η, i.e., it has an error of order O(η2). Hence a ﬁrst
order Suzuki-Trotter formula as in equation (354) should
suﬃce.
The circuit to implement the Quantum Feedforward
and Baqprop (QFB) on a single QPU is simple, pictured
in Figure 31. Note that the implementation of the ex-
ponential of the Hamiltonian can come with large depth
overhead, thus it may be convenient to have a method
with higher space overhead but with lower depth, i.e., a
way to parallelize the accumulation of the gradient over
the terms in the Hamiltonian. We discuss this in the next
subsubsection.
Figure 31. QFB circuit for Parametric Hamiltonian Optimiza-
tion in the case of a single QPU. The circuit simply consists of
a feedforward of the parametric unitary acting on a reference
state, followed by the simulated Hamiltonian exponentiation
as a phase kick and the uncomputation.
1.
Hamiltonian-Parallelized Gradient Accumulation
Here we discuss various methods to parallelize the ac-
cumulation of phase kicks and gradients in order to re-
duce circuit depth (time) overhead, at the cost of higher
space overhead. Notice that since the eﬀective phase from
above is an expectation value, it is linear and can be split
up over the terms of the Hamiltonian:
L(ˆΦ) = ⟨ψ0| ˆU †(ˆΦ) ˆH ˆU(ˆΦ) |ψ0⟩
=
X
j∈X
⟨ψ0| ˆU †(ˆΦ) ˆHj ˆU(ˆΦ) |ψ0⟩.
(356)
This trick is the fundamental principle behind the Quan-
tum Expectation Estimation algorithm [48], which paral-

69
lelizes the expectation values of each term in the Hamilto-
nian over diﬀerent QPUs/runs. Recall that in our case we
are looking to obtain a gradient of these eﬀective phases
(which are expectation values). Since the gradient is a
linear operator, we can accumulate the gradient of the
sum by the sum of the gradients.
Operationally, by using multiple sets of parameter reg-
isters, {ˆΦ[j]}j∈X , and dividing up the terms in the Hamil-
tonian into individual loss functions over diﬀerent QPUs,
we can classically parallelize the accumulation of gra-
dients, i.e., using classical addition we can sum up the
gradient contribution of each term.
We call this ap-
proach Gradient Expectation Estimation Parallelization
(GEEP), which is technique mostly relevant to Momen-
tum Measurement Gradient Descent (MoMGrad), since
the gradient has to be measured to be stored as classi-
cal information. Mathematically, by acting a QFB with
a loss ˆL[j] = ˆHj on each replica, we get the following
eﬀective QFB phase on replica j:
Lj(ˆΦ[j]) = ⟨ψ0| ˆLj(ˆΦ[j]) |ψ0⟩
= ⟨ψ0| ˆU †(ˆΦ[j]) ˆHj ˆU(ˆΦ[j]) |ψ0⟩.
(357)
Thus, to ﬁrst order in η, the eﬀective phase kick is
e−iηLj(ˆΦ[j]) on each of the parameter sets.
The corre-
sponding shift in momenta of each set of parameters is
ˆΠ[j]
7→
eiηLj(ˆΦ[j]) ˆΠ[j]e−iηLj(ˆΦ[j]) + O(η2)
= ˆΠ[j] −η ∂Lj(ˆΦ[j])
∂ˆΦ[j]
+ O(η2).
(358)
Therefore, by preparing identical momentum pointer
states (cenetered at zero momentum) in each of the pa-
rameter registers of the replicas, i.e., |Ψ0⟩⊗|X| for some
pointer state |Ψ0⟩, and by classically summing up the
expectation values of the momenta in each replica, we
have
X
j∈X
⟨ˆΠ[j]⟩[j] = −η
X
j∈X
[j]⟨Ψ0| ∂Lj(ˆΦ[j])
∂ˆΦ[j]
|Ψ0⟩[j] + O(η2)
= −η ⟨Ψ0|
X
j∈X
∂Lj(ˆΦ)
∂ˆΦ
|Ψ0⟩+ O(η2)
= −η ⟨Ψ0|
∂(P
j∈X Lj(ˆΦ))
∂ˆΦ
|Ψ0⟩+ O(η2)
= −η ⟨Ψ0| ∂L(ˆΦ)
∂ˆΦ
|Ψ0⟩+ O(η2).
(359)
Thus we see that by classically adding up the expectation
values of the momenta in each replica, we get the gradient
of the total loss function as if it were applied on a single
replica. We present the quantum-classical circuit for this
GEEP procedure with MoMGrad in Figure 32.
To apply a similar parallelization which is applicable to
Quantum Dynamical Descent, the accumulation of mo-
menta must be done coherently. For this purpose, we can
Figure 32.
MoMGrad + GEEP: Momentum Measurement
Gradient Descent iteration via Gradient Expectation Estima-
tion Parallelization.
The parameter pointer states in each
replica are prepared using a unitary ˆUp(Θ). The QFB circuit
is applied in each replica, with each parametrized unitary con-
trolled by the corresponding replica parameters and the phase
kick generated by the corresponding term in the Hamiltonian.
The shift in the momenta of the parameters in each replica
are measured, and after many runs the expectation values are
classically added to obtain an averaged gradient of the total
loss function.
use the technique of Coherent Accumulation of Momenta
Parallelization (CAMP) introduced in Section IV A 3.
The point is that we can consider the diﬀerent terms in
the Hamiltonian to be analogous to datapoints in a batch,
whose loss functions are exponentiated and coherently
accumulated to attain a total loss function comprised of
the sum of losses of each term. Once again denoting the
loss function for each Hamiltonian term as ˆL[j] = ˆHj,
and the associated eﬀective phase for each replica as in
(357), we can apply the following unitary for parallelized
Hamiltonian Quantum Dynamical Descent:
ˆUpqdd =
Y
k
e−iγk ˆ
Π2
[0]U †
tent
 O
j
e−iηkLj(ˆΦ[j])
ˆUtent
=
Y
k
e−iγk ˆ
Π2
[0] ˆUcamp,k,
(360)
where k is an index for the iterations. Recall that the
TENT unitary is simply a multi-target adder gate, as
deﬁned in equation (124). Also note that in the above
equation (360), the phase kicking rate is ηk in each replica
whereas previously in (129) it is normalized by the mini-
batch size. Finally, this unitary is applied on an initial
state where the parameter server (replica of index 0, with
parameters ˆΦ[0]) is in a pointer state of choice and the
replicas are initialized in a null-parameter eigenstate, i.e.,
|Ψ0⟩[0]
O
j
|0⟩[j] .
(361)
We represent the circuit for an iteration of Quantum
Dynamical Descent with Coherent Accumulation of Mo-
menta Parallelization for the Hamiltonian Optimization
task in Figure 33.

70
Figure 33. QDD + CAMP for Parametric Hamiltonian Op-
timization. The parameter server is initialized to a pointer
state using ˆUp(Θ), and this is distributed to the replicas us-
ing the TENT operation. The QFB circuit is applied to each
replica, with each parametrized unitary controlled by the cor-
responding replica parameters and the phase kick generated
by the corresponding term in the Hamiltonian. The inverse
TENT operation is applied after the QFB circuits to accumu-
late the phase kicks in the parameter server as a phase kick
according to the total loss function. The standard QDD ki-
netic pulse is then applied to the parameter server at the end
of the iteration.
I.
Hybrid Quantum Neural-Circuit Networks
The method for regression/classiﬁcation using quan-
tum parametric circuits, outlined in Subsection VI E, is
eﬀectively a method for learning a quantum-to-classical
map.
One could then imagine having a classical neu-
ral network taking in this signal to perform some further
processing. More generally, one may wish to perform fur-
ther processing on the outcomes of the measurement of
some observable at the output of a general parametrized
quantum circuit. Further, the methods we describe here
will, in principle, also apply to a general parametrized
classical circuit, although we will focus on neural net-
works for concreteness. The challenge examined here is
to eﬃciently train both the quantum and classical parts
of the hybrid network in unison.
In this section we focus on methods to backpropagate
error signals through such a quantum-classical interface,
i.e., how to train networks which are hybrids of quan-
tum parametric circuits connected to classical neural net-
works. We consider two cases, ﬁrst is to embed the clas-
sical neural network into a quantum computation, i.e.,
both parts for the network are trained on a Quantum
Processing Unit (QPU).
In the second case, we have the classical neural net-
work being trained on a Classical Processing Unit (CPU),
which is connected to a QPU on which the Quantum
Parametric Circuit is being trained.
We propose two
methods for simultaneous quantum-classical training, in
both cases we propose a way to backpropagate the error
signal through the quantum-classical boundary.
The ﬁrst of these latter methods depends only on ex-
pectation values of the observables of the quantum out-
put registers, which are used as input activations for the
neural network.
Using classical feedforward and back-
propagation of gradients, we can approximate the error
signal as a linear potential centered around this expec-
tation value, and enact a linear relative phase kick on
the quantum system (momentum kick) to convert this
approximate error signal back to quantum.
The second method follows a similar philosophy, but
allows for a more non-trivial error signal tomography,
hence a higher-order approximation to the error signal.
The approach relies on sampling various measurement
results from the output of the parametric circuit and
feeding these through the classical neural network. For
each sample point, a gradient is obtained through classi-
cal feedforward and backpropagation. For sample points
that are relatively close to each other (low variance of
output from quantum regression net), a higher order in-
terpolation of the eﬀective backpropagated cost function
can be obtained. This can then be applied as a higher-
order phase kick on the quantum network, which can then
be leveraged by the usual quantum phase kick backprop-
agation method for MoMGrad.
1.
Fully Coherent Hybrid Networks
To begin, let us examine the case where both the
quantum-parametrized circuit (QPC) and the classical
neural network (NN) are trained on a QPU. This setup
simply involves connecting one of the neural nets from
Section V to the output of the QPC. The presence of
both the QPC and NN on the quantum chip allows one
to use QFB in a straightforward manner. Of course, once
the QPC and NN have been trained on the QPU, there
is an option to do inference with the NN on a CPU.
Although, in essence, using QFB in this situation is
similar to before, it will be worth describing explicitly
in order to compare to the subsequent cases.
Let us
write ˆUqpc(ˆΦ) as the quantum-parametric circuit, where
ˆΦ are the parameters of the circuit. We will also write
˜y = f(θ, x) as the prediction at the output of the classical
parametric circuit (i.e., the NN) with parameters θ and
input x. Once embedded in a quantum chip, the input ˆx
and parameters ˆθ are quantum. As in Section V, the cir-
cuit for the feedforward in the NN is ˆUff(ˆθ) = e−if(ˆθ,ˆx)ˆp˜y,
where ˆ˜y denotes the output register of the network (pre-
diction) and ˆp˜y its conjugate momentum. Recall also that
the QFB circuit for the NN is e−iη ˆL(ˆ˜y+f(ˆθ,ˆx),y). The full
QFB for the QPC and NN involves the feedforward of
the QPC¡ followed in turn by the feedforward of the NN,
phase kick for the output of the NN, backpropagation
for the NN, and ﬁnally backpropagation for the QPC.
We will ﬁnd it illustrative to absorb the middle three
steps as simply the QFB circuit for the NN alone:
ˆU †
qpc(ˆΦ)e−iη ˆL(ˆ˜y+f(ˆθ,ˆx),y) ˆUqpc(ˆΦ).
(362)

71
In this way, we can abstract away the entire NN, so that
insofar as the QPC is concerned, the QFB of the NN ap-
pears as a phase kick on the momentum of the observable
ˆx at the output of the QPC.
In the following, we will discuss cases where the NN is
implemented on a CPU, so that θ are classical NN pa-
rameters. The tasks that remain are to ﬁnd an appropri-
ate replacement for the input to the classical network, x,
determined from the output of the quantum-parametric
circuit, as well as a means of employing the notion of
backpropagation at the quantum-classical interface.
2.
Hybrid Quantum-Classical Networks
To obtain a classical number from the output of the
QPC, one has to perform a measurement. In the case
of classiﬁcation or regression, this could correspond to a
generalized measurement. However, a generalized mea-
surement can always be seen as a projective measurement
on a larger system. Thus, without loss of generality, we
will deﬁne an observable ˆz at the output of the QPC as
an operator whose spectrum consists of some encoding of
the measurement outcomes.
After declaring such an observable, we need to decide
how to use outcomes of measurements of ˆz to feed into
the classical circuit. That is, if we again write the output
of the classical circuit as f(θ, x), then we will describe
some choices of maps from measurements of ˆz to values
of x. For example, the ﬁrst map we will examine is the
expectation value: x = ⟨ˆz⟩. The second map we will dis-
cuss will be able to accommodate some variance in the
variable ˆz. However, simultaneously training a quantum
circuit combined with a classical network will typically
only work well if the uncertainty in the QPC parame-
ters, ˆΦ, is low (i.e., when their distributions are highly
concentrated close to their expectation values).
Once we have chosen such a map, we can feedforward
the input through the network, and perform classical
backpropagation to obtain ∂f(θ, x)/∂x.
In the previ-
ous case, where the QPC and NN were both placed on
the QPU, we saw that QFB involved feeding forward the
QPC, and applying the phase kick
e−iη ˆL(f(ˆθ,ˆz),y),
(363)
followed by uncomputing the QPC. Note that in this for-
mula we have removed ˆ˜y, since we will assume that the
register for ˆ˜y is initialized to zero and none of the other
circuit elements act on the output register of the NN
embedded in the QPU. Below we will discuss analogues
of the QFB for the NN constructed from the gradients,
∂f(θ, x)/∂x, obtained form the classical backpropaga-
tion in order to obtain a means of propagating the error
from the classical network as a phase kick on the output
of the quantum circuit.
First-order method. The simplest means of map-
ping the observable ˆz at the output of the QPC to a
classical input is to assign x = ⟨ˆz⟩:= tr[ ˆU †(ˆΦ)ˆz ˆU(ˆΦ)ˆρ0].
Note the trace is taken over the computational Hilbert
space as well as the Hilbert space of the parameters ˆΦ.
In practice, this expectation value is obtained from mea-
suring ˆz over multiple runs of the QPC.
With this assignment to x, one can feedforward the
input to obtain the output of the network, f(θ, x),
and backpropagate the loss function to obtain a gra-
dient of the loss function with respect to the input:
[∂L(f(θ, x), y)/∂x]|x=⟨ˆz⟩. This gradient can be used to
approximate the QPU version of the phase when the vari-
ance of ˆz is small, since we can then write
L(f(θ, ˆz), y) ≈L(f(θ, ⟨ˆz⟩), y)
+ (ˆz −⟨ˆz⟩) · ∂L(f(θ, x), y)
∂x

x=⟨ˆz⟩
.
(364)
Note that when exponentiated, the c-number terms in
this expression simply give global phases to the wave-
function. Therefore, the phase kick we should apply at
the output of the QPC to backpropagate the error of
the classical network consists of a linear phase shift. In
summary, once we have the backpropagation of the clas-
sical network to the input, we can write the QFB for the
quantum-parametric circuit as
ˆU †
qpc(ˆΦ)e−iηˆz·[ ∂L(f(θ,x),y)/∂x|x=⟨ˆ
z⟩] ˆUqpc(ˆΦ).
(365)
As the gradients for the classical network have already
been backpropagated, the classical part of the network
can simply be trained using these classically backprop-
agated gradients, using gradient descent or any other
choice classical gradient-based based optimizer [61, 62].
This method requires relatively low-depth circuits, and
only depends on easily-measured expectation values. Al-
gorithms of low-depth which depend on simple expecta-
tion values have shown to be suﬃciently robust to noise
for successful implementation on near-term devices [46],
as such, we expect that this algorithm should be imple-
mentable on near-term devices.
An illustration of this ﬁrst-order method for training
hybrid quantum-classical networks is shown in Figure 34.
Higher-order method. Instead of inputting the ex-
pectation value ⟨ˆz⟩into the classical network, here we
will input a sample for the outcome of a measurement of
ˆz, i.e., we draw a sample point, z∗, from the distribu-
tion p(z) = tr[|z⟩⟨z| ˆU(ˆΦ)ˆρ0 ˆU †(ˆΦ)]. Now, if we perform
backpropagation on the classical network back to the in-
put, we obtain a gradient:
g(z∗) := ∂L(f(θ, x), y)
∂x

x=z∗.
(366)
We can repeat this for multiple samples, {z∗
i }N
i=1, in
order to collect multiple gradients, {g(z∗
i )}N
i=1. Now the
idea is to use this collection of gradients in an interpola-
tion scheme to obtain an approximation to the quantum

72
Figure 34. Concurrent training of a hybrid quantum-classical
network using a ﬁrst-order method. The upper-left diagram
shows the feedforward of a parametric quantum classiﬁer upon
input state ˆρj and auxiliary reference state |ψ0⟩. Measure-
ments are performed for multiple runs of the feedforward (on
input ˆρj) to obtain the expectation value ⟨ˆz⟩j. This expec-
tation value is fed into the classical neural network (top-
right), where classical feedforward and backpropagation is
performed to obtain the gradient of the loss function at the
output of the classical network with respect to the input,
gj := ∂xL(f(θ, x), yj)|x=xj. The gradient, gj, is then used
to employ a phase kick, exp(−iηgj · ˆz), in the MoMGrad pro-
cedure for the parametric quantum circuit on the QPU (bot-
tom).
phase kick,
G(ˆz, {g(z∗
i )}N
i=1) ≈L(f(θ, ˆz), y).
(367)
For example, if the sample points happen to be near one
another, one could try to reconstruct a second-order Tay-
lor approximation to the function L. Otherwise, if the
sample points are too far apart, one could use a diﬀer-
ent interpolation scheme. After making a choice for the
function G, one can write the QFB circuit for the QPC
as:
ˆU †
qpc(ˆΦ)e−iηG(ˆz,{g(z∗
i )}N
i=1) ˆUqpc(ˆΦ).
(368)
VII.
NUMERICAL EXPERIMENTS
In this section we demonstrate the capabilities of the
heuristics proposed in sections III by implementing these
methods to optimize various quantum neural networks
and quantum parametric circuits. We compare the per-
formance of Quantum Dynamical Descent (QDD) ver-
sus Momentum Measurement Gradient Descent (MoM-
Grad). We begin with the training of a classical deep
neural networks on a quantum computer to demonstrate
how the algorithm performs for classical computation
embedded in quantum computation. Following this, we
show how QDD and MoMGrad can leveraged to enhance
quantum Hamiltonian optimization algorithms, we use
the Quantum Alternating Operator Ansatz parametric
circuit as our example. To show how the heuristics deal
with loss operators that are not Hamiltonian-based, but
rather state-based, we show how one can perform gradi-
ent ascent on the ﬁdelity in order to learn a parametric
circuit approximating a unitary.
Finally, to show how
Quantum Phase Backpropagation interfaces with classi-
cal backprop, we demonstrate the training of a hybrid
network on a simulated quantum computer running a
quantum parametric circuit connected to a classical neu-
ral network running on a classical processor.
All the experiments featured in this section were clas-
sical numerical simulations of quantum computation,
which were on the Rigetti Forest Quantum Virtual Ma-
chine, with code written in PyQuil [88].
A.
Quantum Neural Deep Learning
In this subsection we train a classical deep neural net-
work y embedding it into a quantum computation in or-
der to leverage MoMGrad and QDD.
In order to demonstrate the capabilities of the quan-
tum descent algorithms of section III to train a deep neu-
ral network, we chose a problem which is a non-linearly
separable classiﬁcation task.
Due to being one of the
most elementary canonical counter-example to the learn-
ing capabilities of single-layer networks, we chose the task
of learning the exclusive-or (XOR) Boolean function us-
ing a 2-layered perceptron network.
Learning a set of
optimal parameters which minimize the loss for this clas-
siﬁcation task counts as deep learning, since it requires a
neural network of depth at least 2.
1.
Application & Methods
Recall the XOR function (denoted ⊕) takes binary
pairs of bits and maps them {b1, b2} ∈Z2 ×Z2 and maps
them to a single binary value corresponding to their ad-
dition modulo 2; b1 ⊕b2 ≡(b1 + b2)(mod 2).
In order to learn this function, we then have to use a
neural network which has 2 input units and 1 output unit.
The particular network chosen for the implementation in
this paper is pictured in ﬁgure 35.
This network has
an input layer, a single hidden layer, and one neuron
constituting the output layer.
In order to encode this network on the quantum sim-
ulator, we use ﬁnite-dimensional qudits for each neuron,
weight and bias.
In terms of notation, we denote the
qudit standard basis position operators of the neurons
as ˆaℓ,jℓfor the jth
ℓ
neuron of the ℓth layer,
ˆ
Wℓis the
matrix of operators corresponding to the weight param-
eters for the ℓth layer, and ˆbℓis the vector of operators

73
corresponding to the bias parameters for the ℓth layer's
neurons.
For simplicity, we use a simulated Rectiﬁed Linear Unit
(RELU) activation function, as it is standard in modern
classical deep learning. Instead of using separate qudit
registers for the input acumulation of the neuron and the
activation value of this neuron's input, we perform the
activation in-situ, by using a modiﬁed position operator
projected onto its positive values as the generator of shifts
(see ﬁgure 36).
Figure 35. Neural network used for learning the XOR func-
tion.
Input neurons and output layers' neurons are black,
hidden layer neurons are white, while the quantum weights
and biases are represented with white dots. Both the hidden
layer and output layer have biases.
Let us describe more explicitly the circuit that was
applied in order to train the network from ﬁgure 35. The
QFB circuit which was applied is represented in ﬁgure
36. The input and output data registers were kept as
classical controls in order to save memory space for the
simulation.
The parametric unitary for the ﬁrst layer
feedforward was
ˆU (1)( ˆ
W1,ˆb1) =
Y
j,k∈{0,1}
e−ixm,j ˆ
W1,jk ˆpa1,k e−iˆb1,k ˆpa1,k
(369)
where here the xm ∈Z2
2 are the possible input data
points. This is simply the addition of the weight values
conditioned on the input bit values, and the addition
of the bias values onto the second layer's neurons. The
feedforward operation for the following layer is given by
ˆU (2)( ˆ
W2,ˆb2) =
Y
j∈{0,1}
e−iˆs1,j ˆ
W2,j ˆpa2e−iˆb2 ˆpa2
(370)
where ˆs is a neuron's activation value, which is the
quadrature value projected onto the positive values;
ˆs1,j ≡ˆP ˆa1,j ˆP,
ˆP ≡
X
a≥0
|a⟩⟨a|
(371)
which is an operator which assigns the ReLU eigenvalue
to the neuron's input; eﬀectively
ˆs1,j = σ(ˆa1,j),
σ(x) =
(
x,
x > 0
0,
x < 0 .
(372)
To synthesize this operation, an ancilla qubit would nor-
mally be necessary, the above option was implemented
in order to reduce the eﬀective dimension of the Hilbert
space and reduce memory overhead during simulation.
Now, after the feedforward of both layers has been ap-
plied, we apply a phase kick according to the following
cost function,
( ˆPa2 −yj ˆIa2)2 = ˆPa2 + yj ˆIa2 −2yj ˆPa2
(373)
where yj ∈Z2 is the classical data bit desired output.
The above cost function forces the output activation to
be positive to indicate a value 1 versus being nonpositive
for the output 0; in other words the above loss foces the
network to encode the XOR value of the inputs into the
eigenvalue of the obersvable ˆP, which is the projector
onto the positive value qudit states of the output. One
could consider the ˆP as a step function activation oper-
ator for the output. For the full Quantum Feedforward
and Baqprop circuit that was applied, see ﬁgure 36.
2.
Implementation & Results
In this section we present neural network training re-
sults from leveraging Momentum Measurement Gradi-
ent Descent (MoMGrad) and Quantum Dynamical De-
scent (QDD) to train the neural network from ﬁgure 35
to learn the classical XOR function. We use the Quan-
tum Feedforward and Baqprop circuit presented in ﬁgure
36 in order to query the eﬀective phase on the parame-
ters for the cost function. The parameters, neurons, and
bias registers were all chosen to be qudits of dimension
7 in the simulation. The parameters to be optimized via
MoMGrad/QDD are the the weights and biases; in the
notation of section III, ˆΦ = { ˆ
W ,ˆb}.
In ﬁgure 37, we show the cross-entropy (Kullback-
Leibler divergence [1] ) between the desired output bit
value and the value obtained through the feedforward.
We consider any output of postive eigenvalue of the out-
put's position quadrature as a 1, and any nonpositive
value as 0 (eﬀectively like a step function activation).
In both the QDD and MoMGrad cases, we begin with
Gaussian wavefunctions for the quantum parameters ˆΦ.
In terms of hyper-parameters, the initial means of the
Gaussian wavefunctions; the components of Φ0, were
sampled randomly from a classical Gaussian distribution
of mean 0 and standard deviation 0.5, while all the mo-
menta hyper-parameters Π0 were initialized at 0.
In the case of training via QDD, the initial standard
deviation of the Gaussian wavefunction was chosen to be
Σ0 = 1 for all parameters in the case of QDD, the kicking
rate was kept at a constant ηj = 0.5 ∀j and the kinetic
rate for iteration j was adjusted as γj = 0.5 −0.1⌊j/5⌋.
For the MoMGrad case this standard deviation of the
Gaussian pointer state was adjusted at each iteration as
Σ(j)
0
= 0.95j for the jth iteration, the kicking rate held
constant at ηj = 0.5 and kinetic rate held at γj = 1 for
all iterations.

74
Figure 36.
Quantum Feedforward and Baqprop circuit for
the Neural Network tasked with learning the XOR function.
Refer to ﬁgure 35 for a schematic of the neural network ar-
chitecture. The data are input-output pairs {xj, yj} where
xj ∈Z2
2 and yj = (xj,0 ⊕xj,1) ∈Z2. The solid lines are qu-
dits (simulated qumodes), while classical registers are classical
bits. The legend for the diagram is boxed below the circuit,
in which c ∈Z2 represents an arbitrary bit, ˆP ≡P
x≥0 |x⟩⟨x|
is the projector onto the qudit's positive-position states, and
ˆs ≡ˆP ˆx ˆP is the position operator projected onto the posi-
tive states; akin to a RELU operator. Note the controlled-
shifts with a [−] are the Hermitian conjugate of their respec-
tive counterpart with a [+], since they serve to uncompute
the feedforward orperations. The loss function is the squared
diﬀerence between the desired bit value and the truth value
whether the output activation's is positive of not; we thus
read out any output activation of positive value as 1 and any
of negative value as 0.
In ﬁgure 38 we show the decision boundary when con-
sidering a continuous input as opposed to simply bi-
nary. For a given continuously valued input in the range
[−0.5, 1.5] × [−0.5, 1.5], we show the domain where the
output is postitive (hence would be decided correspond-
ing to an output 1), versus where the output is negative.
We see that there is a striped domain characteristic of the
non-linear separability of this domain. The QDD seems
to have a tighter interval around the two points of XOR
value 0. Due to our choice of cost function and due to
feeding only binary data points, there was no incentive
for the network to ﬁnd an optimal hyperplane separating
the inputs into the 0 and 1 classes. For the desired do-
main the neural network was trained for, binary inputs
and output, the network performs the correct classiﬁca-
tion.
0
5
10
15
20
Epoch
0.0
0.5
1.0
1.5
Cross Entropy
MoMGrad
QDD
Figure 37. Plot of the cross entropy between the neural net-
works output and the XOR of the input, at various iterations.
The above is the average loss for 3 separate runs at each it-
eration index, for both training via MoMGrad and QDD.
0
0
1
1
0
0
1
1
a)
b)
Class 0
Class 1
Figure 38. XOR Quantum neural network learning decision
boundary obtained from numerical quantum simulations, left
(a) is via MoMGrad, right (b) is via QDD. The decision
boundary was obtained by feeding a continuum of values
in the input qudits, and observing the value of the output.
For a positive-valued output, the corresponding decision is 1,
whereas a nonpositive output is considered as 0. We see that
both the QDD and MoMGrad correctly classiﬁed the output
of the XOR.
B.
Quantum Parametric Hamiltonian Optimization
As mentioned in section VI H, there exists multiple
possible applications of Parametric Hamiltonian Opti-
mization we could chose to implement.
We choose to
focus our numerical experiments on the QAOA, since we
have established in section IV D that the meta-learning
problem is technically a QAOA-class problem. Given the
large overheads of simulation of many parameters on a
classical computer, testing the meta-learning directly for
an interesting problem size would be intractable, hence
by simply showing that our quantum-enhanced parame-
ter optimization methods work for an instance of QAOA,
we can thereby verify that it would work for a meta-
learning problem.
In terms of speciﬁc QAOA implementation, we look at

75
the canonical application of QAOA, i.e., applied to the
optimization problem corresponding to ﬁnding the Max-
imum Cut (Max-Cut) of a graph [39]. We brieﬂy review
this application below, before showing our results for en-
hancing this optimization algorithm using MoMGrad and
QDD.
1.
Application & Methods
Consider a graph G = {V, E} of vertices V and edges
E. A cut set C ⊆E is deﬁned as a set of edges which
partitions the set of vertices in two. The maximum cut
is the largest such subset of edges. We can consider the
following Hamiltonian:
ˆHc =
X
{j,k}∈E
1
2(ˆI −ˆZj ˆZk)
(374)
where each vertex in j ∈V is assigned a qubit, with |0⟩j
or |1⟩j representing whether a given vertex is in partition
0 or partition 1. Each edge {j, k} ∈E is associated a
coupling of the form 1
2(ˆI −ˆZj ˆZk), which is an operator
of eigenvalue 1 if the both vertices of the edge are of
diﬀerent partitions, or of eigenvalue 0 if they are in the
same partition.
Thus, ﬁnding the computational basis state |b⟩which
is the maximal eigenvalue eigenstate of the Hamiltonian
(374), would be equivalent to ﬁnding the bitstring b of
partition labels for each vertex b = {bj}j∈V, bj ∈Z2∀j
which represents the Max-Cut set.
In order to ﬁnd this optimal state, we can apply the
Quantum Approximate Optimization Algorithm, with
ˆHc from (374) as the cost Hamiltonian and
ˆHm =
X
j∈V
ˆXj
(375)
as the mixer Hamiltonian. The parametric circuit to be
applied for the QAOA is then given by
ˆU(ˆΦ) =
P
Y
j=1
e−iˆΦ2j ˆ
Hme−iˆΦ2j−1 ˆ
Hc
(376)
where P is the number of alternating exponential steps,
and the loss function to be minimized is ˆL = −ˆHc. We
can use MomGrad or QDD to optimize this parametric
circuit in order to minimize the loss function (maximize
the Hamiltonian). The canonical choice of initial state
onto which one applies the above parametric circuit is
the superposition of all bitsrings,
|ψ0⟩≡
O
j∈V
|+⟩.
(377)
In general, after applying the QAOA parametric circuit
for some choice of parameters deemed suﬃciently optimal
Φ, the ﬁnal state should have a certain probablity of
being in the Max-Cut state, or at least a probability of
having states with a cut size close to this Max-Cut.
For our particular implementation of QAOA, we apply
it to ﬁnd the Max-Cut of the graph depicted in ﬁgure
39, which has a maximum cut of size 5. In ﬁgure 41,
we plot the probability of measuring a state which has
a cut size of 4 or more, for the expected parameters at
various iterations of the optimization. We see that the
probability of obtaining a near-optimal cut becomes high
(Pr(|C| ≥4) ⪆0.8 where C is the eigenvalue of ˆHc for
the measured bit string) as the training progresses, a sign
that the approximate optimization is working. For this
particular implementation, we chose a circuit with P = 2,
hence with only 4 parameters to be optimized, which we
depict in ﬁgure 40.
0
1
2
4
5
3
0
1
3
Figure 39. Graph G = {V, E} of |V| = 6 vertices and |E| = 5
edges for which we would like to leverage the QAOA in order
to ﬁnd the maximum cut. The maximum cut is represented
on the right, with the partition index being represented by
the vertex coloring, with either black (0) or white (1). Note
the Max-Cut set has cardinality 5 hence any cut set C for this
graph has |C| ≤5.
2.
Implementation & Results
In this subsection, we present training results for the
optimization of the QAOA parametric circuit using both
MoMGrad and QDD. This parametric circuit consists
of a P = 2 QAOA ansatz (depicted in ﬁgure 40), with
cost Hamiltonian from (374) and mixer Hamiltonian from
(375) for the graph depicted in ﬁgure 39.
Figure 40. QAOA P = 2 parametric circuit from equation 376
which was optimized for the results displayed in ﬁgure 41. The
cost and mixer Hamiltonians are those from equations (374)
and (375) for the graph depicted in ﬁgure 39.
In ﬁgure 41, we represent the probability of obtain-
ing a near-optimal cut, over the training iterations, for
MoMGrad, QDD, and a quantum-classical Nelder-Mead

76
method [89] (for comparison). For this implementation,
the parameters were simulated qudits of dimension d =
7. For the hyper-parameters, the kicking rate for both
QAOA and MoMGrad cases was kept at ηj = 0.35 ∀j.
The kinetic rate for QDD and MoMGrad were updated
as γj = 0.98j/4. The initial wavefunction for both QDD
and MoMGrad was a Gaussian of Σ0 = 1 for all pa-
rameters, with a mean Φ0 with each component sampled
from an independent classical Gaussian distribution of
standard deviation 0.5 and mean 0. For MoMGrad, the
subsequent standard deviation Σ(j)
0
= 0.98j for all com-
ponents for the jth iteration.
0
25
50
75
100
125
150
Iteration
0.2
0.4
0.6
0.8
Pr(|C| ≥4)
Classical Nelder-Mead
MoMGrad
QDD
Figure 41. Training results for optimizing the QAOA circuit
from ﬁgure 40 via MoMGrad and QDD. Displayed is the prob-
ability of measuring a bitstring which corresponds to a cut set
C of size 4 ≤C ≤5; near the optimum of 5 which is the Max
Cut set size. Additionally plotted above for comparison is a
Nelder-Mead optimized QAOA, which converges slower than
QDD and MoMGrad. We see that all 3 optimizers converge
to a probability Pr(|C| ≥4) ⪆0.8.
C.
Quantum Unitary Learning
In this subsection we demonstrate the implementa-
tion of quantum supervised unitary learning, see section
VI D 1 for more details on this task.
1.
Application & Methods
The task of supervised unitary learning, as described
in section VI D 1, is the following: given a set of input-
output pairs {|ψi
j⟩, |ψo
j ⟩} which are related by a uni-
tary mapping |ψo
j ⟩= ˆV |ψi
j⟩, ﬁnd a parameteric unitary
ansatz ˆU(Φ) and suﬃciently optimal parameters Φ∗such
that |ψo
j ⟩≈ˆU(Φ∗) |ψi
j⟩so as to generally approximate
the unitary ˆU(Φ∗) ≈ˆV , which should hold ideally for
input-output pairs which lie outside the given dataset.
For the implementation in this paper, we consider a
fairly simple case of learning a random single-qubit uni-
tary. Using a uniform measure on the unit sphere, we
can sample random points on the Bloch sphere and gen-
erate uniformly random single-qubit pure states.
The
input states |ψj⟩are thus generated by sampling from
the Bloch sphere. As for the unitary ˆV to be learned, we
ﬁrst sample a random state on the Bloch sphere, call it
|ϕV ⟩. Then we deﬁne the unitary ˆV to be learned as the
unitary such that ˆV † |ϕV ⟩= |0⟩, where |0⟩is the com-
putational basis null state of the qubit. The parametric
ansatz we use is represented in ﬁgure 42, it is a sequence
of parametric rotations about the x, y and z axes of the
Bloch sphere, in that order.
Figure 42. Parametric circuit ansatz applied in this imple-
mentation of supervised unitary learning. The rotations are
about the x, y and z axes of the Bloch sphere, in that order.
2.
Implementation & Results
Here we describe the details of the implementation of
the learning of random single-qubit unitaries via the use
of both QDD and MomGrad, for the parametric ansatz
presented in ﬁgure 42. The qudit dimension of the simu-
lated quantum parameters was d = 7.
Note that in order to apply the phase kick according
the output state projector loss function, eiη|ψo
j⟩⟨ψo
j|, we
implement the exponential of these states directly in the
numerics rather than with the quantum state exponenti-
ation tricks described in VI B. This was done to minimize
the classical memory overhead of simulation.
The phase kicks were applied in a sequential mini-
batches (see sec. IV A) of size 10.
Now, for the hyperparameters chosen for the training.
For both the QDD and MoMGrad training, the kicking
rates were kept at η = 0.2 for all iterations. For both
QDD and MoMGrad, the initial Gaussian wavefunction
over parameters was chosen to have standard deviation
Σ0 = 0.9 for all parameters, and the initial means P hi0
which were sampled from a normal distribution of null
mean and standard deviation 0.5. For QDD the kinetic
rate for iteration j was 0.2 · 0.98j. Featured in 43 are the
results of the average ﬁdelity throughout the training,
averaged over 5 diﬀerent optimization runs with diﬀerent
random unitaries to be learned in each case.

77
0
10
20
30
40
50
60
70
Iteration
0.6
0.7
0.8
0.9
1.0
Fidelity
MoMGrad
QDD
Figure 43.
Training results for single qubit random unitary
learning problem. Shown is the average ﬁdelity between the
states generated by applying the true unitary and the current
best estimate to the parametric unitary, averaged over 5 runs.
Each run had a diﬀerent random unitary to be learned. Both
QDD and MoMGrad converge to ⪆99.75% ﬁdelity.
D.
Hybrid Neural-Circuit Learning
In this section we numerically implement the train-
ing of a hybrid quantum-classical neural-circuit hybrid
network, as described in section VI I 2. That is, we con-
sider having a quantum parametric circuit whose output
is connected to a classical neural network.
1.
Application & Methods
In this particular implementation, we consider asking
the hybrid network to learn to readout the momentum
eigenvalue of a input momentum eigenstate, i.e., a com-
putational basis state in the canonical dual (Fourier) ba-
sis. This can be seen as a hybrid quantum state classiﬁ-
cation task. For this particular implementation, we look
at learning the quantum Fourier transform on 3 qubits.
Mathematically, we prepare a set of states {|ψj⟩=
ˆF |j⟩012}j∈Z8 where |j⟩= N2
k=0 |jk⟩is the binary repre-
sentation of the computational basis state of eigenvalue
j = P2
k=0 jk2k, ˆF is the 3-qubit Quantum Fourier trans-
form.
The network is fed quantum states along with
their corresponding desired label {|Ψj⟩, j}. The network
is tasked to learn how to correctly classify these states
according to their label. The task is then eﬀectively to
learn decode the eigenvalue of the operator ˆF † ˆJ ˆF, where
ˆJ =
X
j∈Z8
j |j⟩⟨j| =
2
X
k=0
2k−1(ˆIk −ˆZk).
(378)
We decompose this task of decoding the spectrum of
this operator in such a way to force cooperation between
the classical processing unit and the quantum process-
ing unit in order to obtain correct classiﬁcation.
The
learning is hybrid, as the quantum parametric circuit has
to learn the inverse Fourier transform F † gate decom-
position, while the classical network learns the correct
weighted combination of the readouts from the diﬀerent
qubit registers. Both networks must be optimized in a
joint fashion in order for the composite quantum-classical
mapping to guess the correct scalar corresponding to the
eigenvalue of ˆF † ˆJ ˆF for each possible input state.
The classical network must learn the aﬃne transfor-
mation which converts vectors of expectation values as
z = {⟨ˆZ⟩0 , ⟨ˆZ⟩1 , ⟨ˆZ⟩2} 7→P2
k=0 2k−1(1 −⟨ˆZk⟩) ≡y.
Meanwhile the quantum parametric circuit must learn
the canonical decomposition of the 3-qubit inverse QFT.
To restrict the number of quantum parameters needed
to simulate the learning of the inverse Fourier transform,
we only parametrize the controlled-Rz rotations of this
decomposition; the parametric circuit ansatz for this is
represented in ﬁgure 44. The neural network is a single-
layer of input activations with one neuron with RELU
activation as output.
Figure 44. Quantum Parametric Circuit Hybridized with a
classical Neural Network to learn the Quantum Fourier Trans-
form. Here each parametric rotation is of the form ˆR(Φ) =
|0⟩⟨0| + eiΦπ/4 |1⟩⟨1|.
We use quantum-parametric versions
of these rotations,
ˆR(ˆΦj), in order to perform quantum-
enhanced optimization of the latter via MoMGrad. The neu-
ral network connected to the output of the parametric circuit
is a single neuron with rectiﬁed linear unit (ReLu) activation.
2.
Implementation & Results
Using a numerical simulation of the QPU-CPU inter-
action, we simulate the implementation of the ﬁrst-order
hybrid quantum-classical MoMGrad described in section
VI I 2. The qudit dimension of the simulated quantum
parameters was d = 7 once again.
We use a hybrid network stochastic gradient descent,
where an iteration of gradient descent is performed for
each state and label combination {|Ψjk⟩, jk}k. The loss
function to be optimized was the mean squared error:
for a network prediction at the output of value ˜yk, and a
desired label value jk, the loss function is given by
L(˜yk, jk) := (˜yk −jk)2.
(379)
The gradient of such a loss function is straightforward to
obtain. The optimization procedure is that which is de-

78
scribed in section VI I 2. The results of the hybrid train-
ing are presented in ﬁgure 45.
Let us now describe the set of hyperparameters cho-
sen to generate the results featured in ﬁgure 45.
The
learning rate for the classical network and the kicking
rate for the parametric circuit QFB were both kept at
η = 0.15 throughout the training. The quantum param-
eters' initial wavefunction was a Gaussian of Σ0 = 0.65
for all parameters, with a mean Φ0 whose components
were each sampled from independent classical Gaussian
distributions of standard deviation 0.5 and mean 0. For
the MoMGrad pointer states of further iterations, the
subsequent standard deviations were Σ(j)
0
= 0.65 · 0.98j
in all components for the jth iteration.
0
5
10
15
20
25
30
Iteration
0
2
4
6
Mean Squared Error
Classical SGD BackProp + MoMGrad
Figure 45.
Training results for parametric circuit and classi-
cal neural network hybrid learning, for the network featured in
ﬁgure 44. Shown is the mean squared error between the neural
network output and the true label. The training was executed
using the hybrid gradient descent technique described in sec-
tion VI I 2. Towards the end of training the Mean Squared
Error (average squared distance between labels averaged over
the dataset) converges to ⪅0.12, thus indicating successful
training.
VIII.
DISCUSSION & OUTLOOK
In this section we discuss potential implementations,
implications, and possible future extensions of this work.
1.
Near-term considerations
We begin with a discussion of potential near-term im-
plementations. Parametric circuits have been shown to
be successfully implementable on NISQ (Noisy Interme-
diate Scale Quantum) devices [49]. Due to the variational
nature of parametric circuits optimization algorithms, in
the presence of noise, the parametric transformations can
adjust in order to partially counter the eﬀects of noise. As
there is currently no standard criterion quantifying how
robust a certain algorithm is to noise, and since execu-
tion performance can vary greatly depending both on the
device and the algorithm, most approaches have resorted
to empirically checking performance on a case-wise ba-
sis. The common conception is that algorithms with low-
depth quantum circuits using a quantum-classical opti-
mization loop which relies only on expectation values of
simple observables tend to be somewhat robust to noise.
Thus, it is diﬃcult to predict whether a certain optimizer
and ansatz will perform well under various noise condi-
tions but in this section we shall speculate as to which
protocols have the best chance of being implementable in
the near-term.
From the optimizers presented in this paper, although
QDD has the potential for non-trivial tunneling in the
optimization landscape, MoMGrad is the protocol with
the best chance of execution on near-term devices due
to its lower circuit depth requirements. In the case of
MoMGrad, for a low-depth circuit ansatz, assuming hav-
ing quantum parameters does not increase depth of ex-
ecution of a parametric gate, the quantum feedforward
and Baqprop should generally also be a low-depth cir-
cuit. The MoMGrad circuit includes twice the depth of
the original ansatz plus an added depth due the exponen-
tial of the loss function. For simple loss functions, such
as is the case for quantum classiﬁers for example, the
exponential of the loss adds very minimal depth, while
for loss operators with non-commuting terms (e.g. for
Hamiltonian optimization), one can leverage the Gradi-
ent Expectation Estimation technique from section VI H
to split up the gradient over multiple runs for the various
terms.
As for the eﬃcient execution of quantum-parametric
gates, there are a few options that could be tractable
while adding minimal depth relative to a classically
parametrized circuit ansatz. The most elementary form
of a quantum parameter register would be using a sin-
gle qubit instead of a qudit.
As mentioned in section
IV B, one can use a qubit to estimate the phase kickback
induced by Baqprop, analogous to single-qubit phase es-
timation, at the cost of having to execute multiple runs
in order to estimate the gradient to a suﬃciently high
precision. Generally, one could use perhaps only a few
qubits (e.g.
on the order of 2 or 3) to form a qudit
of potentially suﬃcient dimension for multiple applica-
tions.
For such low numbers of qubits, the Quantum
Fourier transform is quite low depth, hence the gradient
readout should be relatively robust to noise. Our numer-
ical experiments in section VII showed a good perfor-
mance with only 7-dimensional qudits (achievable with 3
qubits). On the other hand since these were classical sim-
ulations of quantum computation, the expectation values
could be extracted directly from the simulator, whereas
a real quantum computation would necessitate multiple
runs. Thus using a small-dimensional qudit (using a few
qubits) for the parameters may be suﬃcient for some
applications, but in general one would expect the perfor-
mance to decay for many parameters since the readout

79
of the gradient value is stochastic and could be greatly
inﬂuenced by noise during the execution of the Quantum
Fourier transform. Using language from section II, not
only can there be underﬂow error (phase kick too small
to be well detected) but there can also be overﬂow error,
where the gradient phase kick exceeds the range of the
qudit or qubit.
A possible alternative to qudits and qubits for imple-
mentation of the quantum parameters would be to use
a continuous variable (CV) quantum mode (qumode) for
each parameter.
Note that the formalism and deriva-
tions throughout this paper were compatible with both
simulated (qudit) qumodes and physical qumodes. Most
current implementations of quantum computing, whether
it be via superconducting qubits or trapped ions, have
ways to build and control quantum harmonic oscilla-
tors on-chip [90, 91]. Using CV modes as quantum pa-
rameters would require the ability to prepare squeezed
states, the ability to perform measurements of the po-
sition/momentum quadratures, and for the execution of
qubit-based circuit ansatze, the qumodes would need to
be able to couple to qubits via an interaction of the form
depicted in equation (286). A potential advantage of us-
ing a physical qumode for readout is its robustness to
small perturbations in its phase or position.
For con-
trast, a small error on one qubit of in a multi-qubit Quan-
tum Fourier transform can lead to a signiﬁcant change in
the readout value of the qudit position, whereas a small
nudge of the qumode leads to a small change in read-
out value. Thus one could expect that the readout of
the gradient values would be more robust to noise using
analog qumodes. The eﬀective phase estimation capacity
of the qumode will then be determined by its degree of
squeezing [92, 93].
As for the implementation of the quantum-coherent
classical neural networks from section V, both small-
dimensional qudits or qumodes could work for the neu-
rons in the near-term, the same arguments from above
concerning the quantum parameters apply.
One prob-
lem that may arise chaining many low-dimensional qu-
dits' controlled-displacements (feedforward operations)
is that any sort of under/overﬂow errors could add up
exponentially with the depth. On the other hand, the
current trend in classical machine learning has been to
employ low-precision arithmetic [94] for deep learning,
which would suggest that not all classical deep learn-
ing algorithms necessitate high-precision ﬂoating points
for eﬀective operation and training. As such, one may
consider few-qubit precision quantum-coherent neurons
potentially suﬃcient in precision. One could even poten-
tially consider the noise induced from the qudit impre-
cision as a form of regularization during both the feed-
forward an Baqprop phases. For further details on the
inﬂuence of qudit imprecision on the feedforward opera-
tion, and for more details on potential physical CV im-
plementations, see section V C.
Let us now consider which applications from section VI
have the best chance of being near-term implementable.
As mentioned above, apart from the overheads of us-
ing quantum parameters to execute the feedforward of
the parametric circuit, a key component to determin-
ing whether or not a certain Quantum Feedforward and
Baqprop circuit is implementable in the near-term is the
circuit depth required for the execution of the the expo-
nential of the loss function. For any quantum data appli-
cation which requires quantum state exponentiation, one
could consider the near-term implementation of such an
algorithm as unlikely, mainly due to the large overheads
of have multiple Fredkin gates, and of batching quan-
tum state exponentials sequentially. On the other hand,
quantum classiﬁcation, including measurement learning
and quantum regression, have fairly simple cost functions
which can be exponentiated as simple exponentials of
standard basis observables. Another set of networks with
a chance of near-term implementation are the Quantum-
classical Hybrid neural-circuit hybrids, which as one may
recall from section VI I 2, can be built from paramet-
ric circuits for quantum classiﬁers/regression. One may
imagine that having some additional classical neural pro-
cessing after a quantum parametric circuit may reduce
the need for depth of the quantum circuit to attain
the same transformation or accomplish a given learn-
ing task many cases. Additionally, the feedforward step
only relies on simple expectation values of simple ob-
servables, hence it should be robust to noise according
to our criterion mentioned above. Finally, Hamiltonian
Optimization, which includes the Variational Quantum
Eigensolver and the Quantum Approximate Optimiza-
tion Algorithm, should be implementable on near-term
hardware with Baqprop.
For Hamiltonians that are a
sum of commuting terms, the Quantum Feedforward
and Baqprop approach is straightforward, and for non-
commuting terms in the Hamiltonian, one can use the
Gradient Expectation Estimation technique (GEEP, sec.
VI H), which allows for parallelization of the gradient ac-
cumulation over multiple runs.
2.
Further-term considerations
We now proceed to considering potential interesting
applications in the further-term, as well as future work.
In the long-term, with the advent of large-scale error-
corrected fault-tolerant quantum computers, the possi-
bility of training large-scale classical neural networks on
quantum computers, as presented in section V, will be-
come tractable. At that moment, one may want to con-
sider training neural networks with the Quantum Dy-
namical Descent (QDD) approach. QDD may be more
powerful than simple gradient descent in some instances,
due to being an eﬀective Quantum Approximate Opti-
mization of the parameters. Furthermore, with a large
scale error-corrected quantum computer one could test
the training of quantum neural networks using Quantum
Meta-Learning (sec. IV D), for either the optimization
of hyper-parameters or network architecture to improve

80
generalization error. If one were to apply the Meta-QDD
protocol to either of these meta-learning applications,
which would consist of a quantum dynamical simulation
of descent (with possible tunneling) in the space of possi-
ble network architectures or hyper-parameters, one could
imagine the distribution over such hyper-parameters dif-
ﬁcult to simulate. Again this is would be due the known
diﬃculty of simulating samples from a QAOA [40]. Em-
pirical testing of possible advantages of Quantum Meta-
Learning via its large-scale implementation could yield
potentially interesting results.
As a side-note, although we only treated how to quan-
tize and train classical feedforward networks, the opti-
mization methods featured in this paper could poten-
tially be used to train classical Boltzmann machines. In
recent work, it was shown that one could train Quantum
Boltzmann machines using QAOA-type quantum para-
metric circuits [38].
The QAOA was used to approxi-
mately sample from various Gibbs distributions of net-
works, such sampling is a necessary step to perform (clas-
sical) gradient descent of the network's weights. Thus,
using techniques developed in this paper, one could po-
tentially consider enhancing the optimization of the para-
metric QAOA circuit via MoMGrad or QDD, such as to
leverage Baqprop to accelerate the Gibbs sampling at
each gradient descent.
If one were to go further and
also consider the Boltzmann machine's weights as quan-
tum parameters along with the corresponding paramet-
ric circuit's parameters, one could then potentially us a
meta-QDD optimization loop to quantumly the optimize
Boltzmann machine weights, similar to that featured in
section IV D. We leave further details of this approach
for future work.
Another interesting avenue of future exploration is the
possibility of performing quantum deep learning in a
massively quantum-parallelized fashion across a quan-
tum network.
Very recently, the ﬁrst experimental
demonstration of quantum state transfer between quan-
tum computing chips was successfully implemented [95].
Eventually, with Quantum Error Corrected state trans-
fers, parallelization of algorithms across multiple quan-
tum chips will become a feasibility. As we showed in sec-
tion IV, various parallelization and regularizaton proto-
cols such as the Coherent Accumulation of Momenta Par-
allelization protocol (CAMP, sec. IV A 3) and the Meta-
networked Swarm Optimization (MISO, sec. IV C 2) can
take advantage of a quantum network of quantum pro-
cessing units to improve the precision and time require-
ments of training networks.
In the particular case of
CAMP, there is a square root speedup to get the expec-
tation value of the gradient over a minibatch within a
certain precision as compared to classical parallelization.
In modern classical deep learning, parallelization is key
to training large-scale neural networks in a feasible time
frame [65], it is thus to be expected that once quantum
algorithms can reach a certain scale, parallelization be-
comes indispensable, just as it is in the classical case.
Now, let us mention some avenues for further possible
mathematical analyses which could be conducted. A ﬁrst
one is to provide a more detailed analysis of the resource
overheads of synthesizing gate sequences for the various
protocols studied in this paper. As we established multi-
ple connections with quantum simulation theory, perhaps
tools from this subﬁeld could be ported over to quantum
deep learning.
In terms of the further analysis of the
eﬀective physics of the parameters for QDD, one could
view the stochastic QFB phase kicks as a repeated in-
teraction with an environment (in this case the compute
registers).
One could then perform an analysis of the
eﬀective open system dynamics and disspation terms at
higher-orders of the kicking rate.
Finally, now that we have added multiple optimization
techniques to the repertoire of quantum deep learning
tools, the key to making quantum deep learning feasible
for large-scale quantum parametric circuits will require
new quantum parametric ansatze.
As pointed out by
McClean et al. [51], most current quantum parametric
ansatze relying on random circuits of qubits have van-
ishing gradients.
Similar to the problem of vanishing
gradients in classical machine learning, current paramet-
ric ansatz have exponentially vanishing gradients in the
number of degrees of freedom. Further study into the
mechanism behind the obtention of gradients of paramet-
ric circuits is necessary in order to allow for the design
of new ansatze which could solve this vanishing gradient
problem. In section V B, we explicitly detailed the mech-
anism for the backward quantum propagation of phase
errors through the quantum-coherent neural networks.
One could then potentially extend the analysis presented
in section VI for the layerwise backpropagation of the
gradient signal in general quantum parametric circuits
such as to provide the same level of detail as to how the
gradient (phase kick) signal travels through the compute
registers in order to inﬂuence the parameters. By choos-
ing speciﬁc ansatze, one could examine the generators
of each parametric circuit element, and possibly repli-
cate the level of detail of the analysis from V B for this
speciﬁc parametric ansatz. Such an analysis would have
the potential to shed new light on the vanishing gradient
problem and point towards solutions. We leave an anal-
ysis of this kind for general parametric quantum circuit
ansatze for future work.
IX.
CONCLUSION
The goal of this paper was to establish a bridge be-
tween the theories of classical and quantum deep learn-
ing, such as to allow for the exchange of tools and the
gain of new insights in both ﬁelds. In alignment with
this goal, we took inspiration from classical deep learn-
ing techniques to create numerous new methods for the
quantum-enhanced optimization of quantum parametric
networks on a quantum computer. Furthermore, we ex-
plored various ways classical deep learning can leverage
quantum computation for optimization, and how classi-

81
cal and quantum deep learning optimization strategies
can directly interface with one another.
More speciﬁcally, we introduced a uniﬁed approach
to the optimization of quantum parametric circuits and
classical neural networks on a quantum computer, based
on a universal error backpropagation principle for quan-
tum parametric networks.
We then further extended
these quantum optimization methods with a compatible
set of tools for parallelization, regularization, and meta-
learning. Furthermore, we detailed how to leverage these
optimization strategies for the eﬀective training of any
classical feedforward neural network on a quantum com-
puter, as well as for numerous quantum parametric cir-
cuit applications. We numerically tested both core op-
timization algorithms on multiple such applications, em-
pirically demonstrating their eﬀectiveness.
Finally, we
introduced a way to merge classical and quantum back-
propagation between classical and quantum computers,
opening up the possibility for the ﬁeld of truly hybrid
quantum-classical deep learning.
We hope that the work presented in this paper will bol-
ster further work exploring this nascent ﬁeld of Quantum
Deep Learning.
X.
ACKNOWLEDGEMENTS
Quantum circuit simulations featured in this paper
were executed on the Rigetti Forest Quantum Virtual
Machine, with code written in PyQuil [88]. The authors
would like to thank Rigetti Computing and its team for
providing computing infrastructures and continued sup-
port for Forest. The authors would also like to thank
Steve Weiss and the Information Technology team at the
IQC for providing additional computing infrastructures
and IT support for this project. The authors would like
to thank Atmn Patel for useful discussions, as well as
Achim Kempf for the support. GV and JP acknowledge
funding from NSERC.
[1] I. Goodfellow, Y. Bengio, and A. Courville, Deep Learn-
ing (MIT Press, 2016) http://www.deeplearningbook.
org.
[2] D. P. Kingma and J. Ba, ArXiv e-prints
(2014),
arXiv:1412.6980 [cs.LG].
[3] M. D. Zeiler, ArXiv e-prints
(2012), arXiv:1212.5701
[cs.LG].
[4] M. Bojarski, D. Del Testa, D. Dworakowski, B. Firner,
B. Flepp, P. Goyal, L. D. Jackel, M. Monfort, U. Muller,
J. Zhang, X. Zhang, J. Zhao,
and K. Zieba, ArXiv e-
prints (2016), arXiv:1604.07316 [cs.CV].
[5] I. Sutskever, O. Vinyals,
and Q. V. Le, ArXiv e-prints
(2014), arXiv:1409.3215 [cs.CL].
[6] A.
van
den
Oord,
S.
Dieleman,
H.
Zen,
K.
Si-
monyan, O. Vinyals, A. Graves, N. Kalchbrenner, A. Se-
nior,
and K. Kavukcuoglu, ArXiv e-prints
(2016),
arXiv:1609.03499 [cs.SD].
[7] T. Mikolov, K. Chen, G. Corrado, and J. Dean, ArXiv
e-prints (2013), arXiv:1301.3781 [cs.CL].
[8] K. He, X. Zhang, S. Ren,
and J. Sun, ArXiv e-prints
(2015), arXiv:1512.03385 [cs.CV].
[9] V.
Mnih,
K.
Kavukcuoglu,
D.
Silver,
A.
Graves,
I. Antonoglou, D. Wierstra,
and M. Riedmiller, ArXiv
e-prints (2013), arXiv:1312.5602 [cs.LG].
[10] D. P. Kingma and M. Welling, ArXiv e-prints
(2013),
arXiv:1312.6114 [stat.ML].
[11] I. J. Goodfellow, J. Pouget-Abadie, M. Mirza, B. Xu,
D. Warde-Farley, S. Ozair, A. Courville, and Y. Bengio,
ArXiv e-prints (2014), arXiv:1406.2661 [stat.ML].
[12] D. E. Rumelhart, G. E. Hinton,
and R. J. Williams,
Nature 323, 533 (1986).
[13] P. Domingos, The Master Algorithm: How the Quest for
the Ultimate Learning Machine Will Remake Our World
(Penguin Books Limited, 2015).
[14] S. P. Jordan, Physical Review Letters 95, 050501 (2005),
quant-ph/0405146.
[15] A. Gily´en, S. Arunachalam,
and N. Wiebe, ArXiv e-
prints (2017), arXiv:1711.00465 [quant-ph].
[16] B. Catanzaro, M. Garland, and K. Keutzer, in Proceed-
ings of the 16th ACM symposium on Principles and prac-
tice of parallel programming - PPoPP '11 (ACM Press,
2011).
[17] N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever,
and R. Salakhutdinov, Journal of Machine Learning Re-
search 15, 1929 (2014).
[18] A. Krogh and J. A. Hertz, in Advances in neural infor-
mation processing systems (1992) pp. 950-957.
[19] J. Biamonte, P. Wittek, N. Pancotti, P. Rebentrost,
N. Wiebe, and S. Lloyd, Nature 549, 195 (2017).
[20] S. Lloyd, M. Mohseni, and P. Rebentrost, Nature Physics
10, 631 (2014).
[21] P. Rebentrost, M. Mohseni,
and S. Lloyd, Physical re-
view letters 113, 130503 (2014).
[22] M.
Schuld
and
N.
Killoran,
arXiv
preprint
arXiv:1803.07128 (2018).
[23] V. Havlicek, A. D. C´orcoles, K. Temme, A. W. Har-
row, J. M. Chow, and J. M. Gambetta, arXiv preprint
arXiv:1804.11326 (2018).
[24] V. Giovannetti, S. Lloyd, and L. Maccone, Physical re-
view letters 100, 160501 (2008).
[25] S. Arunachalam, V. Gheorghiu, T. Jochym-OConnor,
M. Mosca, and P. V. Srinivasan, New Journal of Physics
17, 123010 (2015).
[26] E. Farhi and H. Neven, arXiv preprint arXiv:1802.06002
(2018).
[27] H. Chen, L. Wossnig, S. Severini, H. Neven,
and
M. Mohseni, arXiv preprint arXiv:1805.08654 (2018).
[28] E. Grant, M. Benedetti, S. Cao, A. Hallam, J. Lockhart,
V. Stojevic, A. G. Green, and S. Severini, arXiv preprint
arXiv:1804.03680 (2018).
[29] A. Peruzzo, J. McClean, P. Shadbolt, M.-H. Yung, X.-Q.
Zhou, P. J. Love, A. Aspuru-Guzik,
and J. L. Obrien,
Nature communications 5, 4213 (2014).
[30] R. Salakhutdinov and H. Larochelle, in Proceedings of
the thirteenth international conference on artiﬁcial intel-
ligence and statistics (2010) pp. 693-700.

82
[31] M. H. Amin, E. Andriyash, J. Rolfe, B. Kulchytskyy, and
R. Melko, Physical Review X 8, 021050 (2018).
[32] S. H. Adachi and M. P. Henderson, arXiv preprint
arXiv:1510.06356 (2015).
[33] H. Neven, G. Rose, and W. G. Macready, arXiv preprint
arXiv:0804.4457 (2008).
[34] M. Mohseni and H. Neven, "Constructing and program-
ming quantum hardware for robust quantum annealing
processes," (2016), uS Patent App. 15/109,614.
[35] T. F. Rønnow, Z. Wang, J. Job, S. Boixo, S. V. Isakov,
D. Wecker, J. M. Martinis, D. A. Lidar, and M. Troyer,
Science 345, 420 (2014).
[36] M. Benedetti,
J. Realpe-G´omez,
R. Biswas,
and
A. Perdomo-Ortiz, Physical Review A 94, 022308 (2016).
[37] H. G. Katzgraber, F. Hamze, Z. Zhu, A. J. Ochoa, and
H. Munoz-Bauza, Physical Review X 5, 031026 (2015).
[38] G. Verdon, M. Broughton,
and J. Biamonte, arXiv
preprint arXiv:1712.05304 (2017).
[39] E. Farhi, J. Goldstone, and S. Gutmann, arXiv preprint
arXiv:1411.4028 (2014).
[40] E.
Farhi
and
A.
W.
Harrow,
arXiv
preprint
arXiv:1602.07674 (2016).
[41] S. Hadﬁeld,
Z. Wang,
B. O'Gorman,
E. G. Rief-
fel,
D. Venturelli,
and R. Biswas, arXiv preprint
arXiv:1709.03489 (2017).
[42] E. Farhi, J. Goldstone, S. Gutmann,
and M. Sipser,
arXiv preprint quant-ph/0001106 (2000).
[43] E. Farhi, J. Goldstone, and S. Gutmann, arXiv preprint
quant-ph/0201031 (2002).
[44] E. Crosson, E. Farhi, C. Y.-Y. Lin, H.-H. Lin,
and
P. Shor, arXiv preprint arXiv:1401.7320 (2014).
[45] E. Crosson and A. W. Harrow, in Foundations of Com-
puter Science (FOCS), 2016 IEEE 57th Annual Sympo-
sium on (IEEE, 2016) pp. 714-723.
[46] W. Zeng, N. Rubin, M. Curtis, A. Polloreno, R. Smith,
J. Angeles, B. Bloom, M. Block, S. Caldwell, W. O'Brien,
et al., in APS Meeting Abstracts (2017).
[47] M.
Benedetti,
D.
Garcia-Pintos,
Y.
Nam,
and
A.
Perdomo-Ortiz,
arXiv
preprint
arXiv:1801.07686
(2018).
[48] J. R. McClean, J. Romero, R. Babbush, and A. Aspuru-
Guzik, New Journal of Physics 18, 023023 (2016).
[49] J. Preskill, arXiv preprint arXiv:1801.00862 (2018).
[50] D. Gottesman, in Quantum information science and its
contributions to mathematics, Proceedings of Symposia
in Applied Mathematics, Vol. 68 (2010) pp. 13-58.
[51] J. R. McClean, S. Boixo, V. N. Smelyanskiy, R. Babbush,
and H. Neven, arXiv preprint arXiv:1803.11173 (2018).
[52] J. Romero, J. P. Olson, and A. Aspuru-Guzik, Quantum
Science and Technology 2, 045001 (2017).
[53] P.
D.
Johnson,
J.
Romero,
J.
Olson,
Y.
Cao,
and A. Aspuru-Guzik, arXiv preprint arXiv:1711.02249
(2017).
[54] S.
Lloyd
and
C.
Weedbrook,
arXiv
preprint
arXiv:1804.09139 (2018).
[55] M. A. Nielsen and I. Chuang, "Quantum computation
and quantum information," (2002).
[56] R. D. Somma, arXiv preprint arXiv:1503.06319 (2015).
[57] D. Gross, Journal of mathematical physics 47, 122107
(2006).
[58] S. D. Bartlett, B. C. Sanders, S. L. Braunstein,
and
K. Nemoto, in Quantum Information with Continuous
Variables (Springer, 2002) pp. 47-55.
[59] A. Messiah and E. Q. M. D. B. On, "Quantum mechanics,
dover books on physics," (2014).
[60] S. Ruder, arXiv preprint arXiv:1609.04747 (2016).
[61] M. D. Zeiler, arXiv preprint arXiv:1212.5701 (2012).
[62] D. P. Kingma and J. Ba, arXiv preprint arXiv:1412.6980
(2014).
[63] L.
Bottou,
in
Proceedings
of
COMPSTAT'2010
(Springer, 2010) pp. 177-186.
[64] R.
Horodecki,
P.
Horodecki,
M.
Horodecki,
and
K. Horodecki, Reviews of modern physics 81, 865 (2009).
[65] J. Dean, G. Corrado, R. Monga, K. Chen, M. Devin,
M. Mao, A. Senior, P. Tucker, K. Yang, Q. V. Le, et al.,
in Advances in neural information processing systems
(2012) pp. 1223-1231.
[66] C. L. Degen, F. Reinhard, and P. Cappellaro, Reviews
of modern physics 89, 035002 (2017).
[67] K. Marshall, R. Pooser, G. Siopsis, and C. Weedbrook,
Physical Review A 91, 032321 (2015).
[68] H.-K. Lau, R. Pooser, G. Siopsis,
and C. Weedbrook,
Physical review letters 118, 080501 (2017).
[69] V. Jelic and F. Marsiglio, European Journal of Physics
33, 1651 (2012).
[70] A. Neelakantan, L. Vilnis, Q. V. Le, I. Sutskever,
L. Kaiser, K. Kurach,
and J. Martens, arXiv preprint
arXiv:1511.06807 (2015).
[71] R. Vilalta and Y. Drissi, Artiﬁcial Intelligence Review
18, 77 (2002).
[72] J. Bergstra and Y. Bengio, Journal of Machine Learning
Research 13, 281 (2012).
[73] S. Hochreiter, A. S. Younger,
and P. R. Conwell, in
International Conference on Artiﬁcial Neural Networks
(Springer, 2001) pp. 87-94.
[74] M. Andrychowicz, M. Denil, S. Gomez, M. W. Hoﬀman,
D. Pfau, T. Schaul, B. Shillingford, and N. De Freitas,
in Advances in Neural Information Processing Systems
(2016) pp. 3981-3989.
[75] C. Finn, P. Abbeel,
and S. Levine, ArXiv e-prints
(2017), arXiv:1703.03400 [cs.LG].
[76] T. H¨aner, M. Roetteler, and K. M. Svore, arXiv preprint
arXiv:1805.12445 (2018).
[77] L. B. Rall, Automatic diﬀerentiation: Techniques and ap-
plications (Springer, 1981).
[78] V. Kliuchnikov, D. Maslov, and M. Mosca, IEEE Trans-
actions on Computers 65, 161 (2016).
[79] R. Barends, J. Kelly, A. Megrant, A. Veitia, D. Sank,
E. Jeﬀrey, T. C. White, J. Mutus, A. G. Fowler,
B. Campbell, et al., Nature 508, 500 (2014).
[80] B. W. Shore and P. L. Knight, Journal of Modern Optics
40, 1195 (1993).
[81] P.-L. Dallaire-Demers and N. Killoran, arXiv preprint
arXiv:1804.08641 (2018).
[82] T. R. Bromley and P. Rebentrost, arXiv preprint
arXiv:1803.07039 (2018).
[83] S. Kimmel, C. Y.-Y. Lin, G. H. Low, M. Ozols, and T. J.
Yoder, npj Quantum Information 3, 13 (2017).
[84] M. M. Wilde, Quantum information theory (Cambridge
University Press, 2013).
[85] I.
H.
Kim
and
B.
Swingle,
arXiv
preprint
arXiv:1711.07500 (2017).
[86] S. Lloyd, Science , 1073 (1996).
[87] D. Poulin, A. Qarry, R. Somma, and F. Verstraete, Phys-
ical review letters 106, 170501 (2011).
[88] R. S. Smith, M. J. Curtis,
and W. J. Zeng, ArXiv e-
prints (2016), arXiv:1608.03355 [quant-ph].

83
[89] J. C. Lagarias, J. A. Reeds, M. H. Wright,
and P. E.
Wright, SIAM Journal on optimization 9, 112 (1998).
[90] J. Poyatos, J. Cirac, and P. Zoller, Physical review letters
77, 4728 (1996).
[91] M. Hofheinz, H. Wang, M. Ansmann, R. C. Bialczak,
E. Lucero, M. Neeley, A. O'connell, D. Sank, J. Wenner,
J. M. Martinis, et al., Nature 459, 546 (2009).
[92] N. Liu, J. Thompson, C. Weedbrook, S. Lloyd, V. Vedral,
M. Gu,
and K. Modi, Physical Review A 93, 052304
(2016).
[93] G. Verdon-Akzam, Probing Quantum Fields: Measure-
ments and Quantum Energy Teleportation, Master's the-
sis, University of Waterloo (2017).
[94] S.
Gupta,
A.
Agrawal,
K.
Gopalakrishnan,
and
P. Narayanan, in International Conference on Machine
Learning (2015) pp. 1737-1746.
[95] P. Kurpiers, P. Magnard, T. Walter, B. Royer, M. Pechal,
J. Heinsoo, Y. Salath´e, A. Akin, S. Storz, J. Besse, et al.,
Nature 558, 264 (2018).

